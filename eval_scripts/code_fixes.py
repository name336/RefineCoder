"""
Code fixing utilities for LLM-generated code.

This module provides functions to fix common issues in code generated by LLMs:
1. Escaped newlines: Fix double-escaped \\n sequences
2. Missing imports: Auto-detect and add missing typing/collections imports
3. Function name consistency: Ensure generated function names match entry_point
"""

import re


def extract_all_top_level_function_names(code: str) -> list:
    """Extract all top-level function names from code (not nested functions).
    
    Returns a list of function names in order of appearance.
    """
    function_names = []
    pattern = r'^def\s+(\w+)\s*\('
    for line in code.split('\n'):
        match = re.match(pattern, line)
        if match:
            function_names.append(match.group(1))
    return function_names


def fix_escaped_newlines(code: str) -> str:
    """Fix double-escaped newlines in code.
    
    Some LLM responses return literal '\\n' strings instead of actual newlines.
    This function detects and fixes this issue.
    
    Detection strategy:
    - If code has very few actual newlines (0-2) but contains literal '\\n' sequences (>=3)
    - And the code appears to have multiple statements (contains 'def ' or multiple ':')
    - Then replace literal '\\n' with actual newlines
    """
    actual_newline_count = code.count('\n')
    literal_newline_count = code.count('\\n')
    if actual_newline_count <= 2 and literal_newline_count >= 3:
        if 'def ' in code or code.count(':') >= 2:
            code = code.replace('\\n', '\n').replace('\\t', '\t')
    return code


def fix_missing_imports(code: str) -> str:
    """Auto-detect and add missing import statements for common types and modules.
    
    LLM-generated code often uses type hints like List, Dict, etc. without importing them.
    This function detects such usage and adds the necessary imports.
    
    Supported typing imports: List, Dict, Tuple, Set, Optional, Union, Any, Callable, 
                              Iterable, Iterator, Sequence
    Supported collections imports: Counter, defaultdict, deque, OrderedDict
    """
    # Define typing module types and their patterns
    typing_types = {
        'List': r'\bList\s*\[',
        'Dict': r'\bDict\s*\[',
        'Tuple': r'\bTuple\s*\[',
        'Set': r'\bSet\s*\[',
        'Optional': r'\bOptional\s*\[',
        'Union': r'\bUnion\s*\[',
        'Any': r'\bAny\b',
        'Callable': r'\bCallable\s*\[',
        'Iterable': r'\bIterable\s*\[',
        'Iterator': r'\bIterator\s*\[',
        'Sequence': r'\bSequence\s*\[',
    }
    
    # Define collections module types
    collections_types = {
        'Counter': r'\bCounter\s*\(',
        'defaultdict': r'\bdefaultdict\s*\(',
        'deque': r'\bdeque\s*\(',
        'OrderedDict': r'\bOrderedDict\s*\(',
    }
    
    # Check what's already imported
    existing_imports = set()
    for line in code.split('\n'):
        line_stripped = line.strip()
        if line_stripped.startswith('from typing import'):
            import_part = line_stripped.replace('from typing import', '').strip()
            for name in import_part.split(','):
                existing_imports.add(name.strip())
        elif line_stripped.startswith('from collections import'):
            import_part = line_stripped.replace('from collections import', '').strip()
            for name in import_part.split(','):
                existing_imports.add(name.strip())
    
    # Find missing typing imports
    missing_typing = []
    for type_name, pattern in typing_types.items():
        if type_name not in existing_imports and re.search(pattern, code):
            missing_typing.append(type_name)
    
    # Find missing collections imports
    missing_collections = []
    for type_name, pattern in collections_types.items():
        if type_name not in existing_imports and re.search(pattern, code):
            missing_collections.append(type_name)
    
    # Build import statements to add
    imports_to_add = []
    if missing_typing:
        imports_to_add.append(f"from typing import {', '.join(sorted(missing_typing))}")
    if missing_collections:
        imports_to_add.append(f"from collections import {', '.join(sorted(missing_collections))}")
    
    # Add imports at the beginning of the code
    if imports_to_add:
        import_block = '\n'.join(imports_to_add) + '\n\n'
        # Find where to insert (after any existing imports, or at the beginning)
        lines = code.split('\n')
        insert_idx = 0
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            if line_stripped.startswith('import ') or line_stripped.startswith('from '):
                insert_idx = i + 1
            elif line_stripped and not line_stripped.startswith('#'):
                # Found non-import, non-comment line
                break
        
        if insert_idx > 0:
            # Insert after existing imports
            lines.insert(insert_idx, '\n'.join(imports_to_add))
            code = '\n'.join(lines)
        else:
            # No existing imports, add at the beginning
            code = import_block + code
    
    return code


def find_main_function_to_replace(code: str, entry_point: str) -> str:
    """Find the main function that should be renamed to entry_point.
    
    Returns the function name to replace, or empty string if no replacement needed.
    """
    all_functions = extract_all_top_level_function_names(code)
    
    # If entry_point already exists, no replacement needed
    if entry_point in all_functions:
        return ''
    
    # If no functions found, nothing to replace
    if not all_functions:
        return ''
    
    # If only one function, that's the one to replace
    if len(all_functions) == 1:
        return all_functions[0]
    
    # Multiple functions: find the main one (usually the last non-helper function)
    # Helper function patterns that should NOT be replaced
    helper_patterns = [
        'is_', 'has_', 'check_', 'helper_', 'validate_', 'get_', 
        '_helper', '_check', '_validate', 'can_', 'should_'
    ]
    
    # Find candidate main functions (non-helper functions)
    main_candidates = []
    for func_name in all_functions:
        is_helper = any(func_name.lower().startswith(p) or func_name.lower().endswith(p.lstrip('_')) 
                       for p in helper_patterns)
        if not is_helper:
            main_candidates.append(func_name)
    
    # If we have main candidates, use the last one
    if main_candidates:
        return main_candidates[-1]
    
    # If all functions look like helpers, use the last one anyway
    return all_functions[-1]


def replace_function_name(code: str, old_name: str, new_name: str) -> str:
    """Replace function name in code (both definition and calls).
    
    Args:
        code: The source code string
        old_name: The function name to replace
        new_name: The new function name
        
    Returns:
        Modified code with function name replaced
    """
    if not old_name or old_name == new_name:
        return code
    
    # Replace function definition: def old_name( -> def new_name(
    code = re.sub(rf'^\s*def\s+{re.escape(old_name)}\s*\(', 
                  f'def {new_name}(', code, flags=re.MULTILINE)
    
    # Replace function calls: old_name( -> new_name(
    code = re.sub(rf'\b{re.escape(old_name)}\s*\(', 
                  f'{new_name}(', code)
    
    return code


def fix_generated_code(code: str, entry_point: str) -> str:
    """Apply all fixes to LLM-generated code.
    
    This is a convenience function that applies all fixes in the correct order:
    1. Fix escaped newlines
    2. Fix missing imports
    3. Fix function name to match entry_point
    4. Replace 'candidate(' calls with entry_point
    
    Args:
        code: The generated code string
        entry_point: The expected function name
        
    Returns:
        Fixed code string
    """
    # Fix escaped newlines first (needed for other processing)
    code = fix_escaped_newlines(code)
    
    # Fix missing imports
    code = fix_missing_imports(code)
    
    # Fix function name
    main_function = find_main_function_to_replace(code, entry_point)
    if main_function:
        code = replace_function_name(code, main_function, entry_point)
    
    # Replace any remaining 'candidate(' calls
    if 'candidate(' in code:
        code = code.replace('candidate(', entry_point + '(')
    
    return code

