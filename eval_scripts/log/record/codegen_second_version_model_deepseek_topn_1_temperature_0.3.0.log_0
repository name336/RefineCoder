{"name": "HumanEval/0", "code_candidates": [{"code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i, num1 in enumerate(numbers):\n        for num2 in numbers[i+1:]:\n            if abs(num1 - num2) < threshold:\n                return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/1", "code_candidates": [{"code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    paren_string = paren_string.replace(' ', '')  # Remove all spaces\n    result = []\n    current_group = ''\n    balance = 0\n\n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(current_group)\n                current_group = ''\n\n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/2", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"The function only accepts positive floating point numbers.\")\n    return number - int(number)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0.5", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/3", "code_candidates": [{"code": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/4", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        raise ValueError('Input list cannot be empty.')\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean_value) for number in numbers]\n    return sum(absolute_deviations) / len(numbers)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/5", "code_candidates": [{"code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[5, 8, 6, 8, 3, 8, 2]", "[2, 2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/6", "code_candidates": [{"code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n                if current_depth < 0:\n                    break\n        if current_depth == 0:\n            result.append(max_depth)\n        else:\n            result.append(0)  # Invalid group, but we'll return 0 for consistency\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/7", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/8", "code_candidates": [{"code": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    total_sum = sum(numbers) if numbers else 0\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    return (total_sum, total_product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/9", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/10", "code_candidates": [{"code": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return string\n    \n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    \n    return string + string[:-1][::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "x", "xyzyx", "xyx", "jerryrrej"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/11", "code_candidates": [{"code": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    # Ensure both strings are of the same length\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length\")\n    \n    # Perform XOR operation\n    result = ''.join('1' if x != y else '0' for x, y in zip(a, b))\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/12", "code_candidates": [{"code": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    \n    max_length = -1\n    longest_string = None\n    \n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_string = string\n    \n    return longest_string", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/13", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/14", "code_candidates": [{"code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [string[:i] for i in range(1, len(string) + 1)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/15", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "0 1 2 3", "0 1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/16", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/17", "code_candidates": [{"code": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    note_mapping = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    notes = music_string.split()\n    beats = [note_mapping.get(note, 0) for note in notes]\n    \n    return beats", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[]", "[4, 4, 4, 4]", "[1, 1, 1, 1]", "[2, 2, 1, 1, 4, 4, 4, 4]", "[2, 1, 2, 1, 4, 2, 4, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/18", "code_candidates": [{"code": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if not substring:\n        return 0\n\n    count = 0\n    sub_len = len(substring)\n    str_len = len(string)\n\n    for i in range(str_len - sub_len + 1):\n        if string[i:i + sub_len] == substring:\n            count += 1\n\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/19", "code_candidates": [{"code": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    numeral_order = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    if not numbers:\n        return ''\n    \n    numeral_list = numbers.split()\n    try:\n        sorted_numerals = sorted(numeral_list, key=lambda x: numeral_order[x])\n    except KeyError as e:\n        raise ValueError(f\"Invalid numeral string: {e}\")\n    \n    return ' '.join(sorted_numerals)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "three", "three five nine", "zero four five seven eight nine", "zero one two three four five six"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/20", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    numbers_sorted = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (numbers_sorted[0], numbers_sorted[1])\n    \n    for i in range(len(numbers_sorted) - 1):\n        diff = abs(numbers_sorted[i] - numbers_sorted[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers_sorted[i], numbers_sorted[i + 1])\n    \n    return tuple(sorted(closest_pair))", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/21", "code_candidates": [{"code": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        raise ValueError(\"All elements in the list must be distinct.\")\n    \n    rescaled = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return rescaled", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/22", "code_candidates": [{"code": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/23", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/24", "code_candidates": [{"code": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors smaller than n for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    \n    return None  # In case no divisor is found (should not happen for valid input)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/25", "code_candidates": [{"code": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/26", "code_candidates": [{"code": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if numbers.count(number) == 1:\n            result.append(number)\n        else:\n            seen.add(number)\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[1, 2, 3, 4]", "[1, 4, 5]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/27", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    return ''.join(char.lower() if char.isupper() else char.upper() for char in string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/28", "code_candidates": [{"code": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "xyz", "xyzwk"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/29", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/30", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [x for x in l if x > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/31", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/32", "code_candidates": [{"code": "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list of coefficients must have an even number of elements.\")\n    \n    # Find the largest non-zero coefficient\n    max_coeff = max(abs(coeff) for coeff in xs if coeff != 0)\n    \n    # Determine the range based on the largest non-zero coefficient\n    range_start = -max_coeff\n    range_end = max_coeff\n    \n    # Simple bisection method to find a zero point within the range\n    while range_start <= range_end:\n        mid = (range_start + range_end) / 2\n        # Evaluate the polynomial at the midpoint\n        poly_value = sum(coeff * (mid ** i) for i, coeff in enumerate(xs))\n        \n        if abs(poly_value) < 1e-6:  # Consider values close to zero as zero\n            return mid\n        elif poly_value > 0:\n            range_end = mid\n        else:\n            range_start = mid\n    \n    # If no zero point is found within the range, return the midpoint as a fallback\n    return (range_start + range_end) / 2", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/33", "code_candidates": [{"code": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if not l:\n        return l\n    \n    # Extract elements at indices divisible by 3\n    divisible_by_three = l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l.copy()\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/34", "code_candidates": [{"code": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/35", "code_candidates": [{"code": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        raise ValueError(\"The list is empty\")\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/36", "code_candidates": [{"code": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    count = 0\n    for number in range(n):\n        if number % 11 == 0 or number % 13 == 0:\n            count += str(number).count('7')\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "2", "3", "3", "6", "192", "639", "8026"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/37", "code_candidates": [{"code": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    if not l:\n        return l\n    \n    # Extract even-indexed elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Reconstruct the list with sorted even-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[1, 2, 3]", "[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]", "[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/38", "code_candidates": [{"code": "def decode_cyclic(encoded_string: str) -> str:\n    if not encoded_string:\n        return \"\"\n    \n    decoded_chars = []\n    n = len(encoded_string)\n    shift = n % 26  # Calculate the shift based on the length of the string\n\n    for char in encoded_string:\n        if 'a' <= char <= 'z':\n            decoded_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            decoded_char = chr((ord(char) - ord('A') - shift) % 26 + ord('A'))\n        else:\n            decoded_char = char\n        decoded_chars.append(decoded_char)\n    \n    return ''.join(decoded_chars)", "index": 0, "passed_case": [], "case_status": ["gdjnnodjkdxbytigihmn", "izbecozvewaphiqhng", "souiuqmwnvvnsjdl", "mvaaslcudpfbkelqh", "tpouayxrgxsxhu", "izalxanldsoucxabqnee", "rpxcyawism", "farfzxtppicstic", "ztuolswjxikfbmlcuga", "bibfxdpkgms", "eoxaqeptjugldodelwwj", "awpmkzelrewxzqggjvrf", "nttooebojdkkqq", "xlvwzomxtdcecpmbasru", "lpwkspaziappkeijpc", "zrqwxfevkgt", "wozwggnkucukuuseivc", "jhadqsjnfmxmktuoulni", "amidaklhjowqypyvk", "oaannwxbclnk", "exdormjaozjfsjfaxj", "njyknybkkpudaplbja", "ucjzxzpnrdrcptocblq", "hltxcjmlbpzanurlq", "qzuhuckfelgbugc", "xstmgsxytiv", "gfrbatmntytflvm", "wticflbfkrqo", "pzffsgspbznx", "wlbltxohbd", "loeggmuhmermuggegco", "lirynptsbxvalt", "itnxvzlvphdyz", "qgxoljohyztjdfrtzqwj", "qscgxlajkfhbhfhq", "ngyevvoigbuuyvg", "tbgqxowffpdhtwcb", "zwzpidkaje", "epxyizgoilseedzct", "wknwoytpvqw", "hlcwdxpfbvyfqnvdf", "otodxopmvg", "aqkxnmxeiaczhxtcg", "zwvfxnqgwcqpgygcpx", "oiatuvwdwqqoty", "uqkbybcbfubp", "cgiickzkwtivxbwh", "bphpqxxivsduhudnwf", "fohggaoqjbsi", "krotpvttxvrhwrhly", "hrnxkboksr", "wqxuxjflut", "vdnfspaamdkemqfzhkq", "ttcnjddbzkdoqcfgkag", "isgucyjxsrhbwkusbuv", "tlbiwenfhdcm", "cshrmuyrsycifwdu", "avfwbfyapy", "pydxnhoejwyuodfbdww", "jliqvsqsfbueazyuw", "tesqrwplqosffzleng", "kctkfvdglqtww", "swyjenvorewoj", "mdiogrddxytc", "ftycfsiksl", "upuzsithxo", "djdridwyatcytcxd", "ntjwkoylws", "tfvtoqckbdxh", "zmxmezlxsy", "bfytjmnaxokkhlipzfdy", "paaviiucybadof", "nadyqjxlsi", "fchzipfmfxbwpmvubzw", "acezkzuzscl", "evsakhltxtmrvzhje", "vjwytogxbwgcoqjmrz", "ymfdcjqfisaoawjlq", "sjdeltflyxc", "qxynvaczpnlghirwt", "irqrafdxawzmtsxgzz", "uqyrcgriwluxzghj", "fjwozeoaluncnayy", "udnuskpyfa", "tbdrcjtrydfbyiwjoab", "ndptjiaceuljpgcqfhhp", "ypwbysgkdqqqexn", "owclozbpvpcvgvhcyqm", "ahdjcyxdlyv", "nrzcvwtgckftskwc", "dhedvzefpzfnnarzombe", "kabaajpfhhyudkrpqidt", "snuzefwtednw", "wljaopktqjhhyl", "khtiqulwzdftqadctu", "wekigpiwzjr", "cputjahhkvjpnxjsukrb", "afvmvflxcvqbetjwwo", "qiyehyozytqvb", "vjkipjozqwt"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/39", "code_candidates": [{"code": "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    count = 0\n    a, b = 0, 1\n    while True:\n        if is_prime(b):\n            count += 1\n            if count == n:\n                return b\n        a, b = b, a + b\n\n# Example usage:\n# print(prime_fib(1))  # Output: 2\n# print(prime_fib(2))  # Output: 3\n# print(prime_fib(3))  # Output: 5\n# print(prime_fib(4))  # Output: 13\n# print(prime_fib(5))  # Output: 89", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "433494437"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/40", "code_candidates": [{"code": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    # Handle edge cases\n    if len(l) < 3:\n        return False\n\n    # Sort the list to use two-pointer technique\n    l.sort()\n\n    # Iterate through the list to find triplets\n    for i in range(len(l) - 2):\n        # Skip duplicates\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        left = i + 1\n        right = len(l) - 1\n\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/41", "code_candidates": [{"code": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars moving in opposite directions.\n\n    Args:\n        n (int): The number of cars in each set.\n\n    Returns:\n        int: The number of collisions.\n    \"\"\"\n    # The number of collisions is determined by the number of ways to pair the cars.\n    # Since each car in the left-to-right set can collide with each car in the right-to-left set,\n    # the total number of collisions is the product of the number of cars in each set.\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/42", "code_candidates": [{"code": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/43", "code_candidates": [{"code": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/44", "code_candidates": [{"code": "def change_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n    Return string representation after the conversion.\n    Base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    if base < 2 or base >= 10:\n        raise ValueError(\"Base must be between 2 and 9 inclusive.\")\n    \n    if x == 0:\n        return '0'\n    \n    result = []\n    while x > 0:\n        result.append(str(x % base))\n        x = x // base\n    \n    return ''.join(reversed(result))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/45", "code_candidates": [{"code": "def triangle_area(a, h):\n    \"\"\"Given length of a side and height, return the area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    if a <= 0 or h <= 0:\n        raise ValueError(\"Both the side length and height must be positive numbers.\")\n    return 0.5 * a * h", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/46", "code_candidates": [{"code": "def fib4(n: int) -> int:\n    \"\"\"\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    This function efficiently computes the n-th element of the fib4 number sequence without using recursion.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    \n    # Initialize the first four Fib4 numbers\n    fib4_sequence = [0, 0, 2, 0]\n    \n    # Compute the Fib4 sequence iteratively\n    for i in range(4, n + 1):\n        next_fib4 = fib4_sequence[i - 1] + fib4_sequence[i - 2] + fib4_sequence[i - 3] + fib4_sequence[i - 4]\n        fib4_sequence.append(next_fib4)\n    \n    return fib4_sequence[n]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["4", "28", "104", "386"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/47", "code_candidates": [{"code": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if not l:\n        return None\n    \n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    \n    if n % 2 == 0:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2\n    else:\n        return sorted_l[mid]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "8.0", "5", "5.5", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/48", "code_candidates": [{"code": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/49", "code_candidates": [{"code": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0 or p <= 0:\n        raise ValueError(\"Both n must be non-negative and p must be positive.\")\n    \n    result = 1\n    power = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * power) % p\n        power = (power * power) % p\n        n //= 2\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/50", "code_candidates": [{"code": "def decode_shift(s: str):\n    \"\"\"\n    Takes as input a string encoded with encode_shift function. Returns the decoded string by shifting each character back by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/51", "code_candidates": [{"code": "def remove_vowels(text: str) -> str:\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/52", "code_candidates": [{"code": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(x < t for x in l)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/53", "code_candidates": [{"code": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/54", "code_candidates": [{"code": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    from collections import Counter\n\n    # Count the frequency of each character in both strings\n    counter_s0 = Counter(s0)\n    counter_s1 = Counter(s1)\n\n    # Compare the counters\n    return counter_s0 == counter_s1", "index": 0, "passed_case": [3, 4, 5, 6], "case_status": ["False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/55", "code_candidates": [{"code": "def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/56", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        elif bracket == \">\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/57", "code_candidates": [{"code": "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if not l:\n        return True\n    \n    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n    \n    return increasing or decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/58", "code_candidates": [{"code": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    # Use set intersection to find common elements\n    common_elements = set(l1).intersection(set(l2))\n    # Convert the set back to a sorted list\n    return sorted(common_elements)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/59", "code_candidates": [{"code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for factors from 2 up to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            # Check the corresponding factor n // i\n            if is_prime(n // i):\n                largest_factor = n // i\n                break\n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/60", "code_candidates": [{"code": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/61", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == '(':\n            balance += 1\n        elif bracket == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/62", "code_candidates": [{"code": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    if not xs:\n        return []\n    \n    return [xs[i] * i for i in range(1, len(xs))]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/63", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize the first three FibFib numbers\n    fibfib_n_3 = 0  # fibfib(0)\n    fibfib_n_2 = 0  # fibfib(1)\n    fibfib_n_1 = 1  # fibfib(2)\n    \n    # Compute FibFib numbers iteratively from 3 to n\n    for _ in range(3, n + 1):\n        fibfib_n = fibfib_n_1 + fibfib_n_2 + fibfib_n_3\n        fibfib_n_3, fibfib_n_2, fibfib_n_1 = fibfib_n_2, fibfib_n_1, fibfib_n\n    \n    return fibfib_n_1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/64", "code_candidates": [{"code": "def vowels_count(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in a string. Vowels are 'a', 'e', 'i', 'o', 'u',\n    and 'y' is considered a vowel only if it is at the end of the word.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of vowels in the string.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    >>> vowels_count(\"python\")\n    1\n    >>> vowels_count(\"rhythm\")\n    0\n    >>> vowels_count(\"\")\n    0\n    >>> vowels_count(\"y\")\n    1\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    # Check if 'y' or 'Y' is at the end of the word\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/65", "code_candidates": [{"code": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    x_str = str(x)\n    length = len(x_str)\n    \n    if shift > length:\n        return x_str[::-1]\n    \n    shift = shift % length\n    shifted_str = x_str[-shift:] + x_str[:-shift]\n    return shifted_str", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["001", "12", "79", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/66", "code_candidates": [{"code": "def upperCharSum(s: str) -> int:\n    \"\"\"\n    Task\n    Write a function that takes a string as input and returns the sum of the ASCII codes of the uppercase characters only.\n    \"\"\"\n    return sum(ord(char) for char in s if char.isupper())", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "131", "67", "69", "131", "153", "151", "327"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/67", "code_candidates": [{"code": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string that represents the number of apples and oranges,\n    and an integer that represents the total number of fruits in the basket,\n    return the number of mango fruits in the basket.\n    \"\"\"\n    # Split the string to extract the number of apples and oranges\n    parts = s.split()\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/68", "code_candidates": [{"code": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smallest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n    \"\"\"\n    if not arr:\n        return []\n    \n    min_even_value = None\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if min_even_value is None or value < min_even_value:\n                min_even_value = value\n                min_index = index\n            elif value == min_even_value:\n                if index < min_index:\n                    min_index = index\n    \n    if min_even_value is not None:\n        return [min_even_value, min_index]\n    else:\n        return []", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2, 1]", "[2, 1]", "[]", "[0, 1]", "[0, 3]", "[4, 1]", "[6, 1]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/69", "code_candidates": [{"code": "from collections import Counter\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n    # Count the frequency of each integer in the list\n    frequency = Counter(lst)\n    \n    # Initialize the result to -1\n    result = -1\n    \n    # Iterate through the frequency dictionary\n    for num, count in frequency.items():\n        # Check if the number meets the criteria\n        if num > 0 and count >= num:\n            # Update the result if the current number is greater than the previous result\n            if result == -1 or num > result:\n                result = num\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "case_status": ["1", "4", "-1", "8", "2", "1", "2", "1", "-1", "1", "1", "5", "1", "4", "2", "1", "4", "4", "2", "-1", "-1", "2", "1", "1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/70", "code_candidates": [{"code": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left, right = 0, len(sorted_lst) - 1\n    toggle = True\n\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/71", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        # Round the area to 2 decimal points\n        return round(area, 2)\n    else:\n        return -1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["6.0", "-1", "8.18", "1.73", "-1", "16.25", "-1", "0.43", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/72", "code_candidates": [{"code": "def will_it_fly(q, w):\n    '''\n    Returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n    '''\n    # Check if q is a palindromic list\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of the elements in q\n    total_weight = sum(q)\n    \n    # Return True if both conditions are met\n    return is_balanced and total_weight <= w", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/73", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n\n    changes = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n\n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/74", "code_candidates": [{"code": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[]", "['hi', 'hi']", "['hi', 'admin']", "['4']", "['hI', 'Hi']", "['hI', 'hi', 'hi']", "['hi', 'admin']", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/75", "code_candidates": [{"code": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a):\n    if a < 2:\n        return False\n\n    prime_factors = []\n    for i in range(2, a):\n        if a % i == 0 and is_prime(i):\n            prime_factors.append(i)\n            a //= i\n            if len(prime_factors) > 3:\n                return False\n\n    if a > 1 and is_prime(a):\n        prime_factors.append(a)\n\n    return len(prime_factors) == 3\n\n# Example usage:\n# print(is_multiply_prime(30))  # Output: True", "index": 0, "passed_case": [0, 1, 3, 5, 6, 7, 8, 9], "case_status": ["False", "True", "False", "False", "False", "True", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/76", "code_candidates": [{"code": "def is_simple_power(x, n):\n    \"\"\"\n    Returns true if a number x is a simple power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    \"\"\"\n    if n == 1:\n        return x == 1\n    power = 1\n    while power < x:\n        power *= n\n    return power == x", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/77", "code_candidates": [{"code": "def iscube(a: int) -> bool:\n    '''\n    Returns True if the integer a is a cube of some integer number.\n    '''\n    if a < 0:\n        a = -a\n    \n    # Find the cube root of a\n    cube_root = round(a ** (1/3))\n    \n    # Check if the cube of the cube root equals the original number\n    return cube_root ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/78", "code_candidates": [{"code": "def hex_key(num: str) -> int:\n    \"\"\"Counts the number of hexadecimal digits that are primes.\n\n    Args:\n        num (str): A hexadecimal number as a string.\n\n    Returns:\n        int: The count of prime hexadecimal digits.\n    \"\"\"\n    # Define the prime hexadecimal digits and their corresponding decimal values\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize the count of prime digits\n    count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        if char in prime_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/79", "code_candidates": [{"code": "def decimal_to_binary(decimal):\n    \"\"\"\n    Converts a decimal number to a binary string with 'db' at the beginning and end.\n\n    Args:\n        decimal (int): The decimal number to convert.\n\n    Returns:\n        str: The binary representation of the decimal number with 'db' at the beginning and end.\n    \"\"\"\n    if not isinstance(decimal, int) or decimal < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    binary_str = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary_str}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/80", "code_candidates": [{"code": "def is_happy(s: str) -> bool:\n    \"\"\"\n    Check if the string is happy.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    \"\"\"\n    # Check if the length of the string is less than 3\n    if len(s) < 3:\n        return False\n    \n    # Iterate through the string and check every 3 consecutive letters\n    for i in range(len(s) - 2):\n        # Extract 3 consecutive letters\n        triplet = s[i:i+3]\n        # Check if all 3 letters are distinct\n        if len(set(triplet)) != 3:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "False", "True", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/81", "code_candidates": [{"code": "def numerical_letter_grade(grades):\n    \"\"\"\n    Converts a list of numerical GPAs to a list of corresponding letter grades.\n\n    Args:\n        grades (list): A list of numerical GPAs.\n\n    Returns:\n        list: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n        else:\n            letter_grades.append('Invalid GPA')\n    return letter_grades", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['A+', 'B', 'C-', 'C', 'A-']", "['D+']", "['D-']", "['E']", "['D', 'D-', 'C-', 'B', 'B+']", "['E', 'D-']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/82", "code_candidates": [{"code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return is_prime(len(string))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/83", "code_candidates": [{"code": "def count_numbers(n: int) -> int:\n    if n <= 0:\n        return 0\n    \n    # Total n-digit numbers\n    total_n_digit_numbers = 9 * (10 ** (n - 1))\n    \n    # Numbers that start with 1\n    start_with_1 = 10 ** (n - 1)\n    \n    # Numbers that end with 1\n    end_with_1 = 10 ** (n - 1)\n    \n    # Numbers that start AND end with 1\n    start_and_end_with_1 = 10 ** (n - 2) if n > 1 else 1\n    \n    # Using the inclusion-exclusion principle\n    result = start_with_1 + end_with_1 - start_and_end_with_1\n    \n    return result", "index": 0, "passed_case": [0], "case_status": ["1", "19", "190", "1900", "19000"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/84", "code_candidates": [{"code": "def solve(N: int) -> str:\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    if N < 0 or N > 10000:\n        raise ValueError(\"N must be between 0 and 10000 inclusive.\")\n    \n    # Calculate the sum of digits\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "110", "1100", "1001", "10010"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/85", "code_candidates": [{"code": "def add(lst: list[int]) -> int:\n    \"\"\"Given a non-empty list of integers lst, add the even elements that are at odd indices.\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["88", "122", "0", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/86", "code_candidates": [{"code": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello !!!Wdlor", "", ".Hi My aemn is Meirst .Rboot How aer ?ouy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/87", "code_candidates": [{"code": "def get_row(lst, x):\n    \"\"\"\n    Given a 2 dimensional data as a nested list, find integer x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, column), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the same row by columns in descending order.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/88", "code_candidates": [{"code": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    if not array:\n        return []\n    \n    first_value = array[0]\n    last_value = array[-1] if len(array) > 1 else 0\n    sum_values = first_value + last_value\n    \n    if sum_values % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/89", "code_candidates": [{"code": "def encrypt(s: str) -> str:\n    encrypted_str = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Shift by 4 places within the lowercase alphabet\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted_str += encrypted_char\n        elif 'A' <= char <= 'Z':\n            # Shift by 4 places within the uppercase alphabet\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted_str += encrypted_char\n        else:\n            # Non-alphabetic characters remain unchanged\n            encrypted_str += char\n    return encrypted_str", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["lm", "ewhjklnop", "kj", "ix"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/90", "code_candidates": [{"code": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n    if len(lst) < 2:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "2", "None", "None", "1", "None", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/91", "code_candidates": [{"code": "import re\n\ndef is_bored(S: str) -> int:\n    if not S:\n        return 0\n    \n    # Split the string into sentences using regex to match '.', '?', or '!'\n    sentences = re.split(r'[.!?]', S)\n    \n    # Filter out any empty strings resulting from the split\n    sentences = [sentence.strip() for sentence in sentences if sentence.strip()]\n    \n    # Count sentences starting with 'I'\n    count = 0\n    for sentence in sentences:\n        words = sentence.split()\n        if words and words[0].lower() == 'i':\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["0", "0", "1", "0", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/92", "code_candidates": [{"code": "def any_int(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    any_int(5, 2, 7) \u279e True\n    \n    any_int(3, 2, 2) \u279e False\n\n    any_int(3, -2, 1) \u279e True\n    \n    any_int(3.6, -2.2, 2) \u279e False\n    '''\n    \n    # Check if all numbers are integers\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    return (x == y + z) or (y == x + z) or (z == x + y)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["True", "False", "False", "False", "True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/93", "code_candidates": [{"code": "def encode(message: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    encoded_message = []\n\n    for char in message:\n        if char in vowels:\n            # Determine if the character is uppercase or lowercase\n            is_upper = char.isupper()\n            # Find the position in the alphabet\n            position = ord(char.lower()) - ord('a')\n            # Calculate the new position, wrapping around if necessary\n            new_position = (position + 2) % 26\n            # Convert back to character\n            new_char = chr(new_position + ord('a'))\n            # Restore the case\n            new_char = new_char.upper() if is_upper else new_char\n            encoded_message.append(new_char)\n        else:\n            # Swap the case for non-vowel characters\n            encoded_message.append(char.swapcase())\n    \n    return ''.join(encoded_message)", "index": 0, "passed_case": [], "case_status": ["tGst", "mwDcSkR", "yGs", "tHkS kS c MgSScGg", "K dqnT kNQW wHCT TQ wRKTG"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/94", "code_candidates": [{"code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(d) for d in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    largest_prime = -1\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n    if largest_prime == -1:\n        return 0\n    return sum_of_digits(largest_prime)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["10", "25", "13", "11", "3", "7", "19", "19", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/95", "code_candidates": [{"code": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n    if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    if all(key.isupper() for key in keys):\n        return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "False", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/96", "code_candidates": [{"code": "def count_up_to(n: int) -> list:\n    \"\"\"Implement a function that takes a non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    primes = [x for x in range(2, n) if is_prime(x)]\n    return primes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/97", "code_candidates": [{"code": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    # Extract the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Return the product of the unit digits\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/98", "code_candidates": [{"code": "def count_upper(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/99", "code_candidates": [{"code": "def closest_integer(value: str) -> int:\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    '''\n    number = float(value)\n    if number % 1 == 0.5:\n        if number >= 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["10", "15", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/100", "code_candidates": [{"code": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    stones = []\n    current = n\n    for _ in range(n):\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    \n    return stones", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/101", "code_candidates": [{"code": "def words_string(s: str) -> list:\n    \"\"\"\n    Splits a string of words separated by commas or spaces into an array of words.\n    \n    Args:\n        s (str): The input string containing words separated by commas or spaces.\n    \n    Returns:\n        list: An array of the words extracted from the input string.\n    \"\"\"\n    if not s:\n        return []\n    \n    # Replace commas with spaces and then split by spaces\n    words = s.replace(',', ' ').split()\n    return words", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/102", "code_candidates": [{"code": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    # Ensure x is less than or equal to y\n    if x > y:\n        return -1\n    \n    # Iterate from y down to x to find the largest even number\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    # If no even number is found, return -1\n    return -1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["14", "-1", "12354", "-1", "28", "-1", "-1", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/103", "code_candidates": [{"code": "def rounded_avg(n, m):\n    \"\"\"\n    Compute the average of the integers from n through m (including n and m),\n    round the answer to the nearest integer, convert that to binary, and return\n    the binary string prefixed with '0b'. If n is greater than m, return -1.\n    \"\"\"\n    if n > m:\n        return -1\n    \n    # Calculate the average of the integers from n to m\n    average = (n + m) / 2\n    \n    # Round the average to the nearest integer\n    rounded_average = round(average)\n    \n    # Convert the rounded average to binary and return as a string prefixed with '0b'\n    return bin(rounded_average)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["0b11", "0b1010", "0b1111001010", "0b1111100100", "0b1011000010", "0b101101110", "0b110101101", "0b1001110010", "0b11010111", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/104", "code_candidates": [{"code": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x, return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    def has_even_digit(num):\n        \"\"\"Helper function to check if a number has any even digit.\"\"\"\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                return True\n        return False\n\n    # Filter out numbers with even digits and sort the result\n    return sorted([num for num in x if not has_even_digit(num)])", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 15, 33]", "[]", "[111, 151]", "[31, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/105", "code_candidates": [{"code": "def by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    \"\"\"\n    # Filter the array to include only integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/106", "code_candidates": [{"code": "def f(n):\n    \"\"\" Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n    def factorial(x):\n        result = 1\n        for i in range(1, x + 1):\n            result *= i\n        return result\n\n    def sum_of_numbers(x):\n        return x * (x + 1) // 2\n\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_of_numbers(i))\n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 2, 6, 24, 15]", "[1, 2, 6, 24, 15, 720, 28]", "[1]", "[1, 2, 6]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/107", "code_candidates": [{"code": "def even_odd_palindrome(n: int) -> tuple:\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    def is_palindrome(x: int) -> bool:\n        \"\"\"Check if a number is a palindrome.\"\"\"\n        s = str(x)\n        return s == s[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/108", "code_candidates": [{"code": "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    def sum_of_digits(num):\n        \"\"\"Helper function to calculate the sum of digits considering sign.\"\"\"\n        total = 0\n        num_str = str(num)\n        for char in num_str:\n            if char == '-':\n                continue  # Skip the negative sign\n            total += int(char) if num >= 0 else -int(char)\n        return total\n\n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 6, 7], "case_status": ["0", "0", "6", "5", "4", "3", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/109", "code_candidates": [{"code": "def move_one_ball(arr):\n    \"\"\"\n    Determines if it is possible to get an array sorted in non-decreasing order\n    by performing right shift operations on the given array.\n\n    Args:\n        arr (List[int]): The input array of unique integers.\n\n    Returns:\n        bool: True if it is possible to sort the array by right shifts, False otherwise.\n    \"\"\"\n    if not arr:\n        return True\n\n    # Find the index of the minimum element\n    min_index = arr.index(min(arr))\n\n    # Check if the array can be sorted by right shifts\n    for i in range(1, len(arr)):\n        if arr[(min_index + i) % len(arr)] < arr[(min_index + i - 1) % len(arr)]:\n            return False\n\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/110", "code_candidates": [{"code": "def exchange(lst1, lst2):\n    \"\"\"\n    Determines whether it is possible to perform an exchange of elements\n    between lst1 and lst2 to make lst1 a list of only even numbers.\n    If possible, returns \"YES\"; otherwise, returns \"NO\".\n    \"\"\"\n    # Count the number of odd elements in lst1\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    \n    # Count the number of even elements in lst2\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If the number of odd elements in lst1 can be replaced by even elements from lst2, return \"YES\"\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["YES", "NO", "YES", "YES", "NO", "NO", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/111", "code_candidates": [{"code": "def histogram(test: str) -> dict:\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    if not test:\n        return {}\n    \n    letter_counts = {}\n    for char in test.split():\n        if char in letter_counts:\n            letter_counts[char] += 1\n        else:\n            letter_counts[char] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {char: count for char, count in letter_counts.items() if count == max_count}\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/112", "code_candidates": [{"code": "def reverse_delete(s: str, c: str) -> tuple:\n    # Handle edge cases\n    if not s:\n        return ('', True)\n    if not c:\n        return (s, s == s[::-1])\n    \n    # Delete all characters in s that are present in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    # Handle the case where all characters in s are deleted\n    if not result:\n        return ('', True)\n    \n    return (result, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/113", "code_candidates": [{"code": "def odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for s in lst:\n        odd_count = sum(1 for c in s if c in '13579')\n        result.append(f\"the number of odd elements {odd_count} in the string {s} of the input.\")\n    return result", "index": 0, "passed_case": [], "case_status": ["['the number of odd elements 4 in the string 1234567 of the input.']", "['the number of odd elements 1 in the string 3 of the input.', 'the number of odd elements 8 in the string 11111111 of the input.']", "['the number of odd elements 2 in the string 271 of the input.', 'the number of odd elements 3 in the string 137 of the input.', 'the number of odd elements 2 in the string 314 of the input.']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/114", "code_candidates": [{"code": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return 0\n    \n    current_min = nums[0]\n    global_min = nums[0]\n    \n    for num in nums[1:]:\n        current_min = min(num, current_min + num)\n        global_min = min(global_min, current_min)\n    \n    return global_min", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/115", "code_candidates": [{"code": "import math\n\ndef max_fill(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    total_buckets = 0\n    \n    for row in grid:\n        water_units = sum(row)\n        if water_units > 0:\n            total_buckets += math.ceil(water_units / capacity)\n    \n    return total_buckets", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["6", "5", "0", "4", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/116", "code_candidates": [{"code": "def sort_array(arr):\n    \"\"\"\n    Sort an array of non-negative integers based on the number of ones in their binary representation in ascending order. If the number of ones is the same, sort by decimal value.\n\n    Examples:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 4, 3, 5]\n    >>> sort_array([0, 1, 2, 3, 4]) == [0, 1, 2, 3, 4]\n    \"\"\"\n    # Define a helper function to count the number of ones in the binary representation\n    def count_ones(num):\n        return bin(num).count('1')\n    \n    # Sort the array based on the number of ones and then by the decimal value\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[1, 2, 4, 3, 5]", "[-4, -2, -6, -5, -3]", "[0, 1, 2, 4, 3]", "[]", "[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "[32, 3, 5, 6, 12, 44]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/117", "code_candidates": [{"code": "def select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    if not s:\n        return result\n    \n    words = s.split()\n    \n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['little']", "['Mary', 'lamb']", "[]", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/118", "code_candidates": [{"code": "def get_closest_vowel(word: str) -> str:\n    \"\"\"Find the closest vowel that stands between two consonants from the right side of the word.\n    \n    Vowels in the beginning and ending don't count. Return empty string if no such vowel is found.\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    # Iterate from the end of the word to the beginning\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels:\n            # Check if the vowel is between two consonants\n            if i > 0 and i < len(word) - 1 and word[i - 1] in consonants and word[i + 1] in consonants:\n                return word[i]\n    return \"\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["u", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/119", "code_candidates": [{"code": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    # Try concatenating in both orders\n    if is_balanced(s1 + s2):\n        return 'Yes'\n    if is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "Yes", "No", "No", "No", "Yes", "Yes"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/120", "code_candidates": [{"code": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    # Handle edge case where k is 0\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Return the last k elements (which are the largest)\n    return sorted_arr[-k:]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[4, 4]", "[2]", "[2, 20, 123]", "[0, 1, 2, 20]", "[-13, -8, 0, 0, 3, 5, 15]", "[3, 5]", "[5]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/121", "code_candidates": [{"code": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["9", "0", "5", "0", "23", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/122", "code_candidates": [{"code": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n    # Ensure the array is non-empty and k is within bounds\n    if not arr or k < 1 or k > len(arr):\n        return 0\n\n    # Sum the elements with at most two digits from the first k elements\n    total = 0\n    for i in range(min(k, len(arr))):\n        if arr[i] < 100 and arr[i] > -100:\n            total += arr[i]\n\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["-4", "0", "125", "24", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/123", "code_candidates": [{"code": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    odd_numbers = []\n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    odd_numbers.append(1)  # Adding the final 1\n    return sorted(odd_numbers)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/124", "code_candidates": [{"code": "import re\n\ndef valid_date(date):\n    \"\"\"Validates a given date string and returns True if the date is valid, otherwise False.\n    The date is valid if:\n    1. The date string is not empty.\n    2. The number of days is valid for the given month and year (considering leap years). Specifically:\n       - February has 28 days in a common year and 29 days in a leap year.\n       - A year is a leap year if it is divisible by 4, but not by 100 unless it is also divisible by 400.\n       - Months with 30 days: April, June, September, November.\n       - Months with 31 days: January, March, May, July, August, October, December.\n    3. The months are between 1 and 12.\n    4. The date is in the format: mm-dd-yyyy, where single-digit months and days can be represented without leading zeros.\n    \"\"\"\n    \n    if not date:\n        return False\n    \n    # Regular expression to match the date format mm-dd-yyyy\n    date_pattern = re.compile(r'^(\\d{1,2})-(\\d{1,2})-(\\d{4})$')\n    match = date_pattern.match(date)\n    \n    if not match:\n        return False\n    \n    month, day, year = map(int, match.groups())\n    \n    if month < 1 or month > 12:\n        return False\n    \n    # Define the number of days in each month\n    days_in_month = {\n        1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,\n        7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31\n    }\n    \n    # Check for leap year\n    is_leap_year = (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n    \n    if is_leap_year:\n        days_in_month[2] = 29\n    \n    if day < 1 or day > days_in_month[month]:\n        return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "False", "False", "True", "True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/125", "code_candidates": [{"code": "def process_string(s: str) -> list[str] | int:\n    if ' ' in s:\n        return s.split()\n    elif ',' in s:\n        return s.split(',')\n    else:\n        count = 0\n        for char in s:\n            if char.islower():\n                if ord(char) % 2 != 0:\n                    count += 1\n        return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 7], "case_status": ["['Hello', 'world!']", "['Hello', 'world!']", "['Hello', 'world,!']", "['Hello,Hello,world', '!']", "3", "3", "3", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/126", "code_candidates": [{"code": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted([5]) \u279e True\n    is_sorted([1, 2, 3, 4, 5]) \u279e True\n    is_sorted([1, 3, 2, 4, 5]) \u279e False\n    is_sorted([1, 2, 3, 4, 5, 6]) \u279e True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) \u279e True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279e False\n    is_sorted([1, 2, 2, 3, 3, 4]) \u279e True\n    is_sorted([1, 2, 2, 2, 3, 4]) \u279e False\n    '''\n    if not lst:\n        return True\n    \n    prev = lst[0]\n    count = 1\n    \n    for num in lst[1:]:\n        if num < prev:\n            return False\n        if num == prev:\n            count += 1\n            if count > 1:\n                return False\n        else:\n            count = 1\n        prev = num\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/127", "code_candidates": [{"code": "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection start and end\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # Check if there is an intersection\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = intersection_end - intersection_start + 1\n    \n    # Check if the length is a prime number\n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"", "index": 0, "passed_case": [0, 2, 3, 4, 5, 7], "case_status": ["NO", "YES", "YES", "YES", "NO", "NO", "YES", "NO"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/128", "code_candidates": [{"code": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n    if not arr:\n        return None\n    \n    # Determine the sign of each number\n    signs = [1 if x > 0 else -1 if x < 0 else 0 for x in arr]\n    \n    # Calculate the product of all signs\n    product_of_signs = 1\n    for sign in signs:\n        if sign == 0:\n            product_of_signs = 0\n            break\n        product_of_signs *= sign\n    \n    # Calculate the sum of magnitudes\n    sum_of_magnitudes = sum(abs(x) for x in arr)\n    \n    return sum_of_magnitudes * product_of_signs", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["-9", "0", "-10", "None", "20", "4", "-4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/129", "code_candidates": [{"code": "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < N\n    \n    def generate_paths(x, y, path, length):\n        if length == k:\n            return [path]\n        paths = []\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                paths.extend(generate_paths(nx, ny, path + [grid[nx][ny]], length + 1))\n        return paths\n    \n    all_paths = []\n    for i, j in product(range(N), range(N)):\n        all_paths.extend(generate_paths(i, j, [grid[i][j]], 1))\n    \n    return min(all_paths)\n\n# Example usage:\n# print(minPath([[1,2,3], [4,5,6], [7,8,9]], 3))  # Output: [1, 2, 1]\n# print(minPath([[5,9,3], [4,1,6], [7,8,2]], 1))  # Output: [1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 7, 8, 9, 10], "case_status": ["[1, 2, 1]", "[1]", "[1, 2, 1, 2]", "[1, 10, 1, 10, 1, 10, 1]", "[1, 7, 1, 7, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1]", "Timeout", "[1, 3, 1, 3, 1, 3, 1, 3]", "[1, 5, 1, 5, 1, 5, 1, 5]", "[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/130", "code_candidates": [{"code": "def tri(n):\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return [0]\n    elif n == 1:\n        return [0, 1]\n    elif n == 2:\n        return [0, 1, 1]\n    \n    # Initialize the sequence with the first three numbers\n    sequence = [0, 1, 1]\n    \n    # Generate the sequence up to n\n    for i in range(3, n + 1):\n        next_value = sequence[-1] + sequence[-2] + sequence[-3]\n        sequence.append(next_value)\n    \n    return sequence", "index": 0, "passed_case": [], "case_status": ["[0, 1, 1, 2]", "[0, 1, 1, 2, 4]", "[0, 1, 1, 2, 4, 7]", "[0, 1, 1, 2, 4, 7, 13]", "[0, 1, 1, 2, 4, 7, 13, 24]", "[0, 1, 1, 2, 4, 7, 13, 24, 44]", "[0, 1, 1, 2, 4, 7, 13, 24, 44, 81]", "[0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012]", "[0]", "[0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/131", "code_candidates": [{"code": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    product = 1\n    has_odd = False\n    \n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd = True\n        n = n // 10\n    \n    return product if has_odd else 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["5", "5", "5", "315", "2625", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/132", "code_candidates": [{"code": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n    '''\n    stack = []\n    nested = False\n\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n                if stack:\n                    nested = True\n            else:\n                # Invalid sequence, reset stack\n                stack = []\n\n    return nested\n\n# Test cases\nprint(is_nested('[[]]'))          # True\nprint(is_nested('[]]]]]]][[[[[]')) # False\nprint(is_nested('[][]'))          # False\nprint(is_nested('[]'))            # False\nprint(is_nested('[[][]]'))        # True\nprint(is_nested('[[]][['))        # True", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13], "case_status": ["True", "True", "False", "False", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/133", "code_candidates": [{"code": "import math\n\ndef sum_squares(lst):\n    \"\"\"\n    You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \"\"\"\n    # Calculate the sum of squared numbers after ceiling each element\n    return sum(math.ceil(x) ** 2 for x in lst)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/134", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Returns True if the last character of a given string is an alphabetical character\n    and is not a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n    '''\n    if not txt:\n        return False\n    \n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    \n    # Check if the last character is part of a word\n    if ' ' in txt:\n        last_space_index = txt.rfind(' ')\n        if last_space_index < len(txt) - 1:\n            return True\n        else:\n            return False\n    else:\n        return False\n\n# Examples\n# print(check_if_last_char_is_a_letter(\"apple pie\"))  # \u279e False\n# print(check_if_last_char_is_a_letter(\"apple pi e\"))  # \u279e True\n# print(check_if_last_char_is_a_letter(\"apple pi e \"))  # \u279e False\n# print(check_if_last_char_is_a_letter(\"\"))  # \u279e False", "index": 0, "passed_case": [0, 1, 2, 4, 5, 6, 7, 9], "case_status": ["False", "True", "False", "False", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/135", "code_candidates": [{"code": "def can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        # Check if the current element is not greater than or equal to the previous element\n        if arr[i] < arr[i - 1]:\n            return i\n    # If no such element exists, return -1\n    return -1", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["3", "-1", "2", "2", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/136", "code_candidates": [{"code": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n    largest_negative = None\n    smallest_positive = None\n\n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return (largest_negative, smallest_positive)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/137", "code_candidates": [{"code": "from typing import Union, Optional\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Optional[Union[int, float, str]]:\n    def convert_to_number(value: Union[int, float, str]) -> Optional[float]:\n        if isinstance(value, (int, float)):\n            return float(value)\n        elif isinstance(value, str):\n            try:\n                # Replace ',' with '.' and convert to float\n                return float(value.replace(',', '.'))\n            except ValueError:\n                return None\n        return None\n\n    # Convert both values to numbers\n    a_num = convert_to_number(a)\n    b_num = convert_to_number(b)\n\n    # If either conversion failed, return None\n    if a_num is None or b_num is None:\n        return None\n\n    # Compare the numeric values\n    if a_num > b_num:\n        return a\n    elif b_num > a_num:\n        return b\n    else:\n        return None", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["2", "2.5", "3", "6", "2,3", "6", "2", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/138", "code_candidates": [{"code": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\"\"\"\n    # Check if n is less than 8, which is the smallest sum of 4 positive even numbers (2 + 2 + 2 + 2)\n    if n < 8:\n        return False\n    # If n is even, it can be expressed as the sum of 4 positive even numbers\n    return n % 2 == 0\n\n# Examples\n# is_equal_to_sum_even(4) == False\n# is_equal_to_sum_even(6) == False\n# is_equal_to_sum_even(8) == True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/139", "code_candidates": [{"code": "import math\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/140", "code_candidates": [{"code": "def fix_spaces(text: str) -> str:\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \"\"\"\n    if not text:\n        return text\n    \n    # Replace more than 2 consecutive spaces with '-'\n    text = text.replace('   ', '-')\n    text = text.replace('  ', '-')\n    \n    # Replace all remaining spaces with '_'\n    text = text.replace(' ', '_')\n    \n    return text", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["Example", "Mudasir_Hanif_", "Yellow_Yellow-Dirty-Fellow", "Exa-mple", "-Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/141", "code_candidates": [{"code": "import re\n\ndef file_name_check(file_name: str) -> str:\n    \"\"\"\n    Check if the file name is valid according to the specified rules.\n    \n    Parameters:\n    file_name (str): The file name to be checked.\n    \n    Returns:\n    str: 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    # Check for exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name is not empty and starts with a latin alphabet letter\n    if not name or not re.match(r'^[a-zA-Z]', name):\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # Check for no more than three digits in the name\n    if len(re.findall(r'\\d', name)) > 3:\n        return 'No'\n    \n    return 'Yes'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "No", "No", "No", "No", "Yes", "No", "No", "No", "No", "No", "Yes", "Yes", "Yes", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/142", "code_candidates": [{"code": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n    \"\"\"\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["6", "14", "0", "9", "-3", "0", "-126", "3030", "0", "-14196", "-1448"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/143", "code_candidates": [{"code": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["is", "go for", "there is no place", "Hi am Hussein", "go for it", "", "is"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/144", "code_candidates": [{"code": "def simplify(x, n):\n    \"\"\"\n    Simplifies the expression x * n and returns True if the result is a whole number, False otherwise.\n    Both x and n are string representations of fractions in the format <numerator>/<denominator>.\n    \"\"\"\n    from fractions import Fraction\n\n    # Parse the input fractions\n    frac_x = Fraction(x)\n    frac_n = Fraction(n)\n\n    # Multiply the fractions\n    result = frac_x * frac_n\n\n    # Check if the result is a whole number\n    return result.denominator == 1\n\n# Test cases\nprint(simplify(\"1/5\", \"5/1\"))  # True\nprint(simplify(\"1/6\", \"2/1\"))  # False\nprint(simplify(\"7/10\", \"10/2\"))  # False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/145", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/146", "code_candidates": [{"code": "def specialFilter(nums):\n    \"\"\"\n    Takes an array of numbers as input and returns the number of elements in the array \n    that are greater than 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9).\n    \"\"\"\n    def is_first_and_last_digit_odd(num):\n        # Convert the number to its absolute value to handle negative numbers\n        num_str = str(abs(num))\n        first_digit = int(num_str[0])\n        last_digit = int(num_str[-1])\n        return first_digit % 2 != 0 and last_digit % 2 != 0\n\n    count = 0\n    for num in nums:\n        if num > 10 and is_first_and_last_digit_odd(num):\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "1", "2", "4", "3", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/147", "code_candidates": [{"code": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n    if n < 3:\n        return 0\n\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "4", "36", "53361"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/148", "code_candidates": [{"code": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closest to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n    \n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    if index1 > index2:\n        index1, index2 = index2, index1\n    \n    return tuple(planets[index1 + 1:index2])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["('Saturn', 'Uranus')", "('Venus',)", "('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')", "('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')", "()", "()", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/149", "code_candidates": [{"code": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes the strings that have odd lengths,\n    and returns the resulted list sorted by length ascending, and alphabetically\n    for strings of the same length.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['aa']", "['AI', 'asdf', 'school']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['cc', 'dd', 'aaaa', 'bbbb']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/150", "code_candidates": [{"code": "import math\n\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n    \n    if n <= 1:\n        return y\n    \n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return y\n    \n    return x", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["34", "5", "33", "3", "-1", "583", "129", "1234", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/151", "code_candidates": [{"code": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    total = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            total += num ** 2\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "25", "0", "0", "0", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/152", "code_candidates": [{"code": "def compare(game, guess):\n    \"\"\"\n    Compare the guessed scores with the actual scores and return an array\n    denoting how far off each guess was. If the guess is correct, the value\n    is 0; otherwise, it's the absolute difference between the guess and the score.\n    \n    :param game: List of actual scores\n    :param guess: List of guessed scores\n    :return: List of differences\n    \"\"\"\n    # Ensure both lists are of the same length\n    if len(game) != len(guess):\n        raise ValueError(\"Both game and guess lists must be of the same length\")\n    \n    # Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate through each match and calculate the difference\n    for actual, guessed in zip(game, guess):\n        if actual == guessed:\n            differences.append(0)\n        else:\n            differences.append(abs(actual - guessed))\n    \n    return differences", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/153", "code_candidates": [{"code": "def Strongest_Extension(class_name: str, extensions: list) -> str:\n    \"\"\"\n    Finds the strongest extension based on the given criteria and returns the class name with the strongest extension.\n    \n    Args:\n    class_name (str): The name of the class.\n    extensions (list): A list of extension names.\n    \n    Returns:\n    str: A string in the format 'ClassName.StrongestExtensionName'.\n    \"\"\"\n    def calculate_strength(extension: str) -> float:\n        \"\"\"\n        Calculates the strength of an extension based on the number of uppercase and lowercase letters.\n        \n        Args:\n        extension (str): The name of the extension.\n        \n        Returns:\n        float: The strength of the extension.\n        \"\"\"\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        return CAP - SM\n    \n    if not extensions:\n        return f\"{class_name}.\"\n    \n    strongest_extension = max(extensions, key=calculate_strength)\n    return f\"{class_name}.{strongest_extension}\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["Watashi.eIGHt8OKe", "Boku123.YEs.WeCaNe", "__YESIMHERE.NuLl__", "K.TAR", "__HAHA.123", "YameRore.okIWILL123", "finNNalLLly.WoW", "_.Bb", "Sp.671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/154", "code_candidates": [{"code": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    Returns True if the second word or any of its rotations is a substring in the first word.\n    \"\"\"\n    if not a or not b:\n        return False\n\n    # Create all rotations of b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n\n    # Check if any rotation is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/155", "code_candidates": [{"code": "def even_odd_count(num):\n    \"\"\"Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Example:\n       even_odd_count(-12) ==> (1, 1)\n       even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    # Handle negative numbers by taking the absolute value\n    num = abs(num)\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each digit in the number\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(0, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/156", "code_candidates": [{"code": "def int_to_mini_roman(number: int) -> str:\n    \"\"\"\n    Given a positive integer, obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000 inclusive.\")\n\n    roman_numerals = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n\n    result = []\n    for value, symbol in roman_numerals:\n        while number >= value:\n            result.append(symbol)\n            number -= value\n\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/157", "code_candidates": [{"code": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # Handle edge cases where any side is zero or negative\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    \n    # Sort the sides to easily identify the hypotenuse\n    sides = sorted([a, b, c])\n    \n    # Apply the Pythagorean theorem\n    return sides[0]**2 + sides[1]**2 == sides[2]**2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/158", "code_candidates": [{"code": "def find_max(words):\n    \"\"\"\n    Write a function that accepts a list of strings.\n    The list contains different words. Return the word with maximum number\n    of unique characters. If multiple strings have maximum number of unique\n    characters, return the one which comes first in lexicographical order.\n    \"\"\"\n    if not words:\n        return None\n\n    max_unique_count = -1\n    max_word = None\n\n    for word in words:\n        unique_chars = set(word)\n        unique_count = len(unique_chars)\n\n        if unique_count > max_unique_count:\n            max_unique_count = unique_count\n            max_word = word\n        elif unique_count == max_unique_count:\n            if max_word is None or word < max_word:\n                max_word = word\n\n    return max_word", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "enam", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/159", "code_candidates": [{"code": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    # Calculate the total number of carrots needed\n    total_needed = number + need\n    \n    # Determine how many carrots can be eaten\n    if remaining >= need:\n        # If there are enough carrots, eat the needed amount\n        eaten = number + need\n        left = remaining - need\n    else:\n        # If there are not enough carrots, eat all remaining\n        eaten = number + remaining\n        left = 0\n    \n    return [eaten, left]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["[11, 4]", "[12, 1]", "[11, 0]", "[7, 0]", "[9, 2]", "[5, 0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/160", "code_candidates": [{"code": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebraic \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n    # Start with the first operand\n    result = operand[0]\n    \n    # Iterate through the operator and operand lists to build the expression\n    for op, num in zip(operator, operand[1:]):\n        if op == '+':\n            result += num\n        elif op == '-':\n            result -= num\n        elif op == '*':\n            result *= num\n        elif op == '//':\n            result //= num\n        elif op == '**':\n            result **= num\n    \n    return result", "index": 0, "passed_case": [0, 2], "case_status": ["37", "15", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/161", "code_candidates": [{"code": "def solve(s: str) -> str:\n    # Check if the string contains no letters\n    if not any(c.isalpha() for c in s):\n        return s[::-1]\n    \n    # Process each character in the string\n    result = ''.join(c.swapcase() if c.isalpha() else c for c in s)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["aSdF", "4321", "AB", "#A@c", "#aSDFw^45", "2@6#", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/162", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/163", "code_candidates": [{"code": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    # Ensure a is the smaller number\n    start, end = min(a, b), max(a, b)\n    \n    # Generate the list of even digits between start and end\n    even_digits = [x for x in range(start, end + 1) if x % 2 == 0]\n    \n    return even_digits", "index": 0, "passed_case": [], "case_status": ["[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132]", "[18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/0_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers meeting a certain condition (e.g. closer to or larger than each other than\n    given threshold).\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    # Handle edge case where the list is empty\n    if not numbers:\n        return False\n\n    # Iterate through all pairs of numbers\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/1_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace has a certain requirement to meet) and not nested within each other\n    Keep or ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    result = []\n    current_group = \"\"\n    balance = 0\n\n    for char in paren_string:\n        if char == '(':\n            balance += 1\n            current_group += char\n        elif char == ')':\n            balance -= 1\n            current_group += char\n            if balance == 0:\n                result.append(current_group.strip())\n                current_group = \"\"\n        elif char == ' ' and balance == 0:\n            continue\n        elif balance > 0:\n            current_group += char\n\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['( )', '(( ))', '(( )( ))']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/2_prompt1a", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, return the decimal part of the number.\n    If the number is an integer, return 0.0.\n    >>> truncate_number(3.5)\n    0.5\n    >>> truncate_number(5.0)\n    0.0\n    \"\"\"\n    if number % 1 == 0:\n        return 0.0\n    return number % 1", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0.5", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/3_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef has_balance_fallen_below_zero(starting_balance: float, operations: List[float]) -> bool:\n    if starting_balance < 0:\n        return True\n    \n    current_balance = starting_balance\n    \n    for operation in operations:\n        current_balance += operation\n        if current_balance < 0:\n            return True\n    \n    return False", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/4_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    if len(numbers) == 1:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean_value) for number in numbers]\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/5_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef insert_between(numbers: List[int], x: int) -> List[int]:\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    for num in numbers[1:]:\n        result.append(x)\n        result.append(num)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[5, 8, 6, 8, 3, 8, 2]", "[2, 2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/6_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by certain characters.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n                if current_depth < 0:\n                    break\n        if current_depth == 0:\n            result.append(max_depth)\n        else:\n            result.append(0)  # Invalid group, but we'll return 0 for consistency\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/7_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], x: str) -> List[str]:\n    \"\"\" Process an input list of strings given string x\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if x in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/8_prompt1a", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of the sum and the product of all integers in the list.\n    If the list is empty, the sum should be equal to 0 and the product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    \n    return (total_sum, total_product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/9_prompt1a", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum values found until each moment in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_values = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_values.append(current_max)\n    \n    return max_values", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/10_prompt1a", "code_candidates": [{"code": "def longest_palindrome_prefix(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    # Reverse the prefix\n    reversed_prefix = s[::-1]\n    \n    # Append the reversed prefix to the original string\n    candidate = s + reversed_prefix\n    \n    # Find the longest palindrome prefix\n    for i in range(len(s), len(candidate)):\n        substring = candidate[:i]\n        if substring == substring[::-1]:\n            return substring\n    \n    return s\n\n# Example usage:\n# print(longest_palindrome_prefix(\"race\"))  # Output: \"racecar\"\n# print(longest_palindrome_prefix(\"\"))       # Output: \"\"\n# print(longest_palindrome_prefix(\"a\"))      # Output: \"aa\"", "index": 0, "passed_case": [0, 1, 3], "case_status": ["", "x", "xyz", "xyx", "jerry"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/11_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform certain bitwise operation on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length\")\n    \n    result = []\n    for char_a, char_b in zip(a, b):\n        if char_a not in '01' or char_b not in '01':\n            raise ValueError(\"Input strings must contain only '0' and '1'\")\n        xor_result = '0' if char_a == char_b else '1'\n        result.append(xor_result)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/12_prompt1a", "code_candidates": [{"code": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n    None\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    return max(strings, key=len)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/13_prompt1a", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/14_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [string[:i] for i in range(1, len(string) + 1)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/15_prompt1a", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto a certain number inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    if n < 0:\n        return \"\"\n    return \" \".join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "0 1 2 3", "0 1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/16_prompt1a", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    # Convert the string to lowercase to handle case insensitivity\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(string)\n    # Return the number of unique characters\n    return len(unique_characters)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/17_prompt1a", "code_candidates": [{"code": "def parse_notes(notes: str) -> List[float]:\n    note_mapping = {\n        'o': 1.0,\n        'o|': 2.0,\n        '.|': 0.5\n    }\n    \n    parsed_notes = []\n    i = 0\n    while i < len(notes):\n        if notes[i] == 'o':\n            if i + 1 < len(notes) and notes[i + 1] == '|':\n                note = 'o|'\n                i += 2\n            else:\n                note = 'o'\n                i += 1\n        elif notes[i] == '.':\n            if i + 1 < len(notes) and notes[i + 1] == '|':\n                note = '.|'\n                i += 2\n            else:\n                raise ValueError(f\"Unknown note representation: {notes[i]}\")\n        else:\n            raise ValueError(f\"Unknown note representation: {notes[i]}\")\n        \n        if note in note_mapping:\n            parsed_notes.append(note_mapping[note])\n        else:\n            raise ValueError(f\"Unknown note representation: {note}\")\n    \n    return parsed_notes", "index": 0, "passed_case": [0], "case_status": ["[]", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/18_prompt1a", "code_candidates": [{"code": "def how_many_times(a: str, b: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    len_a, len_b = len(a), len(b)\n    if len_b == 0:\n        return 0\n    for i in range(len_a - len_b + 1):\n        if a[i:i+len_b] == b:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/19_prompt1a", "code_candidates": [{"code": "from typing import List, Dict\n\ndef sort_numerals(numerals_str: str) -> str:\n    numeral_order = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    # Split the input string into a list of numerals\n    numerals_list = numerals_str.split()\n    \n    # Filter out invalid numerals\n    valid_numerals = [num for num in numerals_list if num in numeral_order]\n    \n    # Sort the valid numerals based on their numerical value\n    sorted_numerals = sorted(valid_numerals, key=lambda x: numeral_order[x])\n    \n    # Join the sorted numerals back into a space-delimited string\n    return ' '.join(sorted_numerals)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "three", "three five nine", "zero four five seven eight nine", "zero one two three four five six"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/20_prompt1a", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef find_closest_numbers(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers or len(numbers) < 2:\n        return (None, None)\n    \n    numbers_sorted = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (None, None)\n    \n    for i in range(len(numbers_sorted) - 1):\n        diff = abs(numbers_sorted[i] - numbers_sorted[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers_sorted[i], numbers_sorted[i + 1])\n    \n    return closest_pair", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/21_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef linear_transform(numbers: List[float]) -> List[float]:\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    if all(num == numbers[0] for num in numbers):\n        return [0.0] * len(numbers)\n    \n    min_num = min(numbers)\n    max_num = max(numbers)\n    \n    if min_num == max_num:\n        return [0.0] * len(numbers)\n    \n    transformed = [(num - min_num) / (max_num - min_num) for num in numbers]\n    return transformed", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/22_prompt1a", "code_candidates": [{"code": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for certain types\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/23_prompt1a", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return the length of the given string.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    >>> strlen('abba')\n    4\n    \"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/24_prompt1a", "code_candidates": [{"code": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return None  # No divisors smaller than n for n <= 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    \n    return None  # Fallback, though it should always find a divisor for n > 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/25_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of factors of given integer in the descending or ascending order.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/26_prompt1a", "code_candidates": [{"code": "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int], K: int) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur exactly K time(s). Keep the order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4], 1)\n    [1, 3, 4]\n    >>> remove_duplicates([1, 2, 2, 3, 3, 3, 4], 2)\n    [1, 3, 3, 3, 4]\n    >>> remove_duplicates([1, 2, 2, 3, 3, 3, 4], 3)\n    [1, 2, 2, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    count = Counter(numbers)\n    return [num for num in numbers if count[num] != K]", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/27_prompt1a", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase or uppercase characters to either uppercase or lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    return ''.join(char.lower() if char.isupper() else char.upper() for char in string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/28_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef concatenate_strings(strings: List[str]) -> str:\n    if not strings:\n        return \"\"\n    return \"\".join(strings)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "xyz", "xyzwk"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/29_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that satisfy certain condition with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/30_prompt1a", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [x for x in l if x > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/31_prompt1a", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    \"\"\"\n    Return true if a given number is prime, and false if it is composite or neither prime nor composite.\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/32_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef candidate(xs: List[float]) -> float:\n    # Check if all coefficients are zero\n    if all(x == 0 for x in xs):\n        raise ValueError(\"All coefficients are zero, no solution exists.\")\n    \n    # Find the largest non-zero coefficient\n    largest_non_zero = max(xs, key=lambda x: abs(x) if x != 0 else -float('inf'))\n    \n    # If the polynomial has an even number of coefficients, ensure a solution exists\n    if len(xs) % 2 == 0:\n        # Find the smallest zero point in the range of the polynomial's domain\n        # For simplicity, we assume the domain is [-100, 100] and use a simple search\n        for x in range(-100, 101):\n            result = sum(coeff * (x ** i) for i, coeff in enumerate(xs))\n            if result == 0:\n                return x\n        \n        # If no zero point is found, raise an error\n        raise ValueError(\"No solution exists for the given coefficients.\")\n    \n    # If the polynomial has an odd number of coefficients, the polynomial will cross the x-axis\n    # We can use the largest non-zero coefficient to find a candidate point\n    candidate_point = -largest_non_zero / xs[-1] if xs[-1] != 0 else 0\n    \n    return candidate_point", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/33_prompt1a", "code_candidates": [{"code": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted descendingly or ascendingly.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if not l:\n        return l\n    \n    # Extract elements at indices divisible by 3\n    divisible_by_three = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements in descending order\n    sorted_divisible_by_three = sorted(divisible_by_three, reverse=True)\n    \n    # Reconstruct the list with sorted elements at indices divisible by 3\n    result = l.copy()\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[5, 6, 3, 4, 8, 9, 2]", "[5, 8, 3, 4, 6, 9, 2]", "[5, 6, 9, 4, 8, 3, 2]", "[5, 6, 3, 4, 8, 9, 2, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/34_prompt1a", "code_candidates": [{"code": "def unique(l: list, ascending: bool = True):\n    if l is None:\n        return []\n    seen = set()\n    unique_elements = []\n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            unique_elements.append(item)\n    return sorted(unique_elements, reverse=not ascending)", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/35_prompt1a", "code_candidates": [{"code": "def max_element(l: list):\n    \"\"\"Return the maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        return None\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/36_prompt1a", "code_candidates": [{"code": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n * n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "index": 0, "passed_case": [], "case_status": ["113", "289", "295", "639", "2560", "1704904", "Timeout", "Timeout"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/37_prompt1a", "code_candidates": [{"code": "def sort_even(l: list) -> list:\n    if not l:\n        return []\n    \n    # Extract values at even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort even values in descending order\n    even_values_sorted = sorted(even_values, reverse=True)\n    \n    # Reconstruct the list with sorted even values\n    l_prime = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_values_sorted[even_index])\n            even_index += 1\n        else:\n            l_prime.append(l[i])\n    \n    return l_prime", "index": 0, "passed_case": [], "case_status": ["[3, 2, 1]", "[123, 3, 9, 2, 5, 3, -3, 0, -5, 1, -10]", "[23, 8, 12, 4, 5, 2, 3, 11, -12, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/38_prompt1a", "code_candidates": [{"code": "def candidate(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with the encode_cyclic function. If the input string is already encoded, it decodes it. If the input string is not encoded, it encodes it.\n    \"\"\"\n    def encode_cyclic(s: str) -> str:\n        \"\"\"\n        Encodes a string by shifting each character by 1 in the alphabet.\n        \"\"\"\n        encoded = []\n        for char in s:\n            if 'a' <= char <= 'z':\n                encoded_char = chr((ord(char) - ord('a') + 1) % 26 + ord('a'))\n            elif 'A' <= char <= 'Z':\n                encoded_char = chr((ord(char) - ord('A') + 1) % 26 + ord('A'))\n            else:\n                encoded_char = char\n            encoded.append(encoded_char)\n        return ''.join(encoded)\n\n    def decode_cyclic(s: str) -> str:\n        \"\"\"\n        Decodes a string by shifting each character back by 1 in the alphabet.\n        \"\"\"\n        decoded = []\n        for char in s:\n            if 'a' <= char <= 'z':\n                decoded_char = chr((ord(char) - ord('a') - 1) % 26 + ord('a'))\n            elif 'A' <= char <= 'Z':\n                decoded_char = chr((ord(char) - ord('A') - 1) % 26 + ord('A'))\n            else:\n                decoded_char = char\n            decoded.append(decoded_char)\n        return ''.join(decoded)\n\n    # Check if the string is encoded by attempting to decode it\n    try:\n        decoded_attempt = decode_cyclic(s)\n        # If decoding doesn't raise an exception, assume it's encoded\n        return decoded_attempt\n    except:\n        # If decoding fails, encode the string\n        return encode_cyclic(s)", "index": 0, "passed_case": [], "case_status": ["zwcgghwcdwqurmbzbafg", "zqsvtfqmvnrgyzhyex", "hdjxjfblckkchysa", "clqqibsktfvraubgx", "gcbhnlketkfkuh", "bsteqtgewlhnvqtujgxx", "ayglhjfrbv", "toftnlhddwqghwq", "rlmgdkobpacxtedumys", "lslphnzuqwc", "xhqtjximcnzewhwxeppc", "tpifdsxekxpqsjzzcoky", "aggbbrobwqxxdd", "qeopshfqmwvxvifutlkn", "cgnbjgrqzrggbvzagt", "jbaghpofuqd", "ogroyyfcmumcmmkwanu", "catwjlcgyfqfdmnhnegb", "qcytqabxzemgofola", "zllyyhimnwyv", "voufidarfqawjawroa", "eapbepsbbglurgcsar", "mubrprhfjvjuhlgutdi", "xbjnszcbrfpqdkhbg", "eniviqytszupiuq", "hcdwqchidsf", "utfpohabhmhtzja", "hetnqwmqvcbz", "akqqdrdamkyi", "fukucgxqkm", "dgwyyemzewjemyywyug", "yvelacgfokinyg", "ufzjhlxhbtpkl", "jzqhecharsmcwykmsjpc", "fhrvmapyzuwqwuwf", "bumsjjcwupiimju", "iqvfmdluueswilrq", "ifiyrmtjsn", "ufnoypweybiuutpsj", "guxgyidzfag", "xbsmtnfvrlovgdltv", "xcxmgxyvep", "qgandcnuyqspxnjsw", "qnmwoehxnthgxpxtgo", "bvnghijqjddbgl", "fbvmjmnmqfma", "rvxxrzozlixkmqlw", "sgyghoozmjulyluenw", "qzsrrlzbumdt", "ahejfljjnlhxmhxbo", "qawgtkxtba", "fzgdgsoudc", "nvfxkhssevcweixrzci", "llufbvvtrcvgiuxycsy", "akymuqbpkjztocmktmn", "ewmthpyqsonx", "rhwgbjnghnrxulsj", "jeofkohjyh", "hqvpfzgwboqmgvxtvoo", "zbygligivrkuqpokm", "kvjhingchfjwwqcvex", "wofwrhpsxcfii", "eikvqzhadqiav", "xotzrcooijen", "ochlobrtbu", "dydibrcqgx", "sysgxslnpirnirms", "wcsftxhufb", "eqgezbnvmois", "ivgvniugbh", "uyrmcfgtqhddaebisywr", "cnnivvhplonqbs", "wjmhzsgubr", "xuzrahxexptohenmtro", "kmojujejcmv", "uliqaxbjnjchlpxzu", "manpkfxosnxtfhadiq", "ocvtszgvyiqeqmzbg", "ctnovdpvihm", "gnodlqspfdbwxyhmj", "zihirwuornqdkjoxqq", "jfngrvgxlajmovwy", "uyldotdpajcrcpnn", "dmwdbtyhoj", "ltvjubljqvxtqaobgst", "gwimcbtvxnecizvjyaai", "mdkpmguyreeeslb", "goudgrthnhunynzuqie", "krntmihnvif", "cgorklivrzuihzlr", "waxwosxyisyggtkshfux", "dtuttciyaarnwdkijbwm", "dyfkpqhepoyh", "jywnbcxgdwuuly", "bykzhlcnquwkhrutkl", "gousqzsgjtb", "vinmctaadocigqclndku", "rwmdmwcotmhsvkannf", "cukqtkalkfchn", "ftusztyjagd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/39_prompt1a", "code_candidates": [{"code": "import math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef prime_fib(n: int) -> int:\n    \"\"\"\n    Returns the n-th number that is a Fibonacci number and it's also prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    fib_sequence = [0, 1]\n    count = 0\n    while True:\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        fib_sequence.append(next_fib)\n        if is_prime(next_fib):\n            count += 1\n            if count == n:\n                return next_fib\n\n# Example usage:\n# print(prime_fib(1))  # Output: 2\n# print(prime_fib(2))  # Output: 3\n# print(prime_fib(3))  # Output: 5\n# print(prime_fib(4))  # Output: 13\n# print(prime_fib(5))  # Output: 89", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "433494437"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/40_prompt1a", "code_candidates": [{"code": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    Return True if there are three distinct elements in the list that sum to zero, and False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if len(l) < 3:\n        return False\n\n    # Sort the list to use a three-pointer approach\n    l.sort()\n\n    # Iterate through the list to find the triplet\n    for i in range(len(l) - 2):\n        # Skip duplicates\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        left = i + 1\n        right = len(l) - 1\n\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/41_prompt1a", "code_candidates": [{"code": "def car_race_collision(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of cars moving in opposite directions.\n\n    Args:\n        n (int): The number of cars in each set (total cars in each direction is either n or 2*n).\n\n    Returns:\n        int: The number of collisions.\n    \"\"\"\n    # The number of collisions is determined by the number of ways to pair the cars.\n    # If there are n cars moving left to right and n cars moving right to left,\n    # each left-moving car will collide with each right-moving car exactly once.\n    # Therefore, the number of collisions is n * n.\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/42_prompt1a", "code_candidates": [{"code": "def incr_list(l: list) -> list:\n    if not l:\n        return []\n    for item in l:\n        if not isinstance(item, int):\n            raise ValueError(\"All elements in the list must be integers.\")\n    return [x + 1 for x in l]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/43_prompt1a", "code_candidates": [{"code": "def pairs_sum_to_zero(l):\n    \"\"\"\n    Takes a list of integers as an input.\n    Returns True if there are elements in the list that sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    # Create a set to store the seen numbers\n    seen = set()\n    \n    # Iterate through the list\n    for num in l:\n        # Check if the negative of the current number is in the seen set\n        if -num in seen:\n            return True\n        # Add the current number to the seen set\n        seen.add(num)\n    \n    # If no pairs sum to zero, return False\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/44_prompt1a", "code_candidates": [{"code": "def change_base(x: int, y: int) -> str:\n    if y < 2 or y >= 10:\n        raise ValueError(\"Base y must be between 2 and 9 inclusive.\")\n    \n    if x == 0:\n        return \"0\"\n    \n    result = \"\"\n    is_negative = False\n    \n    if x < 0:\n        is_negative = True\n        x = -x\n    \n    while x > 0:\n        result = str(x % y) + result\n        x = x // y\n    \n    return \"-\" + result if is_negative else result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/45_prompt1a", "code_candidates": [{"code": "def triangle_area(x, y):\n    \"\"\"Given length of a side and height, return the area of a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    if x <= 0 or y <= 0:\n        raise ValueError(\"Both side length and height must be positive numbers.\")\n    return (x * y) / 2", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/46_prompt1a", "code_candidates": [{"code": "def fib4(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 3\n    \n    # Initialize the first four Fib4 numbers\n    fib4_minus_4 = 0\n    fib4_minus_3 = 1\n    fib4_minus_2 = 2\n    fib4_minus_1 = 3\n    \n    # Compute Fib4 numbers iteratively\n    for _ in range(4, n + 1):\n        fib4_current = fib4_minus_1 + fib4_minus_2 + fib4_minus_3 + fib4_minus_4\n        fib4_minus_4, fib4_minus_3, fib4_minus_2, fib4_minus_1 = fib4_minus_3, fib4_minus_2, fib4_minus_1, fib4_current\n    \n    return fib4_minus_1", "index": 0, "passed_case": [], "case_status": ["12", "85", "316", "1174"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/47_prompt1a", "code_candidates": [{"code": "def median(l: list):\n    \"\"\"Return the median of elements in the list l.\n    If the list has an odd number of elements, return the middle element.\n    If the list has an even number of elements, return the average of the two middle elements.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if not l:\n        return None  # Handle empty list case\n    \n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    \n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "8.0", "5", "5.5", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/48_prompt1a", "code_candidates": [{"code": "import re\n\ndef is_palindrome(text: str) -> bool:\n    if not text:\n        return True  # An empty string is considered a palindrome\n    \n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned_text = re.sub(r'[^a-zA-Z0-9]', '', text).lower()\n    \n    # Check if the cleaned text is the same forwards and backwards\n    return cleaned_text == cleaned_text[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/49_prompt1a", "code_candidates": [{"code": "def modulo(x: int, y: int) -> int:\n    if y == 0:\n        raise ValueError(\"Modulo by zero is undefined\")\n    return x % y", "index": 0, "passed_case": [0], "case_status": ["3", "91", "0", "3", "100", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/50_prompt1a", "code_candidates": [{"code": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef candidate(s: str):\n    \"\"\"\n    takes as input string decoded or encoded with encode_shift function. Returns decoded or encoded string.\n    \"\"\"\n    return encode_shift(encode_shift(s))", "index": 0, "passed_case": [], "case_status": ["spmxwwtmskmgrhcqprvw", "ipgvljlgcwdhxopnou", "zxtvnzsrbsaaixoq", "gsbrgyjiahvlrqkwn", "rwsbxdjauaavkx", "jrijugmwudbxjlgwkznn", "wqozbxrvhl", "vjebjdtxtwmggxm", "chbawtfernqstjuokci", "bbidfxgpkms", "gnxnjzsycudpmmxfnufs", "yjfivtanugnfpizepsao", "wqwhrrmerngntt", "eguxficvgnmlvlybkjad", "dswwrzphgwhwprljqw", "qzrfwxkevgt", "hewoeocvsskcaccdmqk", "jsqbmzoswvvgdtcuxdwr", "ogsqjgprnwuceevbq", "bpbxoodyclmo", "kletvyvqhmgqmzqqhe", "fuqfrurirkwbshwhiq", "rckhhfzxvklzwxbtkjy", "znrpdihsrgvfxtarw", "yudglyiojfpkgyk", "txssmgtxyiv", "vkjxfexqrjcxqpz", "jxumdglcgpsr", "gqahgtctqyao", "avkwksangc", "mtwuooucpumzocokmow", "uolsbqewvdayow", "pkvbzxrnxajfb", "gzpsxuhxqsicamozcifs", "hvxqlcpfogkmmmkv", "crkzizksmyfykcz", "lygtvckbkmuihybg", "yyvcohijzd", "dkvfeoomukryfkjiz", "nwkywovtpqw", "inrdcjhvllbebwtjl", "nnsncwuolf", "qgwsdtodkfgizndim", "cgdumedxnwjxnnfejw", "drlywxzzgrttwb", "lvrcczgdcqvc", "nhlpnhbepaynbcgm", "oiwewxcepbzkkobmud", "igpbhhkprjct", "uqxbzvdzznbxncxre", "mgqawjrnjq", "wvpitwteks", "vdlxnauiimlsnuyshpy", "kbblvrhljwslnykioso", "oqagckarfjzpcescajd", "cumfjxiogned", "mhxzwrxdwndhikbz", "ezuevaoxzx", "lxgpfvrwmcegnwlejle", "oprywblwykhaegfac", "zaldxyxwsmvzsmgnlu", "vmexmhnfiysvy", "auyplgtxqqgyl", "jnesphyeedzu", "xesrberhjk", "ttohyrwsgn", "iioiwnfbddyhcyhi", "imsnvjvxkr", "wugrupcdliey", "wylyldrkwx", "hkovcsgwjtxtrquoyimh", "dsdlylbxfgedri", "cmzixprwkh", "pnkxhqnnuefjdxuhcje", "eaczzksuzcl", "ykbngqdrzxzsnbfpk", "dcqvfainejdnqvxgty", "lespjiowluygpgcrw", "dsjtelyflxc", "ewdgtbvifmtrxnocz", "xpymyhhketdgeazgng", "dzvlwhbwncqzmelo", "bkojteqtfhzsdsfd", "mtcjtreoxz", "lbjrzkgbzjlnegqirwj", "ywmrcsnjlsdulypqzoqy", "actwfchkouuurib", "kwehtwdjxdxkpodykgu", "dahyjclxdyv", "eswbhahylypkbxph", "nmqimeynowioawjvixkn", "ktjsjjqyodqhamtryzmc", "vtogaffxuxeo", "mzosdrtnwkmkbo", "arobpxgsdakmkxhbja", "kwepigziwjr", "dlyjcstqqyesswgtbdak", "chmmtcjseicxqlavdd", "askagjaqbxvsd", "kvjjipqozwt"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/51_prompt1a", "code_candidates": [{"code": "def remove_vowels(text: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/52_prompt1a", "code_candidates": [{"code": "def below_threshold(l: list, t: int) -> bool:\n    if not l:\n        return True\n    \n    for num in l:\n        if not isinstance(num, int):\n            raise TypeError(\"List contains non-integer elements\")\n        if num >= t:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/53_prompt1a", "code_candidates": [{"code": "def add(x: int, y: int) -> int:\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/54_prompt1a", "code_candidates": [{"code": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    Check if two words have the same characters, regardless of order and repetition.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    from collections import Counter\n\n    # Count the frequency of each character in both strings\n    counter_s0 = Counter(s0)\n    counter_s1 = Counter(s1)\n\n    # Compare the counters\n    return counter_s0 == counter_s1", "index": 0, "passed_case": [3, 4, 5, 6], "case_status": ["False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/55_prompt1a", "code_candidates": [{"code": "def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\n    \n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/56_prompt1a", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    count = 0\n    for bracket in brackets:\n        if bracket == '<':\n            count += 1\n        elif bracket == '>':\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/57_prompt1a", "code_candidates": [{"code": "def monotonic(l: list):\n    \"\"\"Return True if the list elements are strictly increasing or strictly decreasing.\n    If the list contains repeated elements, return False.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    >>> monotonic([1, 2, 2, 3])\n    False\n    \"\"\"\n    if not l:\n        return False\n    \n    increasing = all(l[i] < l[i+1] for i in range(len(l)-1))\n    decreasing = all(l[i] > l[i+1] for i in range(len(l)-1))\n    \n    return increasing or decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 5, 6], "case_status": ["True", "True", "False", "True", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/58_prompt1a", "code_candidates": [{"code": "def common(l1: list, l2: list) -> list:\n    # Find common elements using set intersection\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Convert the set to a sorted list\n    return sorted(list(common_elements))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/59_prompt1a", "code_candidates": [{"code": "def largest_prime_factor(n: int) -> int:\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            other_factor = n // i\n            if is_prime(other_factor):\n                return other_factor\n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/60_prompt1a", "code_candidates": [{"code": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    Function that sums up all numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/61_prompt1a", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every closing or opening bracket has a corresponding closing or opening bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == '(':\n            balance += 1\n        elif bracket == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/62_prompt1a", "code_candidates": [{"code": "def derivative(xs: list) -> list:\n    if not xs:\n        return []\n    if len(xs) == 1:\n        return [0]\n    return [xs[i] * i for i in range(1, len(xs))]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/63_prompt1a", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute an arbitrary element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize the first three FibFib numbers\n    a, b, c = 0, 0, 1\n    \n    # Compute FibFib numbers iteratively\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    \n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/64_prompt1a", "code_candidates": [{"code": "def vowels_count(s: str) -> int:\n    vowels = set(\"aeiouAEIOU\")\n    count = 0\n    words = s.split()\n    \n    for word in words:\n        word_vowels = vowels.copy()\n        if word and word[-1].lower() == 'y':\n            word_vowels.add('y')\n            word_vowels.add('Y')\n        \n        for char in word:\n            if char in word_vowels:\n                count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/65_prompt1a", "code_candidates": [{"code": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits left or right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    x_str = str(x)\n    length = len(x_str)\n    \n    if shift > length:\n        return x_str[::-1]\n    \n    shift = shift % length  # Ensure shift is within the bounds of the number of digits\n    \n    if shift == 0:\n        return x_str\n    \n    shifted_str = x_str[shift:] + x_str[:shift]\n    return shifted_str", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["010", "12", "79", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/66_prompt1a", "code_candidates": [{"code": "def digitSum(s: str) -> int:\n    return sum(ord(char) for char in s if char.isupper())", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "131", "67", "69", "131", "153", "151", "327"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/67_prompt1a", "code_candidates": [{"code": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string that represents the number of apples and oranges, and an integer\n    that represents the total number of fruits in the basket, return the number of\n    mangoes in the basket.\n    \n    :param s: A string in the format \"X apples and Y oranges\" where X and Y are integers.\n    :param n: An integer representing the total number of fruits in the basket.\n    :return: The number of mangoes in the basket.\n    \"\"\"\n    # Split the string to extract the number of apples and oranges\n    parts = s.split()\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/68_prompt1a", "code_candidates": [{"code": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the value.\n    If multiple nodes with the value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ value, its index ],\n    If there are no values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not arr:\n        return []\n    \n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    \n    return [min_value, min_index]", "index": 0, "passed_case": [0, 2, 3, 4, 5], "case_status": ["[2, 1]", "[1, 0]", "[]", "[0, 1]", "[0, 3]", "[4, 1]", "[1, 3]", "[1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/69_prompt1a", "code_candidates": [{"code": "from collections import Counter\n\ndef search(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the smallest or greatest integer that is greater than zero, and has a frequency equal to the value of the integer itself. If no such a value exists, return -1.\n    Examples:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n    # Count the frequency of each integer in the list\n    frequency = Counter(lst)\n    \n    # Filter integers that have a frequency equal to their value\n    valid_integers = [num for num in frequency if frequency[num] == num]\n    \n    # If no such integer exists, return -1\n    if not valid_integers:\n        return -1\n    \n    # Return the smallest valid integer\n    return min(valid_integers)", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7, 8, 12, 13, 16, 19, 20, 24], "case_status": ["1", "4", "-1", "8", "-1", "-1", "2", "1", "-1", "-1", "-1", "3", "1", "4", "1", "-1", "4", "1", "1", "-1", "-1", "-1", "-1", "-1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/70_prompt1a", "code_candidates": [{"code": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in a certain order (ascending, strange or another).\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left = 0\n    right = len(sorted_lst) - 1\n    toggle = True\n\n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/71_prompt1a", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return -1 if the sides do not form a valid triangle\n        return -1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["6.0", "-1", "8.18", "1.73", "-1", "16.25", "-1", "0.43", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/72_prompt1a", "code_candidates": [{"code": "def will_it_fly(q, w):\n    # Check if q is a palindromic list\n    is_palindromic = q == q[::-1]\n    \n    # Check if the sum of elements in q is less than or equal to w\n    sum_q = sum(q)\n    is_sum_valid = sum_q <= w\n    \n    # Return True if both conditions are met, otherwise False\n    return is_palindromic and is_sum_valid", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/73_prompt1a", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n\n    changes = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n\n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/74_prompt1a", "code_candidates": [{"code": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list more than or less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n    \n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[]", "['hi', 'hi']", "['hi', 'admin']", "['4']", "['hI', 'Hi']", "['hI', 'hi', 'hi']", "['hi', 'admin']", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/75_prompt1a", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2:\n        return False\n    if is_prime(a):\n        return False\n\n    for i in range(2, a):\n        if a % i == 0 and is_prime(i):\n            quotient = a // i\n            if is_prime(quotient):\n                return True\n            if is_multiply_prime(quotient):\n                return True\n    return False\n\n# Example usage:\n# print(is_multiply_prime(30))  # Output: True", "index": 0, "passed_case": [0, 1, 2, 4, 5, 9], "case_status": ["False", "True", "True", "True", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/76_prompt1a", "code_candidates": [{"code": "def is_simple_power(a, b):\n    \"\"\"\n    Returns true if a number a is a power of b and false in other cases.\n    a is a simple power of b if b**k = a for some integer k.\n    \"\"\"\n    if b == 1:\n        # Any number is not a power of 1 unless it is 1 itself\n        return a == 1\n    \n    power = 1\n    while power < a:\n        power *= b\n        if power == a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/77_prompt1a", "code_candidates": [{"code": "import math\n\ndef iscube(a: int) -> bool:\n    '''\n    Returns True if the integer a is a cube or a similar exponent of some integer number.\n    '''\n    if a < 0:\n        a = -a\n        root = round(a ** (1/3))\n        return root ** 3 == a\n    elif a == 0:\n        return True\n    else:\n        root = round(a ** (1/3))\n        return root ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/78_prompt1a", "code_candidates": [{"code": "def hex_key(num: str) -> int:\n    \"\"\"\n    Counts the number of hexadecimal digits in the given string that are prime numbers.\n    \n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So, the prime digits in hexadecimal are 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n    \n    Args:\n        num (str): The hexadecimal number as a string.\n    \n    Returns:\n        int: The count of prime digits in the given hexadecimal number.\n    \"\"\"\n    # Define the prime digits in hexadecimal\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count the number of prime digits in the input string\n    count = 0\n    for char in num:\n        if char in prime_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/79_prompt1a", "code_candidates": [{"code": "def decimal_to_binary(decimal: int) -> str:\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    if decimal == 0:\n        return \"db0db\"\n    \n    binary_str = \"\"\n    while decimal > 0:\n        binary_str = str(decimal % 2) + binary_str\n        decimal = decimal // 2\n    \n    return f\"db{binary_str}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/80_prompt1a", "code_candidates": [{"code": "import re\n\ndef is_happy(s):\n    # Extract all substrings of consecutive letters\n    letter_substrings = re.findall(r'[a-zA-Z]+', s)\n    \n    # Check if the length of the string is at least 3\n    if len(s) < 3:\n        return False\n    \n    # Check if all substrings are distinct\n    seen = set()\n    for substring in letter_substrings:\n        if substring in seen:\n            return False\n        seen.add(substring)\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 4, 6], "case_status": ["False", "False", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/81_prompt1a", "code_candidates": [{"code": "def numerical_letter_grade(grades):\n    \"\"\"\n    Converts a list of GPAs to corresponding letter grades based on the provided grading scale.\n\n    Args:\n        grades (list): A list of GPAs (float or int).\n\n    Returns:\n        list: A list of letter grades corresponding to the input GPAs.\n    \"\"\"\n    grade_map = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'D-',\n        -float('inf'): 'E'  # Default case for GPAs less than 0.0\n    }\n\n    letter_grades = []\n    for gpa in grades:\n        if gpa < 0.0:\n            gpa = -float('inf')  # Handle GPAs less than 0.0\n        for threshold in sorted(grade_map.keys(), reverse=True):\n            if gpa >= threshold:\n                letter_grades.append(grade_map[threshold])\n                break\n\n    return letter_grades", "index": 0, "passed_case": [1, 2], "case_status": ["['A+', 'B+', 'C', 'C+', 'A-']", "['D+']", "['D-']", "['D-']", "['D+', 'D-', 'C-', 'B', 'A-']", "['D-', 'D']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/82_prompt1a", "code_candidates": [{"code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length meets a certain condition (e.g. is an even or prime number or another type) or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    return is_prime(len(string))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/83_prompt1a", "code_candidates": [{"code": "def count_integers_starting_or_ending_with_1(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        s = str(i)\n        if s.startswith('1') or s.endswith('1'):\n            count += 1\n    return count", "index": 0, "passed_case": [0], "case_status": ["1", "1", "1", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/84_prompt1a", "code_candidates": [{"code": "def solve(N: int) -> str:\n    if N <= 0:\n        return \"0\"\n    \n    # Convert the number to its hexadecimal representation\n    hex_representation = hex(N)[2:]\n    \n    # Calculate the sum of the digits in the hexadecimal representation\n    digit_sum = sum(int(digit, 16) for digit in hex_representation)\n    \n    return str(digit_sum)", "index": 0, "passed_case": [], "case_status": ["25", "15", "12", "18", "18"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/85_prompt1a", "code_candidates": [{"code": "def add(lst: list[int]) -> int:\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 != 0 and value % 2 == 0:\n            total += value\n    return total", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["88", "122", "0", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/86_prompt1a", "code_candidates": [{"code": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    descending or ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        if word:\n            # Sort characters in ascending order based on ASCII value\n            ordered_word = ''.join(sorted(word))\n            ordered_words.append(ordered_word)\n        else:\n            # Preserve spaces\n            ordered_words.append('')\n    return ' '.join(ordered_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello !!!Wdlor", "", ".Hi My aemn is Meirst .Rboot How aer ?ouy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/87_prompt1a", "code_candidates": [{"code": "def get_row(lst, x):\n    \"\"\"\n    Given a 1 or 2 dimensional data as a nested list, find integer x in the list,\n    and return a list of tuples [(x1, y1), (x2, y2) ...] such that each tuple\n    is a coordinate - (row, column), starting with 0. Sort coordinates initially\n    by rows, and then by columns within each row.\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort coordinates by row, then by column\n    coordinates.sort()\n    \n    return coordinates", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/88_prompt1a", "code_candidates": [{"code": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting.\n    Sort the array in ascending order if the sum of the first and last index values is odd,\n    or in descending order if the sum is even.\n    Don't change the given array.\n    \"\"\"\n    if not array:\n        return []\n    \n    first_value = array[0]\n    last_value = array[-1] if len(array) > 1 else array[0]\n    sum_indices = first_value + last_value\n    \n    if sum_indices % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/89_prompt1a", "code_candidates": [{"code": "def encrypt(text: str) -> str:\n    encrypted_text = \"\"\n    for char in text:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            encrypted_text += encrypted_char\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            encrypted_text += encrypted_char\n        else:\n            encrypted_text += char\n    return encrypted_text", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["lm", "ewhjklnop", "kj", "ix"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/90_prompt1a", "code_candidates": [{"code": "def next_smallest(lst):\n    if not lst:\n        return None\n    \n    unique_elements = list(set(lst))\n    \n    if len(unique_elements) < 2:\n        return None\n    \n    unique_elements.sort()\n    \n    return unique_elements[1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "2", "None", "None", "1", "None", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/91_prompt1a", "code_candidates": [{"code": "def is_bored(S: str) -> int:\n    \"\"\"\n    Counts the number of boredoms in a string. A boredom is a sentence that starts\n    with a given word (such as \"W\", \"I\"). Sentences are delimited by '.', '?' or '!'.\n\n    Args:\n        S (str): The input string containing sentences.\n\n    Returns:\n        int: The number of boredoms found.\n    \"\"\"\n    if not S:\n        return 0\n\n    # Split the string into sentences based on '.', '?', or '!'\n    sentences = []\n    sentence = \"\"\n    for char in S:\n        sentence += char\n        if char in {'.', '?', '!'}:\n            sentences.append(sentence.strip())\n            sentence = \"\"\n    if sentence:\n        sentences.append(sentence.strip())\n\n    # Count the number of boredoms\n    boredom_count = 0\n    for sentence in sentences:\n        if sentence and sentence[0].upper() in {'W', 'I'}:\n            boredom_count += 1\n\n    return boredom_count", "index": 0, "passed_case": [0, 2, 3, 5], "case_status": ["0", "1", "1", "0", "3", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/92_prompt1a", "code_candidates": [{"code": "def any_int(x: int, y: int, z: int) -> bool:\n    # Check if all parameters are integers\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    \n    # Calculate the sum of the other two numbers\n    sum_yz = y + z\n    sum_xz = x + z\n    sum_xy = x + y\n    \n    # Check if any number is larger than or equal to the sum of the other two\n    if x >= sum_yz or y >= sum_xz or z >= sum_xy:\n        return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 4, 5, 6, 7, 8, 9], "case_status": ["True", "False", "False", "True", "True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/93_prompt1a", "code_candidates": [{"code": "def encode(message: str, places: int) -> str:\n    vowels = \"aeiouAEIOU\"\n    encoded_message = \"\"\n\n    for char in message:\n        # Swap the case\n        if char.islower():\n            new_char = char.upper()\n        else:\n            new_char = char.lower()\n\n        # Replace vowels with the letter `places` ahead\n        if new_char in vowels:\n            is_upper = new_char.isupper()\n            # Convert to lowercase for easier manipulation\n            new_char = new_char.lower()\n            # Calculate the new character\n            new_char_code = ord(new_char) + places\n            if new_char_code > ord('z'):\n                new_char_code -= 26\n            new_char = chr(new_char_code)\n            # Convert back to uppercase if necessary\n            if is_upper:\n                new_char = new_char.upper()\n\n        encoded_message += new_char\n\n    return encoded_message", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/94_prompt1a", "code_candidates": [{"code": "from typing import List, Optional\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef skjkasdkd(lst: List[int]) -> Optional[int]:\n    if not lst:\n        return None\n    \n    primes = [x for x in lst if is_prime(x)]\n    \n    if not primes:\n        return None\n    \n    return min(primes) if primes else None", "index": 0, "passed_case": [4], "case_status": ["2", "2", "3", "5", "3", "2", "8191", "7", "97"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/95_prompt1a", "code_candidates": [{"code": "def check_keys_case(d: dict) -> bool:\n    if not d:\n        return False\n    \n    all_lower = all(isinstance(key, str) and key.islower() for key in d)\n    all_upper = all(isinstance(key, str) and key.isupper() for key in d)\n    \n    return all_lower or all_upper", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "False", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/96_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n: int) -> List[int]:\n    if n < 2:\n        return []\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/97_prompt1a", "code_candidates": [{"code": "def product_of_unit_digits(a: int, b: int) -> int:\n    unit_digit_a = a % 10\n    unit_digit_b = b % 10\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/98_prompt1a", "code_candidates": [{"code": "def count_upper(s: str) -> int:\n    # Initialize count\n    count = 0\n    \n    # Iterate over the string\n    for i, char in enumerate(s):\n        # Check if the character is an uppercase vowel\n        if char in 'AEIOU' and (i % 2 == 0):  # Assuming even indices\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/99_prompt1a", "code_candidates": [{"code": "import math\n\ndef closest_integer(value: str) -> int:\n    num = float(value)\n    if num >= 0:\n        if num - math.floor(num) == 0.5:\n            return math.ceil(num)\n        else:\n            return round(num)\n    else:\n        if math.ceil(num) - num == 0.5:\n            return math.floor(num)\n        else:\n            return round(num)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["10", "15", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/100_prompt1a", "code_candidates": [{"code": "def make_a_pile(n: int) -> list:\n    if n <= 0:\n        return []\n    \n    pile = []\n    current_stones = n\n    for _ in range(2 * n):\n        pile.append(current_stones)\n        current_stones += 2\n    \n    return pile", "index": 0, "passed_case": [], "case_status": ["[3, 5, 7, 9, 11, 13]", "[4, 6, 8, 10, 12, 14, 16, 18]", "[5, 7, 9, 11, 13, 15, 17, 19, 21, 23]", "[6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]", "[8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/101_prompt1a", "code_candidates": [{"code": "import re\n\ndef words_string(s: str) -> list:\n    \"\"\"\n    Splits the input string into words and returns an array of the words.\n    \n    Args:\n    s (str): The input string containing words separated by letters, commas, or spaces.\n    \n    Returns:\n    list: A list of words extracted from the input string.\n    \"\"\"\n    # Use regex to find all words, considering words can be separated by letters, commas, or spaces\n    words = re.findall(r'\\b\\w+\\b', s)\n    return words", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/102_prompt1a", "code_candidates": [{"code": "def choose_num(x, y):\n    # Ensure x is less than or equal to y\n    if x > y:\n        x, y = y, x\n\n    # Iterate from y down to x to find the largest odd number\n    for num in range(y, x - 1, -1):\n        if num % 2 != 0:\n            return num\n\n    # If no odd number is found, return -1\n    return -1", "index": 0, "passed_case": [], "case_status": ["15", "13", "12353", "5233", "29", "27", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/103_prompt1a", "code_candidates": [{"code": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    if n == m:\n        return bin(n)\n    average = (n + m) / 2\n    rounded_average = round(average)\n    return bin(rounded_average)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["0b11", "0b1010", "0b1111001010", "0b1111100100", "0b1011000010", "0b101101110", "0b110101101", "0b1001110010", "0b11010111", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/104_prompt1a", "code_candidates": [{"code": "def unique_digits(x):\n    def has_only_odd_digits(num):\n        return all(int(d) % 2 != 0 for d in str(num))\n    \n    def has_only_even_digits(num):\n        return all(int(d) % 2 == 0 for d in str(num))\n    \n    result = []\n    for num in x:\n        if has_only_odd_digits(num) or has_only_even_digits(num):\n            result.append(num)\n    \n    return sorted(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 15, 33]", "[]", "[111, 151]", "[31, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/105_prompt1a", "code_candidates": [{"code": "def by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers descendingly or ascendingly that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    \"\"\"\n    # Filter the array to include only numbers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/106_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef f(n: int) -> List[int]:\n    if n <= 0:\n        return []\n    \n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Calculate factorial for even i\n            factorial = 1\n            for j in range(2, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate sum for odd i\n            result.append(sum(range(1, i + 1)))\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 2, 6, 24, 15]", "[1, 2, 6, 24, 15, 720, 28]", "[1]", "[1, 2, 6]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/107_prompt1a", "code_candidates": [{"code": "def even_odd_palindrome(n: int) -> tuple:\n    def is_palindrome(x: int) -> bool:\n        s = str(x)\n        return s == s[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, 2 * n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)", "index": 0, "passed_case": [], "case_status": ["(13, 20)", "(5, 6)", "(3, 3)", "(8, 13)", "(6, 7)", "(5, 7)", "(4, 6)", "(1, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/108_prompt1a", "code_candidates": [{"code": "def count_nums(arr: List[int]) -> int:\n    def digit_sum(num: int) -> int:\n        return sum(int(d) for d in str(abs(num)))\n    \n    count = 0\n    for num in arr:\n        if num != 0 and digit_sum(num) > 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 5, 6, 7], "case_status": ["0", "2", "7", "6", "6", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/109_prompt1a", "code_candidates": [{"code": "def move_one_ball(arr):\n    \"\"\"\n    Determines if it is possible to get an array sorted in non-increasing or non-decreasing order\n    by performing right shift operations on the given array.\n    \n    Args:\n        arr (List[int]): The input array of unique integers.\n    \n    Returns:\n        bool: True if it is possible to sort the array by right shifts, False otherwise.\n    \"\"\"\n    if not arr:\n        return True\n    \n    n = len(arr)\n    sorted_arr = sorted(arr)\n    \n    # Check for non-decreasing order\n    for i in range(n):\n        if arr == sorted_arr[i:] + sorted_arr[:i]:\n            return True\n    \n    # Check for non-increasing order\n    sorted_arr_reverse = sorted(arr, reverse=True)\n    for i in range(n):\n        if arr == sorted_arr_reverse[i:] + sorted_arr_reverse[:i]:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/110_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef can_exchange_to_uniform(lst1: List[int], lst2: List[int]) -> str:\n    if len(lst1) != len(lst2):\n        return 'NO'\n    \n    def is_all_even(lst):\n        return all(x % 2 == 0 for x in lst)\n    \n    def is_all_odd(lst):\n        return all(x % 2 != 0 for x in lst)\n    \n    if is_all_even(lst1) or is_all_odd(lst1):\n        return 'YES'\n    \n    # Check if we can make lst1 all even\n    lst1_even = lst1.copy()\n    lst2_even = lst2.copy()\n    for i in range(len(lst1)):\n        if lst1_even[i] % 2 != 0:\n            for j in range(len(lst2_even)):\n                if lst2_even[j] % 2 == 0:\n                    lst1_even[i], lst2_even[j] = lst2_even[j], lst1_even[i]\n                    break\n    \n    if is_all_even(lst1_even):\n        return 'YES'\n    \n    # Check if we can make lst1 all odd\n    lst1_odd = lst1.copy()\n    lst2_odd = lst2.copy()\n    for i in range(len(lst1)):\n        if lst1_odd[i] % 2 == 0:\n            for j in range(len(lst2_odd)):\n                if lst2_odd[j] % 2 != 0:\n                    lst1_odd[i], lst2_odd[j] = lst2_odd[j], lst1_odd[i]\n                    break\n    \n    if is_all_odd(lst1_odd):\n        return 'YES'\n    \n    return 'NO'", "index": 0, "passed_case": [0, 2, 3, 6], "case_status": ["YES", "YES", "YES", "YES", "YES", "YES", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/111_prompt1a", "code_candidates": [{"code": "def histogram(test: str) -> dict:\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the least or most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    if not test:\n        return {}\n    \n    # Split the string into individual letters\n    letters = test.split()\n    \n    # Count the frequency of each letter\n    frequency = {}\n    for letter in letters:\n        if letter in frequency:\n            frequency[letter] += 1\n        else:\n            frequency[letter] = 1\n    \n    # Find the minimum and maximum counts\n    if not frequency:\n        return {}\n    \n    min_count = min(frequency.values())\n    max_count = max(frequency.values())\n    \n    # Create the result dictionary\n    result = {}\n    for letter, count in frequency.items():\n        if count == min_count or count == max_count:\n            result[letter] = count\n    \n    return result", "index": 0, "passed_case": [0, 2, 3, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2, 'c': 1}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4, 'a': 1}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/112_prompt1a", "code_candidates": [{"code": "def reverse_delete(s: str, c: str) -> tuple:\n    \"\"\"\n    Deletes all characters in s that are present in c and checks if the result string is a palindrome.\n    \n    Parameters:\n    s (str): The original string.\n    c (str): The string containing characters to be deleted from s.\n    \n    Returns:\n    tuple: A tuple containing the result string and a boolean indicating if it is a palindrome.\n    \"\"\"\n    # Create a set of characters to delete for O(1) lookup\n    chars_to_delete = set(c)\n    \n    # Filter out characters in s that are in chars_to_delete\n    result_string = ''.join([char for char in s if char not in chars_to_delete])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return (result_string, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/113_prompt1a", "code_candidates": [{"code": "def odd_count(lst: List[str]) -> List[int]:\n    result = []\n    for s in lst:\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(odd_digits)\n    return result", "index": 0, "passed_case": [], "case_status": ["[4]", "[1, 8]", "[2, 3, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/114_prompt1a", "code_candidates": [{"code": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n    if not nums:\n        return 0\n    \n    min_sum = current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/115_prompt1a", "code_candidates": [{"code": "import math\n\ndef max_fill(grid, capacity):\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 0 or 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output something to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    total_buckets = 0\n    \n    for row in grid:\n        water_units = sum(row)\n        if water_units > 0:\n            total_buckets += math.ceil(water_units / capacity)\n    \n    return total_buckets", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["6", "5", "0", "4", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/116_prompt1a", "code_candidates": [{"code": "def sort_array(arr):\n    def count_ones(num):\n        return bin(num).count('1')\n    \n    return sorted(arr, key=lambda x: (count_ones(x), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[1, 2, 4, 3, 5]", "[-4, -2, -6, -5, -3]", "[0, 1, 2, 4, 3]", "[]", "[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "[32, 3, 5, 6, 12, 44]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/117_prompt1a", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    if not s:\n        return []\n    \n    words = s.split()\n    result = []\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    for word in words:\n        consonant_count = len(set(char for char in word if char in consonants))\n        if consonant_count >= n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [1, 3, 4, 5, 6], "case_status": ["[]", "['Mary', 'lamb']", "['simple', 'white', 'space']", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/118_prompt1a", "code_candidates": [{"code": "def get_closest_vowel(word: str) -> str:\n    vowels = set(\"aeiou\")\n    for i in range(1, len(word) - 1):\n        if word[i] in vowels and word[i - 1] not in vowels and word[i + 1] not in vowels:\n            return word[i]\n    return \"\"", "index": 0, "passed_case": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["o", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/119_prompt1a", "code_candidates": [{"code": "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to process the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    # Check both possible orders\n    if is_balanced(lst[0] + lst[1]) or is_balanced(lst[1] + lst[0]):\n        return 'Yes'\n    else:\n        return 'No'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "Yes", "No", "No", "No", "Yes", "Yes"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/120_prompt1a", "code_candidates": [{"code": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the minimum or maximum k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Return the sorted list of length k with the maximum k numbers\n    return sorted_arr[-k:]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[4, 4]", "[2]", "[2, 20, 123]", "[0, 1, 2, 20]", "[-13, -8, 0, 0, 3, 5, 15]", "[3, 5]", "[5]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/121_prompt1a", "code_candidates": [{"code": "def sum_even_odd_elements(nums: list[int]) -> int:\n    total_sum = 0\n    for index, num in enumerate(nums):\n        if (num % 2 == 0 and index % 2 == 0) or (num % 2 != 0 and index % 2 != 0):\n            total_sum += num\n    return total_sum", "index": 0, "passed_case": [], "case_status": ["6", "388", "9", "10", "43", "24"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/122_prompt1a", "code_candidates": [{"code": "def add_elements(arr, k):\n    # Ensure k is within the bounds of the array\n    k = min(k, len(arr))\n    \n    # Initialize sum\n    total_sum = 0\n    \n    # Iterate over the first k elements\n    for i in range(k):\n        # Check if the element has at most two digits\n        if arr[i] < 100 and arr[i] > -100:\n            total_sum += arr[i]\n    \n    return total_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["-4", "0", "125", "24", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/123_prompt1a", "code_candidates": [{"code": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in the Collatz sequence.\n\n    The Collatz sequence is defined as follows: start with any positive integer n. Then each term is obtained from the previous term as follows:\n    - If the previous term is even, the next term is one half of the previous term.\n    - If the previous term is odd, the next term is 3 times the previous term plus 1.\n    The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [1, 5] # The Collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    odd_numbers = []\n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    odd_numbers.append(1)\n    return sorted(odd_numbers)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/124_prompt1a", "code_candidates": [{"code": "import re\n\ndef valid_date(date: str) -> bool:\n    \"\"\"Validates a given date string and returns True if the date is valid, otherwise False.\n    The date is valid if:\n    1. The date string is not empty.\n    2. The number of days is within the valid range for the given month.\n    3. The months are between 1 and 12.\n    4. The date is in the format: dd-mm-yyyy or mm-dd-yyyy.\n    5. Dates must include leading zeros for single-digit days and months.\n    6. Handle leap years correctly for February dates. A year is a leap year if it is divisible by 4, but not by 100 unless it is also divisible by 400.\n    \"\"\"\n    \n    if not date:\n        return False\n    \n    # Regular expression to match the date formats dd-mm-yyyy or mm-dd-yyyy\n    date_pattern = re.compile(r'^(\\d{2})-(\\d{2})-(\\d{4})$')\n    match = date_pattern.match(date)\n    \n    if not match:\n        return False\n    \n    day, month, year = map(int, match.groups())\n    \n    if month < 1 or month > 12:\n        return False\n    \n    # Define the number of days in each month\n    days_in_month = {\n        1: 31, 2: 29 if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0) else 28,\n        3: 31, 4: 30, 5: 31, 6: 30,\n        7: 31, 8: 31, 9: 30, 10: 31,\n        11: 30, 12: 31\n    }\n    \n    if day < 1 or day > days_in_month.get(month, 0):\n        return False\n    \n    return True", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "False", "True", "True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/125_prompt1a", "code_candidates": [{"code": "def process_string(s: str, chars: list = None) -> int:\n    if chars is not None:\n        return len(s.split(''.join(chars)))\n    elif ',' in s:\n        return len(s.split(','))\n    else:\n        odd_count = 0\n        for char in s:\n            if char.islower():\n                if (ord(char) - ord('a') + 1) % 2 != 0:\n                    odd_count += 1\n        if any(char.isupper() for char in s):\n            return odd_count\n        else:\n            return odd_count if odd_count > 0 else 0\n\n# Examples\nprint(process_string(\"apple,banana,cherry\"))  # Output: 3\nprint(process_string(\"apple-banana-cherry\", ['-']))  # Output: 3\nprint(process_string(\"apple-banana_cherry\", ['-', '_']))  # Output: 3\nprint(process_string(\"applebanana\"))  # Output: 5\nprint(process_string(\"APPLEBANANA\"))  # Output: 0\nprint(process_string(\"AppleBanana\"))  # Output: 5", "index": 0, "passed_case": [4, 7], "case_status": ["4", "2", "2", "3", "3", "3", "3", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/126_prompt1a", "code_candidates": [{"code": "def is_sorted(lst):\n    \"\"\"\n    Given a list of numbers, return whether or not they are sorted in ascending order.\n    If the list contains any duplicates, return False. Assume no negative numbers and only integers.\n    \"\"\"\n    if not lst:\n        return True  # An empty list is considered sorted\n    \n    for i in range(len(lst) - 1):\n        if lst[i] >= lst[i + 1]:\n            return False  # Not sorted or contains duplicates\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/127_prompt1a", "code_candidates": [{"code": "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    if start1 > end2 or start2 > end1:\n        return 'NO'\n    \n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    intersection_length = intersection_end - intersection_start\n    \n    if intersection_length <= 0:\n        return 'NO'\n    \n    if is_prime(intersection_length):\n        return 'YES'\n    else:\n        return 'NO'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["NO", "NO", "YES", "YES", "NO", "NO", "NO", "NO"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/128_prompt1a", "code_candidates": [{"code": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by result of certain signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n    if not arr:\n        return None\n    \n    total = 0\n    for num in arr:\n        if num > 0:\n            total += num * 1\n        elif num < 0:\n            total += abs(num) * -1\n        else:\n            total += 0\n    \n    return total", "index": 0, "passed_case": [3], "case_status": ["1", "1", "8", "None", "16", "0", "2", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/129_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef path(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    if N < 2:\n        raise ValueError(\"Grid must have at least 2 rows and 2 columns.\")\n    if k < 1:\n        raise ValueError(\"k must be a positive integer.\")\n\n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Find the position of the smallest element (1)\n    start_pos = None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                start_pos = (i, j)\n                break\n        if start_pos:\n            break\n\n    # Initialize the path with the smallest element\n    path_values = [1]\n    current_pos = start_pos\n\n    # Function to find the next smallest neighbor\n    def get_next_pos(current_pos):\n        min_val = float('inf')\n        next_pos = None\n        for d in directions:\n            ni, nj = current_pos[0] + d[0], current_pos[1] + d[1]\n            if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] > path_values[-1] and grid[ni][nj] < min_val:\n                min_val = grid[ni][nj]\n                next_pos = (ni, nj)\n        return next_pos\n\n    # Build the path\n    for _ in range(k - 1):\n        next_pos = get_next_pos(current_pos)\n        if next_pos:\n            path_values.append(grid[next_pos[0]][next_pos[1]])\n            current_pos = next_pos\n        else:\n            # If no valid next position, loop back to the smallest element\n            path_values.append(1)\n            current_pos = start_pos\n\n    return path_values\n\n# Example usage:\nif __name__ == \"__main__\":\n    grid1 = [ [1,2,3], [4,5,6], [7,8,9]]\n    k1 = 3\n    print(path(grid1, k1))  # Output: [1, 2, 1]\n\n    grid2 = [ [5,9,3], [4,1,6], [7,8,2]]\n    k2 = 1\n    print(path(grid2, k2))  # Output: [1]", "index": 0, "passed_case": [1, 10], "case_status": ["[1, 2, 3]", "[1]", "[1, 2, 3, 4]", "[1, 10, 13, 1, 10, 13, 1]", "[1, 7, 10, 11, 16]", "[1, 6, 15, 1, 6, 15, 1, 6, 15]", "[1, 6, 15, 1, 6, 15, 1, 6, 15, 1, 6, 15]", "[1, 3, 6, 8, 9, 1, 3, 6]", "[1, 5, 9, 1, 5, 9, 1, 5]", "[1, 2, 4, 1, 2, 4, 1, 2, 4, 1]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/130_prompt1a", "code_candidates": [{"code": "def tri(n):\n    if n < 0:\n        return []\n    \n    # Initial conditions\n    if n == 0:\n        return [0]\n    elif n == 1:\n        return [0, 1]\n    elif n == 2:\n        return [0, 1, 1]\n    \n    # Initialize the sequence with the first three numbers\n    sequence = [0, 1, 1]\n    \n    # Generate the sequence up to n\n    for i in range(3, n + 1):\n        next_number = sequence[i - 1] + sequence[i - 2] + sequence[i - 3]\n        sequence.append(next_number)\n    \n    return sequence", "index": 0, "passed_case": [], "case_status": ["[0, 1, 1, 2]", "[0, 1, 1, 2, 4]", "[0, 1, 1, 2, 4, 7]", "[0, 1, 1, 2, 4, 7, 13]", "[0, 1, 1, 2, 4, 7, 13, 24]", "[0, 1, 1, 2, 4, 7, 13, 24, 44]", "[0, 1, 1, 2, 4, 7, 13, 24, 44, 81]", "[0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012]", "[0]", "[0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/131_prompt1a", "code_candidates": [{"code": "def digits(n: int) -> int:\n    # Convert the number to a string to iterate over each digit\n    digits_str = str(n)\n    # Initialize the sum of odd digits\n    odd_sum = 0\n    # Iterate over each digit\n    for digit_char in digits_str:\n        digit = int(digit_char)\n        # Check if the digit is odd\n        if digit % 2 != 0:\n            odd_sum += digit\n    return odd_sum", "index": 0, "passed_case": [0, 1, 5], "case_status": ["5", "5", "6", "21", "25", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/132_prompt1a", "code_candidates": [{"code": "def has_nested_brackets(s: str) -> bool:\n    stack = []\n    nested = False\n\n    for char in s:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            if stack[-1] == '[':\n                stack.pop()\n                if len(stack) > 0:\n                    nested = True\n            else:\n                return False\n\n    return nested and not stack", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13], "case_status": ["True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/133_prompt1a", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    # Handle edge case: empty list\n    if not lst:\n        return 0\n    \n    # Round each element to the upper integer (ceiling) and square it\n    squared_sum = sum(math.ceil(num) ** 2 for num in lst)\n    \n    return squared_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/134_prompt1a", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(txt):\n    '''\n    Returns True if the last character of a given string is an alphabetical character and is not part of a word, and False otherwise.\n    Note: 'word' is a group of characters separated by space. Non-alphabetical characters other than spaces (e.g., punctuation marks) are considered as part of a word.\n    '''\n    if not txt:\n        return False\n    \n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    \n    # Check if the last character is not part of a word\n    if len(txt) == 1:\n        return True\n    \n    second_last_char = txt[-2]\n    if second_last_char == ' ':\n        return True\n    \n    return False\n\n# Examples\n# print(check_if_last_char_is_a_letter('apple pie'))  # \u279e False\n# print(check_if_last_char_is_a_letter('apple pi e'))  # \u279e True\n# print(check_if_last_char_is_a_letter('apple pi e '))  # \u279e False\n# print(check_if_last_char_is_a_letter(''))  # \u279e False\n# print(check_if_last_char_is_a_letter('apple!'))  # \u279e False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["False", "True", "False", "True", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/135_prompt1a", "code_candidates": [{"code": "def can_arrange(arr):\n    \"\"\"Create a function which returns the smallest or largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    if not arr:\n        return -1\n\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n\n    return -1", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["3", "-1", "2", "2", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/136_prompt1a", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef find_closest_to_zero(numbers: List[int]) -> Tuple[int, int]:\n    largest_negative = None\n    smallest_positive = None\n\n    for num in numbers:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return (largest_negative, smallest_positive)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/137_prompt1a", "code_candidates": [{"code": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing real numbers, and returns the smaller or larger variable in its given variable type. Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,. Convert all values to a common type (e.g., float) before comparison. If a string uses ',' as the decimal separator, replace it with '.' before conversion.\n    \"\"\"\n    def convert_to_float(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n        return float(value)\n    \n    try:\n        a_float = convert_to_float(a)\n        b_float = convert_to_float(b)\n    except (ValueError, TypeError):\n        return None\n    \n    if a_float > b_float:\n        return a\n    elif a_float < b_float:\n        return b\n    else:\n        return None", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["2", "2.5", "3", "6", "2,3", "6", "2", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/138_prompt1a", "code_candidates": [{"code": "def is_equal_to_sum_even(n):\n    if not isinstance(n, int) or n <= 0:\n        return False\n    \n    # Any even number can be expressed as 2 * k for some integer k\n    # The sum of 4 even numbers is 4 * (2 * k) = 8 * k\n    # Therefore, n must be divisible by 8\n    return n % 8 == 0\n\n# Example usage:\n# print(is_equal_to_sum_even(8))  # True\n# print(is_equal_to_sum_even(10)) # False\n# print(is_equal_to_sum_even(-4)) # False\n# print(is_equal_to_sum_even(16)) # True", "index": 0, "passed_case": [0, 1, 2, 4, 6, 7], "case_status": ["False", "False", "True", "False", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/139_prompt1a", "code_candidates": [{"code": "import math\n\ndef special_factorial(n):\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= math.factorial(i)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/140_prompt1a", "code_candidates": [{"code": "import re\n\ndef replace_spaces(text: str) -> str:\n    if not text:\n        return text\n    \n    # Replace all sequences of two or more spaces with a single '-'\n    text = re.sub(r' {2,}', '-', text)\n    \n    # Replace all single spaces with '_'\n    text = text.replace(' ', '_')\n    \n    return text", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["Example", "Mudasir_Hanif_", "Yellow_Yellow-Dirty-Fellow", "Exa-mple", "-Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/141_prompt1a", "code_candidates": [{"code": "import re\n\ndef file_name_check(file_name: str) -> str:\n    # Check for exactly three digits\n    if len(re.findall(r'\\d', file_name)) == 3:\n        return 'No'\n    \n    # Check for exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into parts\n    name_part, extension_part = file_name.split('.')\n    \n    # Check if the name part is not empty and starts with a letter\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    \n    # Check if the extension part is valid\n    valid_extensions = ['txt', 'exe', 'dll']\n    if extension_part not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25], "case_status": ["Yes", "No", "No", "Yes", "No", "Yes", "No", "No", "No", "No", "Yes", "No", "No", "No", "No", "No", "No", "Yes", "Yes", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/142_prompt1a", "code_candidates": [{"code": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = [] the output should be 0\n    For lst = [-1,-5,2,-1,-5] the output should be -126\n    \"\"\"\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            lst[i] = num ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = num ** 3\n    \n    return sum(lst)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["6", "14", "0", "9", "-3", "0", "-126", "3030", "0", "-14196", "-1448"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/143_prompt1a", "code_candidates": [{"code": "def words_in_sentence(sentence: str) -> str:\n    \"\"\"\n    Returns a string containing words from the original sentence whose lengths are certain numbers,\n    maintaining the original order.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n    \"\"\"\n    # Define the lengths of words to include\n    valid_lengths = {2, 3}\n    \n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words based on their lengths\n    filtered_words = [word for word in words if len(word) in valid_lengths]\n    \n    # Join the filtered words into a single string\n    return ' '.join(filtered_words)", "index": 0, "passed_case": [0, 1, 4, 5, 6], "case_status": ["is", "go for", "is no", "Hi am", "go for it", "", "is"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/144_prompt1a", "code_candidates": [{"code": "from fractions import Fraction\n\ndef simplify(a: str, b: str) -> bool:\n    # Parse the fractions from the input strings\n    fraction_a = Fraction(a)\n    fraction_b = Fraction(b)\n    \n    # Calculate the product of the two fractions\n    product = fraction_a * fraction_b\n    \n    # Check if the product is a whole number\n    return product.denominator == 1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/145_prompt1a", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Sorts the given list of integers in ascending order according to the sum of their digits.\n    If there are several items with similar sum of their digits, order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/146_prompt1a", "code_candidates": [{"code": "def specialFilter(nums):\n    \"\"\"\n    Returns the number of elements in the array that are less than, greater than, or exactly 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9) or even (0, 2, 4, 6, 8).\n    Handle negative numbers by considering their absolute value for digit determination.\n    Single-digit numbers should be considered valid if they meet the digit criteria.\n    Numbers ending with zero should be considered valid if the first digit meets the criteria.\n    \"\"\"\n    def is_valid_digit(digit):\n        return digit in {1, 3, 5, 7, 9} or digit in {0, 2, 4, 6, 8}\n\n    count = 0\n    for num in nums:\n        # Handle negative numbers by considering their absolute value\n        abs_num = abs(num)\n        \n        # Check if the number is less than, greater than, or exactly 10\n        if abs_num < 10 or abs_num > 10:\n            # Convert the number to a string to easily access digits\n            num_str = str(abs_num)\n            \n            # Handle single-digit numbers\n            if len(num_str) == 1:\n                if is_valid_digit(int(num_str)):\n                    count += 1\n            else:\n                # Get the first and last digits\n                first_digit = int(num_str[0])\n                last_digit = int(num_str[-1])\n                \n                # Check if both first and last digits are valid\n                if is_valid_digit(first_digit) and is_valid_digit(last_digit):\n                    count += 1\n\n    return count", "index": 0, "passed_case": [6], "case_status": ["4", "4", "6", "6", "6", "1", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/147_prompt1a", "code_candidates": [{"code": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i + i - 1 or a[i] = i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n    if n < 3:\n        return 0\n\n    a = []\n    for i in range(1, n + 1):\n        a_i = i * i + i - 1\n        a.append(a_i)\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n\n    return count", "index": 0, "passed_case": [0, 1], "case_status": ["1", "4", "24", "51744"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/148_prompt1a", "code_candidates": [{"code": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closest to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    The function should return a tuple containing only one or all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by \n    the proximity to the sun. \n    The function should return an empty tuple if planet1 or planet2\n    are not correct planet names. \n    Examples\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n    \n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are valid\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    # Get the indices of the two planets\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    # Ensure index1 is less than index2\n    if index1 > index2:\n        index1, index2 = index2, index1\n    \n    # Get the planets between index1 and index2 (exclusive)\n    between_planets = planets[index1 + 1:index2]\n    \n    return tuple(between_planets)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["('Saturn', 'Uranus')", "('Venus',)", "('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')", "('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')", "()", "()", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/149_prompt1a", "code_candidates": [{"code": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes the strings that have odd lengths,\n    and returns the resulted list sorted in descending order by length of each word,\n    and if two words have the same length, sort the list alphabetically ascending.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by descending length, then alphabetically ascending\n    sorted_lst = sorted(filtered_lst, key=lambda x: (-len(x), x))\n    \n    return sorted_lst", "index": 0, "passed_case": [0, 2, 3, 4, 5], "case_status": ["['aa']", "['school', 'asdf', 'AI']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['aaaa', 'bbbb', 'cc', 'dd']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/150_prompt1a", "code_candidates": [{"code": "def x_or_y(a, b, c):\n    \"\"\"A simple program which should return the value of x if n is \n    a certain type of number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n    # Determine if 'a' is a certain type of number (e.g., odd or even)\n    # For simplicity, let's assume 'a' being odd means return 'b', otherwise return 'c'\n    if a % 2 != 0:\n        return b\n    else:\n        return c", "index": 0, "passed_case": [0, 2, 3, 4, 7], "case_status": ["34", "8", "33", "3", "-1", "1245", "56", "1234", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/151_prompt1a", "code_candidates": [{"code": "def double_the_difference(lst):\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate through each number in the list\n    for num in lst:\n        # Check if the number is an odd integer and non-negative\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            # Add the square of the number to the total\n            total += num ** 2\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "25", "0", "0", "0", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/152_prompt1a", "code_candidates": [{"code": "def compare(game, guess):\n    \"\"\"Compare two arrays of scores and guesses of equal length.\n    Return an array of the same length denoting how far off each guess was.\n    If the guess is correct, the value should be 0.\n    If not, the value should be the absolute difference between the guess and the score.\n    \"\"\"\n    # Check if the input lists are of equal length\n    if len(game) != len(guess):\n        raise ValueError(\"The game and guess lists must be of equal length.\")\n    \n    # Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate through the scores and guesses\n    for score, guess_val in zip(game, guess):\n        if score == guess_val:\n            differences.append(0)\n        else:\n            differences.append(abs(score - guess_val))\n    \n    return differences", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/153_prompt1a", "code_candidates": [{"code": "def Extension(class_name, extensions):\n    def calculate_strength(extension):\n        uppercase_count = sum(1 for char in extension if char.isupper())\n        lowercase_count = sum(1 for char in extension if char.islower())\n        return uppercase_count + lowercase_count\n\n    if not extensions:\n        return f\"{class_name}: \"\n\n    strongest_extension = max(extensions, key=calculate_strength)\n    return f\"{class_name}: {strongest_extension}\"", "index": 0, "passed_case": [], "case_status": ["Watashi: eIGHt8OKe", "Boku123: YEs.WeCaNe", "__YESIMHERE: nothing", "K: cosSo", "__HAHA: Tab", "YameRore: okIWILL123", "finNNalLLly: NowW", "_: Bb", "Sp: Bb"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/154_prompt1a", "code_candidates": [{"code": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    Returns True if the second word or any of its rotations is a substring of the first word.\n    \"\"\"\n    if not a or not b:\n        return False\n    \n    # Create all rotations of b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation of b is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/155_prompt1a", "code_candidates": [{"code": "def even_odd_count(number: int) -> tuple:\n    # Convert the number to its absolute value to ignore the negative sign\n    num_str = str(abs(number))\n    even_count = 0\n    odd_count = 0\n\n    for digit_char in num_str:\n        digit = int(digit_char)\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(1, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/156_prompt1a", "code_candidates": [{"code": "def int_to_mini_roman(number: int) -> str:\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000 inclusive.\")\n    \n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    \n    roman_num = \"\"\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syms[i]\n            number -= val[i]\n        i += 1\n    return roman_num", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/157_prompt1a", "code_candidates": [{"code": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # Handle edge cases where any side is zero or negative\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    \n    # Sort the sides to easily identify the hypotenuse\n    sides = sorted([a, b, c])\n    \n    # Apply the Pythagorean theorem\n    return sides[0]**2 + sides[1]**2 == sides[2]**2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/158_prompt1a", "code_candidates": [{"code": "def find_max(words):\n    \"\"\"\n    Finds the word with the maximum number of unique characters from a list of strings.\n    If multiple words have the same number of unique characters, returns the one that comes first in lexicographical order.\n\n    :param words: List of strings\n    :return: String with the maximum number of unique characters\n    \"\"\"\n    if not words:\n        return None\n\n    def unique_char_count(word):\n        return len(set(word))\n\n    max_unique = -1\n    result = None\n\n    for word in words:\n        if not isinstance(word, str):\n            continue\n        current_unique = unique_char_count(word)\n        if current_unique > max_unique or (current_unique == max_unique and (result is None or word < result)):\n            max_unique = current_unique\n            result = word\n\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "enam", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/159_prompt1a", "code_candidates": [{"code": "def eat(x, y, z):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat no or more carrots to complete the day's meals.\n    you should return an array of [ total number of needed or eaten carrots before or after your meals,\n                                    the number of carrots needed or eaten left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    # Calculate the total number of carrots needed or eaten before the meals\n    total_before = x + y\n    \n    # Determine how many carrots are left after eating the remaining carrots\n    if z >= y:\n        # If there are enough carrots, eat the needed amount\n        carrots_left = z - y\n    else:\n        # If there are not enough carrots, eat all remaining and still be hungry\n        carrots_left = 0\n    \n    # Return the result as a list\n    return [total_before, carrots_left]", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["[11, 4]", "[12, 1]", "[11, 0]", "[13, 0]", "[9, 2]", "[9, 0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/160_prompt1a", "code_candidates": [{"code": "def do_algebra(list1, list2):\n    # Ensure the length of the operator list is one less than the operand list\n    if len(list2) != len(list1) - 1:\n        raise ValueError(\"The length of the operator list must be one less than the operand list.\")\n    \n    # Initialize the result with the first operand\n    result = list1[0]\n    \n    # Iterate through the operator list and apply the operations\n    for i in range(len(list2)):\n        operator = list2[i]\n        operand = list1[i + 1]\n        \n        if operator == '+':\n            result += operand\n        elif operator == '-':\n            result -= operand\n        elif operator == '*':\n            result *= operand\n        elif operator == '//':\n            if operand == 0:\n                raise ValueError(\"Cannot perform floor division by zero.\")\n            result //= operand\n        elif operator == '**':\n            result **= operand\n        else:\n            raise ValueError(f\"Unsupported operator: {operator}\")\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/161_prompt1a", "code_candidates": [{"code": "def solve(s: str) -> str:\n    # Initialize an empty list to store the transformed characters\n    transformed_chars = []\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is an uppercase letter\n        if char.isupper():\n            # Append the lowercase version of the character\n            transformed_chars.append(char.lower())\n        # Check if the character is a lowercase letter\n        elif char.islower():\n            # Append the uppercase version of the character\n            transformed_chars.append(char.upper())\n        else:\n            # Append the character as is if it's not a letter\n            transformed_chars.append(char)\n    \n    # Join the list of characters into a string and return it\n    return ''.join(transformed_chars)", "index": 0, "passed_case": [0, 2, 3, 4, 6, 7], "case_status": ["aSdF", "1234", "AB", "#A@c", "#aSDFw^45", "#6@2", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/162_prompt1a", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its ideal hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/163_prompt1a", "code_candidates": [{"code": "def generate_integers(a, b):\n    # Determine the range boundaries\n    start = min(a, b)\n    end = max(a, b)\n    \n    # List to store even digits\n    even_digits = []\n    \n    # Iterate through the range and collect even digits\n    for num in range(start, end + 1):\n        digits = [int(d) for d in str(num)]\n        for digit in digits:\n            if digit % 2 == 0:\n                even_digits.append(digit)\n    \n    # Remove duplicates and sort the list\n    even_digits = sorted(set(even_digits))\n    \n    return even_digits", "index": 0, "passed_case": [], "case_status": ["[0, 2, 4, 6, 8]", "[0, 2, 4, 6, 8]", "[0, 2, 4, 6, 8]", "[0, 2, 4, 6, 8]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/0_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\"Check if in the given list of numbers, any two numbers are within the given threshold distance of each other.\"\"\"\n    if not numbers:\n        return False\n    \n    for i, num1 in enumerate(numbers):\n        for num2 in numbers[i+1:]:\n            if abs(num1 - num2) <= threshold:\n                return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/1_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those groups into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other.\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string.replace(' ', ''):\n        current_group.append(char)\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/2_prompt1c", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    >>> truncate_number(5.75)\n    0.75\n    >>> truncate_number(0.25)\n    0.25\n    \"\"\"\n    return number - int(number)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0.5", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/3_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/4_prompt1c", "code_candidates": [{"code": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.5\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean_value) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/5_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers`.\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimeter)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[5, 8, 6, 8, 3, 8, 2]", "[2, 2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/6_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (() ()) has maximum two levels of nesting while ((( ))) has three.\n\n    >>> parse_nested_parens('(()())((()))()((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    max_depths = []\n    \n    for group in groups:\n        current_depth = 0\n        max_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        max_depths.append(max_depth)\n    \n    return max_depths", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/7_prompt1c", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/8_prompt1c", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    total_sum = sum(numbers) if numbers else 0\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    return (total_sum, total_product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/9_prompt1c", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_list = []\n    current_max = numbers[0]\n    \n    for number in numbers:\n        if number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    \n    return max_list", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/10_prompt1c", "code_candidates": [{"code": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return string\n    \n    # Function to check if a substring is a palindrome\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # Append the reverse of the prefix to the end\n            return string + string[:i][::-1]\n    \n    # If no palindromic suffix is found, append the reverse of the entire string\n    return string + string[:-1][::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "x", "xyzyx", "xyx", "jerryrrej"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/11_prompt1c", "code_candidates": [{"code": "def string_xor(a: str, b: str) -> str:\n    # Determine the maximum length\n    max_len = max(len(a), len(b))\n    \n    # Pad the shorter string with '0's\n    a = a.zfill(max_len)\n    b = b.zfill(max_len)\n    \n    # Perform the XOR operation\n    result = ''.join('0' if bit_a == bit_b else '1' for bit_a, bit_b in zip(a, b))\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/12_prompt1c", "code_candidates": [{"code": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n    None\n    >>> longest(['a', 'b', 'c'])\n    'c'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    return max(strings, key=len)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/13_prompt1c", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/14_prompt1c", "code_candidates": [{"code": "def get_all_prefixes(s: str) -> List[str]:\n    \"\"\"\n    Returns all prefixes of the input string, ordered from shortest to longest.\n\n    :param s: The input string\n    :return: A list of all prefixes of the input string\n    \"\"\"\n    return [s[:i] for i in range(1, len(s) + 1)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/15_prompt1c", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "0 1 2 3", "0 1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/16_prompt1c", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of.\n    Case should be ignored when determining distinct characters.\n    >>> count_distinct_characters('xyzXYZ') -> 3\n    >>> count_distinct_characters('Jerry') -> 5\n    >>> count_distinct_characters('XxYyZz') -> 3\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    # Return the number of distinct characters\n    return len(distinct_chars)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/17_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    note last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quarter note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    note_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    notes = music_string.split()\n    beats = [note_beats.get(note, 0) for note in notes]\n    \n    return beats", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[]", "[4, 4, 4, 4]", "[1, 1, 1, 1]", "[2, 2, 1, 1, 4, 4, 4, 4]", "[2, 1, 2, 1, 4, 2, 4, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/18_prompt1c", "code_candidates": [{"code": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    2\n    \"\"\"\n    if not substring:\n        return 0\n\n    count = 0\n    sub_len = len(substring)\n    str_len = len(string)\n    \n    for i in range(str_len - sub_len + 1):\n        if string[i:i + sub_len] == substring:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/19_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    num_order = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n    words = numbers.split()\n    sorted_words = sorted(words, key=lambda x: num_order.index(x))\n    return ' '.join(sorted_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "three", "three five nine", "zero four five seven eight nine", "zero one two three four five six"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/20_prompt1c", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef find_closest_numbers(nums: List[int]) -> Tuple[int, int]:\n    if not nums:\n        return (None, None)\n    \n    nums_sorted = sorted(nums)\n    min_diff = float('inf')\n    closest_pair = (nums_sorted[0], nums_sorted[0])\n    \n    for i in range(1, len(nums_sorted)):\n        diff = nums_sorted[i] - nums_sorted[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (nums_sorted[i - 1], nums_sorted[i])\n            if min_diff == 0:\n                break\n    \n    return closest_pair", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/21_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given a list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        raise ValueError(\"All elements in the list must be distinct to perform rescaling.\")\n    \n    rescaled = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return rescaled", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/22_prompt1c", "code_candidates": [{"code": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/23_prompt1c", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return the length of the given string.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/24_prompt1c", "code_candidates": [{"code": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n.\n    If n is 1, return None as there are no divisors smaller than 1.\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(1)\n    None\n    \"\"\"\n    if n == 1:\n        return None\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return None", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/25_prompt1c", "code_candidates": [{"code": "def factorize(n: int) -> list:\n    if n <= 0:\n        return []\n    \n    factors = []\n    divisor = 2\n    \n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/26_prompt1c", "code_candidates": [{"code": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 2, 3, 4]\n    \"\"\"\n    seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "[1, 2, 3, 4]", "[1, 2, 3, 4, 5]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/27_prompt1c", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    >>> flip_case('World')\n    'wORLD'\n    >>> flip_case('123')\n    '123'\n    >>> flip_case('')\n    ''\n    \"\"\"\n    return ''.join(char.lower() if char.isupper() else char.upper() if char.islower() else char for char in string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/28_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef concatenate_strings(strings: List[str], reverse: bool, include_spaces: bool) -> str:\n    if reverse:\n        strings = strings[::-1]\n    \n    if include_spaces:\n        return ' '.join(strings)\n    else:\n        return ''.join(strings)", "index": 0, "passed_case": [0], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/29_prompt1c", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/30_prompt1c", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [x for x in l if x > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/31_prompt1c", "code_candidates": [{"code": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/32_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef find_zero(xs: List[float]) -> float:\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list 'xs' must have an even number of elements.\")\n    \n    max_coeff = max(xs, key=abs)\n    if max_coeff == 0:\n        raise ValueError(\"The largest non-zero coefficient must be present.\")\n    \n    # Placeholder logic for finding a zero point of the polynomial\n    # This is a simplified example and should be replaced with actual polynomial solving logic\n    zero_point = -xs[0] / xs[1] if xs[1] != 0 else 0.0\n    \n    return zero_point", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/33_prompt1c", "code_candidates": [{"code": "def sort_third(l: list) -> list:\n    if not l:\n        return l\n    \n    # Extract elements at indices divisible by 3\n    divisible_by_three = l[i] for i in range(0, len(l), 3)]\n    # Sort these elements\n    sorted_divisible_by_three = sorted(divisible_by_three)\n    \n    # Create a new list with sorted elements at indices divisible by 3\n    result = l.copy()\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = sorted_divisible_by_three[sorted_index]\n            sorted_index += 1\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/34_prompt1c", "code_candidates": [{"code": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list.\n    If the list is empty, return an empty list.\n    If the list contains non-comparable elements, raise a TypeError.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    >>> unique([])\n    []\n    >>> unique([1, 'a', 2])\n    raise TypeError\n    \"\"\"\n    if not l:\n        return []\n    \n    try:\n        return sorted(set(l))\n    except TypeError:\n        raise TypeError(\"The list contains non-comparable elements.\")", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/35_prompt1c", "code_candidates": [{"code": "def max_element(l: list):\n    \"\"\"Return the maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        raise ValueError(\"The list is empty\")\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/36_prompt1c", "code_candidates": [{"code": "def fizz_buzz(n: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    2\n    >>> fizz_buzz(78)\n    4\n    >>> fizz_buzz(79)\n    4\n    \"\"\"\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "2", "3", "3", "6", "192", "639", "8026"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/37_prompt1c", "code_candidates": [{"code": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [3, 2, 1]\n    >>> sort_even([5, 6, 3, 4])\n    [6, 5, 4, 3]\n    \"\"\"\n    if not l:\n        return l\n    \n    # Extract even-indexed elements and sort them\n    even_elements = sorted([l[i] for i in range(0, len(l), 2)], reverse=True)\n    \n    # Reconstruct the list with sorted even-indexed elements\n    result = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements.pop(0))\n        else:\n            result.append(l[i])\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[3, 2, 1]", "[123, 3, 9, 2, 5, 3, -3, 0, -5, 1, -10]", "[23, 8, 12, 4, 5, 2, 3, 11, -12, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/38_prompt1c", "code_candidates": [{"code": "def encode_cyclic(s: str) -> str:\n    if not s:\n        return s\n    encoded_chars = []\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            group = group[1:] + group[0]\n        encoded_chars.append(group)\n    return ''.join(encoded_chars)\n\ndef decode_cyclic(s: str) -> str:\n    if not s:\n        return s\n    decoded_chars = []\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            group = group[2] + group[:2]\n        decoded_chars.append(group)\n    return ''.join(decoded_chars)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/39_prompt1c", "code_candidates": [{"code": "from typing import List\nimport math\n\ndef is_prime(num: int) -> bool:\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    fib_sequence = [0, 1]\n    count = 0\n    index = 2\n    \n    while True:\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        fib_sequence.append(next_fib)\n        \n        if is_prime(next_fib):\n            count += 1\n            if count == n:\n                return next_fib\n        \n        index += 1\n\n# Example usage:\n# print(prime_fib(1))  # Output: 2\n# print(prime_fib(2))  # Output: 3\n# print(prime_fib(3))  # Output: 5\n# print(prime_fib(4))  # Output: 13\n# print(prime_fib(5))  # Output: 89", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "433494437"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/40_prompt1c", "code_candidates": [{"code": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    It returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    False\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    # Handle edge cases\n    if len(l) < 3:\n        return False\n\n    # Sort the list to use two-pointer technique\n    l.sort()\n\n    # Iterate through the list to find triplets\n    for i in range(len(l) - 2):\n        # Skip duplicates\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        left = i + 1\n        right = len(l) - 1\n\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/41_prompt1c", "code_candidates": [{"code": "def calculate_collisions(n: int) -> int:\n    \"\"\"\n    This function calculates the number of collisions between two sets of n cars moving in opposite directions on an infinitely long straight road.\n    If n is 0 or negative, the function should return 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/42_prompt1c", "code_candidates": [{"code": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/43_prompt1c", "code_candidates": [{"code": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    False\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/44_prompt1c", "code_candidates": [{"code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return '0'\n    \n    if base < 2:\n        raise ValueError(\"Base must be at least 2\")\n    \n    result = []\n    while x > 0:\n        remainder = x % base\n        result.append(str(remainder))\n        x = x // base\n    \n    return ''.join(reversed(result))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/45_prompt1c", "code_candidates": [{"code": "def triangle_area(a: float, h: float) -> float: \n    return (a * h) / 2", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/46_prompt1c", "code_candidates": [{"code": "def fib4(n: int) -> int:\n    \"\"\"\n    Compute the n-th element of the Fib4 number sequence efficiently without recursion.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    \n    # Initialize the first four elements\n    fib_sequence = [0, 0, 2, 0]\n    \n    # Compute the sequence iteratively\n    for i in range(4, n + 1):\n        next_value = fib_sequence[i - 1] + fib_sequence[i - 2] + fib_sequence[i - 3] + fib_sequence[i - 4]\n        fib_sequence.append(next_value)\n    \n    return fib_sequence[n]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["4", "28", "104", "386"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/47_prompt1c", "code_candidates": [{"code": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    If the list has an odd number of elements, return the middle element.\n    If the list has an even number of elements, return the average of the two middle elements.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    8\n    \"\"\"\n    if not l:\n        return None  # Handle empty list case\n    \n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    \n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "8.0", "5", "5.5", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/48_prompt1c", "code_candidates": [{"code": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if given string is a palindrome.\n    An empty string is considered a palindrome.\n    \n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/49_prompt1c", "code_candidates": [{"code": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    20\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    if n < 0 or p <= 0:\n        raise ValueError(\"Both n must be non-negative and p must be positive.\")\n    \n    result = 1\n    power = 2\n    while n > 0:\n        if n % 2 == 1:\n            result = (result * power) % p\n        power = (power * power) % p\n        n //= 2\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/50_prompt1c", "code_candidates": [{"code": "def decode_shift(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with the encode_shift function, which shifts every character by 5. Returns the decoded string by shifting every character back by 5.\n    \"\"\"\n    decoded_chars = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            decoded_char = chr(((ord(char) - ord('a') - 5) % 26) + ord('a'))\n            decoded_chars.append(decoded_char)\n        elif 'A' <= char <= 'Z':\n            decoded_char = chr(((ord(char) - ord('A') - 5) % 26) + ord('A'))\n            decoded_chars.append(decoded_char)\n        else:\n            decoded_chars.append(char)\n    return ''.join(decoded_chars)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/51_prompt1c", "code_candidates": [{"code": "def remove_vowels(text: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/52_prompt1c", "code_candidates": [{"code": "def below_threshold(l: list, t: int) -> bool:\n    if not l:\n        return True  # An empty list has no elements above the threshold\n    return all(x < t for x in l)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/53_prompt1c", "code_candidates": [{"code": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/54_prompt1c", "code_candidates": [{"code": "def same_chars(s0: str, s1: str) -> bool:\n    if not s0:\n        return True\n    if not s1:\n        return False\n    return all(char in s1 for char in s0)", "index": 0, "passed_case": [0, 1, 2, 3, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/55_prompt1c", "code_candidates": [{"code": "def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\n    The Fibonacci sequence is defined as:\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) for n > 1\n\n    >>> fib(0)\n    0\n    >>> fib(1)\n    1\n    >>> fib(10)\n    55\n    >>> fib(8)\n    21\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/56_prompt1c", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    count = 0\n    for bracket in brackets:\n        if bracket == '<':\n            count += 1\n        elif bracket == '>':\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/57_prompt1c", "code_candidates": [{"code": "def monotonic(l: list):\n    \"\"\"Return True if list elements are strictly monotonically increasing or strictly monotonically decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if not l:\n        return True\n    \n    increasing = all(l[i] < l[i+1] for i in range(len(l)-1))\n    decreasing = all(l[i] > l[i+1] for i in range(len(l)-1))\n    \n    return increasing or decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 5, 6], "case_status": ["True", "True", "False", "True", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/58_prompt1c", "code_candidates": [{"code": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [653, 5, 1]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [3, 2]\n\n    \"\"\"\n    # Convert both lists to sets to find common elements\n    set1 = set(l1)\n    set2 = set(l2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the result back to a sorted list\n    return sorted(list(common_elements), reverse=True)", "index": 0, "passed_case": [3], "case_status": ["[653, 5, 1]", "[3, 2]", "[4, 3, 2]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/59_prompt1c", "code_candidates": [{"code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    # Check for factors from 2 up to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            # Check the corresponding factor n // i\n            if is_prime(n // i):\n                largest_factor = n // i\n                break\n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/60_prompt1c", "code_candidates": [{"code": "def sum_to_n(n: int) -> int:\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/61_prompt1c", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    True\n    >>> correct_bracketing(\"()\")\n    False\n    >>> correct_bracketing(\"(()())\")\n    False\n    >>> correct_bracketing(\")(()\")\n    True\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == '(':\n            balance += 1\n        elif bracket == ')':\n            balance -= 1\n        if balance < 0:\n            return True\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7, 9], "case_status": ["True", "True", "True", "True", "True", "True", "False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/62_prompt1c", "code_candidates": [{"code": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [20, 12, 4, 1]\n    >>> derivative([1, 2, 3])\n    [6, 2]\n    \"\"\"\n    if not xs:\n        return []\n    \n    # The derivative of the constant term (xs[0]) is 0, so we skip it.\n    # For each subsequent term, the derivative is xs[i] * i.\n    return [xs[i] * i for i in range(1, len(xs))]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/63_prompt1c", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    \"\"\"\n    The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    This function efficiently computes the n-th element of the fibfib number sequence.\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize the first three FibFib numbers\n    a, b, c = 0, 0, 1\n    \n    # Compute FibFib numbers iteratively from the 3rd to the nth\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    \n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/64_prompt1c", "code_candidates": [{"code": "def vowels_count(s: str) -> int:\n    \"\"\"\n    Count the number of vowels in the given string.\n    Vowels are 'a', 'e', 'i', 'o', 'u' (case-insensitive).\n    'y' is considered a vowel only if it is at the end of the word.\n\n    :param s: The input string.\n    :return: The number of vowels in the string.\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    # Check if 'y' or 'Y' is at the end of the word\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/65_prompt1c", "code_candidates": [{"code": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    If shift is negative, shift the digits left by the absolute value of shift.\n    If x is a single-digit number, return x as a string.\n    >>> circular_shift(12, 1)\n    '21'\n    >>> circular_shift(12, 2)\n    '21'\n    \"\"\"\n    x_str = str(x)\n    length = len(x_str)\n    \n    if length == 1:\n        return x_str\n    \n    if shift < 0:\n        shift = abs(shift)\n        shift = shift % length\n        shifted_str = x_str[shift:] + x_str[:shift]\n    else:\n        shift = shift % length\n        if shift == 0:\n            shifted_str = x_str\n        else:\n            shifted_str = x_str[-shift:] + x_str[:-shift]\n    \n    if shift >= length:\n        shifted_str = x_str[::-1]\n    \n    return shifted_str", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["001", "12", "97", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/66_prompt1c", "code_candidates": [{"code": "def upperCharSum(s: str) -> int:\n    \"\"\"\n    Task\n    Write a function that takes a string as input and returns the sum of the ASCII codes of the uppercase characters only.\n    \"\"\"\n    return sum(ord(char) for char in s if char.isupper())", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "131", "67", "69", "131", "153", "151", "327"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/67_prompt1c", "code_candidates": [{"code": "def fruit_distribution(s: str, n: int) -> int:\n    \"\"\"\n    Given a string that represents the number of apples and oranges,\n    and an integer that represents the total number of fruits in the basket,\n    return the number of mango fruits in the basket.\n    \"\"\"\n    # Split the string to extract the number of apples and oranges\n    parts = s.split()\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/68_prompt1c", "code_candidates": [{"code": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes, your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found, return the node that has the smallest index.\n    The plucked node should be returned in a list, [smallest_value, its index].\n    If there are no even values or the given array is empty, return [].\n    \"\"\"\n    if not arr:\n        return []\n    \n    even_nodes = [(value, index) for index, value in enumerate(arr) if value % 2 == 0]\n    \n    if not even_nodes:\n        return []\n    \n    smallest_even_node = min(even_nodes, key=lambda x: (x[0], x[1]))\n    \n    return [smallest_even_node[0], smallest_even_node[1]]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2, 1]", "[2, 1]", "[]", "[0, 1]", "[0, 3]", "[4, 1]", "[6, 1]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/69_prompt1c", "code_candidates": [{"code": "from collections import Counter\n\ndef search(lst):\n    if not lst:\n        return -1\n    \n    count = Counter(lst)\n    max_num = -1\n    \n    for num, freq in count.items():\n        if freq >= num and num > max_num:\n            max_num = num\n    \n    return max_num", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "case_status": ["1", "4", "-1", "8", "2", "1", "2", "1", "-1", "1", "1", "5", "1", "4", "2", "1", "4", "4", "2", "-1", "-1", "2", "1", "1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/70_prompt1c", "code_candidates": [{"code": "def strange_sort_list(lst):\n    '''\n    Given a list of integers, return the list sorted in a strange order.\n    The strange order is defined as starting with the minimum value, then the maximum of the remaining integers, then the next minimum, and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left, right = 0, len(sorted_lst) - 1\n    \n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/71_prompt1c", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    \n    # Calculate the semi-perimeter\n    s = (a + b + c) / 2\n    \n    # Calculate the area using Heron's formula\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    # Return the area rounded to 2 decimal points\n    return round(area, 2)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["6.0", "-1", "8.18", "1.73", "-1", "16.25", "-1", "0.43", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/72_prompt1c", "code_candidates": [{"code": "def will_it_fly(q, w):\n    '''\n    Returns True if the object q is a palindromic list and the sum of its elements is less than or equal to the maximum possible weight w. Otherwise, returns False.\n    '''\n    # Check if q is a list\n    if not isinstance(q, list):\n        return False\n    \n    # Check if q is a palindrome\n    if q != q[::-1]:\n        return False\n    \n    # Calculate the sum of elements in q\n    total_sum = sum(q)\n    \n    # Check if the sum is less than or equal to w\n    if total_sum > w:\n        return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/73_prompt1c", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that need to be changed\n    to make the array palindromic. A palindromic array is an array that is read the same backwards\n    and forwards. In one change, you can change one element to any other element.\n\n    :param arr: List of integers\n    :return: Minimum number of changes needed to make the array palindromic\n    \"\"\"\n    if not arr:\n        return 0  # An empty array is trivially a palindrome\n\n    changes = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n\n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/74_prompt1c", "code_candidates": [{"code": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    the total number of characters in all strings of the list less than the other list.\n\n    If the two lists have the same number of characters, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'hi', 'admin', 'project']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hi', 'admin']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['1', '2', '3', '4', '5']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[]", "['hi', 'hi']", "['hi', 'admin']", "['4']", "['hI', 'Hi']", "['hI', 'hi', 'hi']", "['hi', 'admin']", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/75_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef get_prime_factors(n: int) -> List[int]:\n    factors = []\n    for i in range(2, n + 1):\n        if is_prime(i) and n % i == 0:\n            factors.append(i)\n    return factors\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2 or a >= 100:\n        return False\n    \n    prime_factors = get_prime_factors(a)\n    if len(prime_factors) != 3:\n        return False\n    \n    product = 1\n    for factor in prime_factors:\n        product *= factor\n    \n    return product == a\n\n# Example usage:\n# print(is_multiply_prime(30))  # Output: True\n# print(is_multiply_prime(42))  # Output: True\n# print(is_multiply_prime(60))  # Output: False\n# print(is_multiply_prime(1))   # Output: False", "index": 0, "passed_case": [0, 1, 3, 6, 7, 8], "case_status": ["False", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/76_prompt1c", "code_candidates": [{"code": "def is_simple_power(x, n):\n    if n == 1:\n        return x == 1\n    if x == 1:\n        return False\n    power = 1\n    while power < x:\n        power *= n\n        if power == x:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/77_prompt1c", "code_candidates": [{"code": "def iscube(a: int) -> bool:\n    '''\n    Returns True if the integer a is a cube of some integer number.\n    '''\n    if a < 0:\n        a = -a\n    \n    # Find the cube root of a\n    cube_root = round(a ** (1/3))\n    \n    # Check if the cube of the cube root equals the original number\n    return cube_root ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/78_prompt1c", "code_candidates": [{"code": "def hex_key(num: str) -> int:\n    \"\"\"\n    Counts the number of hexadecimal digits that are primes.\n    Prime digits in hexadecimal are: 2, 3, 5, 7, B, D.\n    \"\"\"\n    # Define the prime digits in hexadecimal\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count the occurrences of prime digits in the input string\n    count = 0\n    for char in num:\n        if char in prime_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/79_prompt1c", "code_candidates": [{"code": "def decimal_to_binary(decimal: int) -> str:\n    \"\"\"Convert a decimal number to binary format and return it as a string with '0's and '1's, prefixed and suffixed with 'db'.\n    \n    Args:\n        decimal (int): The decimal number to convert.\n    \n    Returns:\n        str: The binary representation of the decimal number, prefixed and suffixed with 'db'.\n    \"\"\"\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    if decimal < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    binary_str = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary_str}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/80_prompt1c", "code_candidates": [{"code": "def is_happy(s: str) -> bool:\n    \"\"\"\n    Check if the string is happy.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n    \"\"\"\n    # Check if the length of the string is less than 3\n    if len(s) < 3:\n        return False\n    \n    # Iterate through the string and check every 3 consecutive letters\n    for i in range(len(s) - 2):\n        # Extract 3 consecutive letters\n        triplet = s[i:i+3]\n        # Check if all 3 letters are distinct\n        if len(set(triplet)) != 3:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "False", "True", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/81_prompt1c", "code_candidates": [{"code": "def numerical_letter_grade(grades):\n    \"\"\"Convert a list of GPAs to a corresponding list of letter grades based on the following grading scale:\n    4.0: 'A+',\n    3.7: 'A',\n    3.3: 'A-',\n    3.0: 'B+',\n    2.7: 'B',\n    2.3: 'B-',\n    2.0: 'C+',\n    1.7: 'C',\n    1.3: 'C-',\n    1.0: 'D+',\n    0.7: 'D',\n    0.0: 'F'.\n    Example:\n    numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B+', 'C', 'C+', 'A-']\"\"\"\n    \n    grading_scale = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'A-',\n        3.0: 'B+',\n        2.7: 'B',\n        2.3: 'B-',\n        2.0: 'C+',\n        1.7: 'C',\n        1.3: 'C-',\n        1.0: 'D+',\n        0.7: 'D',\n        0.0: 'F'\n    }\n    \n    letter_grades = []\n    for grade in grades:\n        # Find the closest grade in the scale\n        closest_grade = min(grading_scale.keys(), key=lambda x: abs(x - grade))\n        letter_grades.append(grading_scale[closest_grade])\n    \n    return letter_grades", "index": 0, "passed_case": [], "case_status": ["['A+', 'B+', 'C', 'C+', 'A']", "['C-']", "['D']", "['F']", "['D+', 'F', 'C', 'B', 'A-']", "['F', 'D']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/82_prompt1c", "code_candidates": [{"code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == False\n    prime_length('abcdcba') == False\n    prime_length('kittens') == False\n    prime_length('orange') == True\n    \"\"\"\n    return is_prime(len(string))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/84_prompt1c", "code_candidates": [{"code": "def solve(N: int) -> str:\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary as a string.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 (1+0+0+0), the output should be \"1\".\n        For N = 150, the sum of digits will be 6 (1+5+0), the output should be \"110\".\n        For N = 147, the sum of digits will be 12 (1+4+7), the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    if N < 0 or N > 10000:\n        raise ValueError(\"N must be between 0 and 10000 inclusive.\")\n    \n    # Calculate the sum of digits\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and return as a string\n    return bin(digit_sum)[2:]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "110", "1100", "1001", "10010"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/85_prompt1c", "code_candidates": [{"code": "def add(lst: list[int]) -> int:\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 1 and value % 2 == 0:\n            total += value\n    return total", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["88", "122", "0", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/86_prompt1c", "code_candidates": [{"code": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'iH'\n    anti_shuffle('hello') returns 'ollhe'\n    anti_shuffle('Hello World!!!') returns 'roldW!!! olleH'\n    \"\"\"\n    if not s:\n        return s\n    \n    words = s.split(' ')\n    ordered_words = []\n    \n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    \n    return ' '.join(ordered_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello !!!Wdlor", "", ".Hi My aemn is Meirst .Rboot How aer ?ouy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/87_prompt1c", "code_candidates": [{"code": "def get_row(lst, x):\n    \"\"\"\n    Given a 2-dimensional data as a nested list, find all occurrences of integer x and return their coordinates as a list of tuples [(row, column)], sorted by rows in ascending order and then by columns in descending order.\n    \n    Examples:\n    get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1) == [(0, 0), (1, 0), (1, 4), (2, 5)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == []\n    \"\"\"\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by rows in ascending order and then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/88_prompt1c", "code_candidates": [{"code": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [5, 4, 3, 2, 1, 0]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [0, 1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if not array:\n        return []\n    \n    first_value = array[0]\n    last_value = array[-1] if array else 0\n    sum_values = first_value + last_value\n    \n    if sum_values % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/89_prompt1c", "code_candidates": [{"code": "def encrypt(s: str) -> str:\n    encrypted_str = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            # Rotate lowercase letters by 4 places\n            encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted_str += encrypted_char\n        elif 'A' <= char <= 'Z':\n            # Rotate uppercase letters by 4 places\n            encrypted_char = chr(((ord(char) - ord('A') + 4) % 26) + ord('A'))\n            encrypted_str += encrypted_char\n        else:\n            # Non-alphabetic characters remain unchanged\n            encrypted_str += char\n    return encrypted_str", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["lm", "ewhjklnop", "kj", "ix"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/90_prompt1c", "code_candidates": [{"code": "def next_smallest(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function next_smallest() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 1\n    next_smallest([5, 1, 4, 3, 2]) == 1\n    next_smallest([]) == None\n    next_smallest([1, 1]) == 1\n    \"\"\"\n    if not lst:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return unique_sorted[-1] if unique_sorted else None\n    \n    return unique_sorted[1]", "index": 0, "passed_case": [0, 1, 2, 4, 6], "case_status": ["2", "2", "None", "1", "1", "1", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/91_prompt1c", "code_candidates": [{"code": "def is_bored(S: str) -> int:\n    \"\"\"\n    Count the number of boredoms in a string. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n\n    Args:\n        S (str): The input string containing sentences.\n\n    Returns:\n        int: The number of boredoms in the string.\n    \"\"\"\n    if not S:\n        return 0\n\n    sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence.startswith(\"I\"):\n            count += 1\n\n    return count", "index": 0, "passed_case": [0, 3, 5], "case_status": ["0", "3", "3", "0", "4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/92_prompt1c", "code_candidates": [{"code": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 integers.\n    Returns true if one of the numbers is equal to the sum of the other two.\n    Returns false in any other cases.\n    '''\n    return x == y + z or y == x + z or z == x + y", "index": 0, "passed_case": [0, 1, 3, 4, 5, 6, 7, 8], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/93_prompt1c", "code_candidates": [{"code": "def encode(message: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    encoded_message = \"\"\n\n    for char in message:\n        # Swap the case\n        if char.islower():\n            new_char = char.upper()\n        else:\n            new_char = char.lower()\n        \n        # Replace vowels with the letter 2 places ahead\n        if new_char in vowels:\n            if new_char.islower():\n                new_char = chr(((ord(new_char) - ord('a') + 2) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(new_char) - ord('A') + 2) % 26) + ord('A'))\n        \n        encoded_message += new_char\n\n    return encoded_message", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["tgst", "mWDCSKR", "ygs", "tHKS KS C MGSSCGG", "k dQnT kNqW wHcT Tq wRkTg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/94_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef sum_of_digits(n: int) -> int:\n    return sum(int(d) for d in str(n))\n\ndef skjkasdkd(lst: List[int]) -> int:\n    largest_prime = -1\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n    if largest_prime == -1:\n        return 0\n    return sum_of_digits(largest_prime)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["10", "25", "13", "11", "3", "7", "19", "19", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/95_prompt1c", "code_candidates": [{"code": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False.\n    The function should return False if the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    check_dict_case({\"name\":\"John\", \"age\":\"36\", \"city\":\"Houston\"}) should return True.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\"}) should return True.\n    \"\"\"\n    if not dict:\n        return False\n    \n    lower_case = all(isinstance(key, str) and key.islower() for key in dict.keys())\n    upper_case = all(isinstance(key, str) and key.isupper() for key in dict.keys())\n    \n    return lower_case or upper_case", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "False", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/96_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef first_n_primes_less_than(n: int) -> List[int]:\n    if n <= 0:\n        return []\n    primes = []\n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n    return primes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/97_prompt1c", "code_candidates": [{"code": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 4.\n    multiply(19, 28) should return 2.\n    multiply(2020, 1851) should return 10.\n    multiply(14,-15) should return 1.\n    \"\"\"\n    # Extract the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Return the product of the unit digits\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/98_prompt1c", "code_candidates": [{"code": "def count_upper(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 2\n    count_upper('abcdefg') returns 1\n    count_upper('dBBE') returns 1\n    \"\"\"\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/99_prompt1c", "code_candidates": [{"code": "def closest_integer(value: str) -> int:\n    number = float(value)\n    if number >= 0:\n        if number % 1 >= 0.5:\n            return int(number) + 1\n        else:\n            return int(number)\n    else:\n        if number % 1 <= -0.5:\n            return int(number) - 1\n        else:\n            return int(number)", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["10", "15", "-15", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/100_prompt1c", "code_candidates": [{"code": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 2]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    pile = []\n    current_stones = n\n    \n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    \n    return pile", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/101_prompt1c", "code_candidates": [{"code": "def words_string(s: str) -> list:\n    \"\"\"\n    Splits a string of words separated by commas or spaces into individual words\n    and returns an array containing only the last word.\n    \n    Args:\n        s (str): The input string containing words separated by commas or spaces.\n    \n    Returns:\n        list: A list containing only the last word from the input string.\n    \"\"\"\n    if not s:\n        return []\n    \n    # Split the string by either commas or spaces\n    words = [word.strip() for word in s.replace(',', ' ').split()]\n    \n    # Return the last word\n    return [words[-1]] if words else []", "index": 0, "passed_case": [4], "case_status": ["['John']", "['six']", "['name']", "['six']", "[]", "['gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/102_prompt1c", "code_candidates": [{"code": "def choose_num(x, y):\n    if x > y:\n        return -1\n    \n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    return -1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["14", "-1", "12354", "-1", "28", "-1", "-1", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/103_prompt1c", "code_candidates": [{"code": "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b1\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1010\"\n    rounded_avg(20, 33) => \"0b10100\"\n    \"\"\"\n    if n > m:\n        return -1\n    \n    # Calculate the sum of integers from n to m\n    total_sum = sum(range(n, m + 1))\n    \n    # Calculate the count of integers from n to m\n    count = m - n + 1\n    \n    # Calculate the average and round it to the nearest integer\n    average = round(total_sum / count)\n    \n    # Convert the rounded average to binary\n    binary_representation = bin(average)\n    \n    return binary_representation", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["0b11", "0b1010", "0b1111001010", "0b1111100100", "0b1011000010", "0b101101110", "0b110101101", "0b1001110010", "0b11010111", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/104_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef filter_odd_digit_numbers(x: List[int]) -> List[int]:\n    def has_only_odd_digits(number: int) -> bool:\n        return all(int(digit) % 2 != 0 for digit in str(number))\n    \n    return sorted(filter(has_only_odd_digits, x))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 15, 33]", "[]", "[111, 151]", "[31, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/105_prompt1c", "code_candidates": [{"code": "def by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For numbers outside the range 1-9, ignore them.\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]\n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8]\n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n\n      If the array is empty, return an empty array:\n      arr = []\n      return []\n\n      If the array has any numbers outside the range 1-9, ignore them:\n      arr = [1, -1 , 55]\n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return [\"One\"]\n    \"\"\"\n    # Filter numbers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/106_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef f(n: int) -> List[int]:\n    def factorial(x: int) -> int:\n        result = 1\n        for i in range(1, x + 1):\n            result *= i\n        return result\n\n    def sum_of_numbers(x: int) -> int:\n        return x * (x + 1) // 2\n\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_of_numbers(i))\n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 2, 6, 24, 15]", "[1, 2, 6, 24, 15, 720, 28]", "[1]", "[1, 2, 6]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/107_prompt1c", "code_candidates": [{"code": "def even_odd_palindrome(n: int) -> tuple:\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (2, 1)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (6, 4)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    def is_palindrome(x: int) -> bool:\n        \"\"\"Check if a number is a palindrome.\"\"\"\n        s = str(x)\n        return s == s[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/108_prompt1c", "code_candidates": [{"code": "def count_nums(arr):\n    def sum_of_signed_digits(num):\n        digits = []\n        num_str = str(num)\n        sign = 1\n        for char in num_str:\n            if char == '-':\n                sign = -1\n            else:\n                digits.append(sign * int(char))\n                sign = 1\n        return sum(digits)\n    \n    count = 0\n    for num in arr:\n        if sum_of_signed_digits(num) > 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "0", "6", "5", "4", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/109_prompt1c", "code_candidates": [{"code": "def move_one_ball(arr):\n    if not arr:\n        return True\n    \n    n = len(arr)\n    # Find the index of the minimum element\n    min_index = arr.index(min(arr))\n    \n    # Perform the right shift operation\n    shifted_arr = arr[-1:] + arr[:-1]\n    \n    # Check if the shifted array is sorted\n    for i in range(1, n):\n        if shifted_arr[i] < shifted_arr[i-1]:\n            return False\n    \n    return True", "index": 0, "passed_case": [2, 3, 4], "case_status": ["False", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/110_prompt1c", "code_candidates": [{"code": "def exchange(lst1, lst2):\n    \"\"\"\n    Determines whether it is possible to perform an exchange of elements\n    between lst1 and lst2 to make lst1 a list of only even numbers.\n    If possible, return \"YES\"; otherwise, return \"NO\".\n    \"\"\"\n    # Count the number of odd elements in lst1\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    \n    # Count the number of even elements in lst2\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If the number of odd elements in lst1 can be replaced by even elements from lst2, return \"YES\"\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["YES", "NO", "YES", "YES", "NO", "NO", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/111_prompt1c", "code_candidates": [{"code": "def histogram(test: str) -> dict:\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1}\n    histogram('a b b a') == {'a': 2}\n    histogram('a b c a b') == {'a': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    if not test:\n        return {}\n    \n    letter_counts = {}\n    for char in test.split():\n        if char in letter_counts:\n            letter_counts[char] += 1\n        else:\n            letter_counts[char] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {char: count for char, count in letter_counts.items() if count == max_count}\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/112_prompt1c", "code_candidates": [{"code": "def reverse_delete(s, c):\n    \"\"\"\n    Deletes all characters in s that are equal to any character in c,\n    then checks if the result string is a palindrome.\n    Returns a tuple containing the result string and True/False for the check.\n    \"\"\"\n    # Remove characters from s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return (result_string, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/113_prompt1c", "code_candidates": [{"code": "def odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for i, s in enumerate(lst):\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"'the number of odd elements in the string {odd_digits} of the input.'\")\n    return result", "index": 0, "passed_case": [], "case_status": ["[\"'the number of odd elements in the string 4 of the input.'\"]", "[\"'the number of odd elements in the string 1 of the input.'\", \"'the number of odd elements in the string 8 of the input.'\"]", "[\"'the number of odd elements in the string 2 of the input.'\", \"'the number of odd elements in the string 3 of the input.'\", \"'the number of odd elements in the string 2 of the input.'\"]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/114_prompt1c", "code_candidates": [{"code": "def minSubArraySum(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n    minSubArraySum([-1, -2, -3]) == -5\n    \"\"\"\n    if not nums:\n        return 0\n    \n    current_min = nums[0]\n    global_min = nums[0]\n    \n    for num in nums[1:]:\n        current_min = min(num, current_min + num)\n        global_min = min(global_min, current_min)\n    \n    return global_min", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/115_prompt1c", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    Calculate the number of times you need to lower the buckets to empty the wells.\n\n    Args:\n        grid (List[List[int]]): A rectangular grid of wells. Each 1 represents a unit of water.\n        capacity (int): The capacity of each bucket.\n\n    Returns:\n        int: The number of times you need to lower the buckets.\n    \"\"\"\n    if not grid:\n        return 0\n\n    total_buckets = 0\n\n    for row in grid:\n        water_units = row.count(1)\n        if water_units > 0:\n            total_buckets += math.ceil(water_units / capacity)\n\n    return total_buckets", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["6", "5", "0", "4", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/116_prompt1c", "code_candidates": [{"code": "def sort_array(arr):\n    \"\"\"\n    Sort an array of non-negative integers based on the number of ones in their binary representation in descending order. If two numbers have the same number of ones, sort them by their decimal value.\n\n    >>> sort_array([1, 5, 2, 3, 4]) == [5, 3, 4, 2, 1]\n    >>> sort_array([1, 0, 2, 3, 4]) == [3, 1, 4, 2, 0]\n    \"\"\"\n    # Define a key function that returns a tuple (number of ones, number)\n    def key_func(num):\n        return (-bin(num).count('1'), num)\n    \n    # Sort the array using the key function\n    return sorted(arr, key=key_func)", "index": 0, "passed_case": [3, 6, 7], "case_status": ["[3, 5, 1, 2, 4]", "[-6, -5, -3, -4, -2]", "[3, 1, 2, 4, 0]", "[]", "[77, 7, 3, 3, 5, 5, 5, 2, 2, 4, 4]", "[44, 3, 5, 6, 12, 32]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/117_prompt1c", "code_candidates": [{"code": "def select_words(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"had\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"lamb\"]\n    select_words(\"simple white space\", 2) ==> [\"white\"]\n    select_words(\"Hello world\", 4) ==> [\"Hello\"]\n    select_words(\"Uncle sam\", 3) ==> [\"sam\"]\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    if not s:\n        return result\n    \n    words = s.split()\n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['little']", "['Mary', 'lamb']", "[]", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/118_prompt1c", "code_candidates": [{"code": "def get_closest_vowel(word: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    # Iterate from the end of the word to the beginning\n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels:\n            # Check if the vowel is between two consonants\n            if i > 0 and i < len(word) - 1 and word[i - 1] in consonants and word[i + 1] in consonants:\n                return word[i]\n    return \"\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["u", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/119_prompt1c", "code_candidates": [{"code": "def match_parens(lst: List[str]) -> str:\n    '''\n    You are given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S are balanced. For example: the string '(())()' is good, while the string '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n    '''\n    from typing import List\n\n    def is_balanced(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    str1, str2 = lst\n    # Check both possible concatenations\n    if is_balanced(str1 + str2):\n        return 'Yes'\n    if is_balanced(str2 + str1):\n        return 'Yes'\n    return 'No'", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/120_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if not arr:\n        return []\n    \n    # Sort the array in descending order\n    sorted_arr = sorted(arr, reverse=True)\n    \n    # Initialize the result list with the first k elements\n    result = sorted_arr[:k]\n    \n    # Handle ties\n    for i in range(k, len(sorted_arr)):\n        if sorted_arr[i] == result[-1]:\n            result.append(sorted_arr[i])\n        else:\n            break\n    \n    # If k is greater than the length of arr, return all elements sorted\n    if k > len(arr):\n        return sorted(arr, reverse=True)\n    \n    return result", "index": 0, "passed_case": [1, 7], "case_status": ["[5, -3, -4]", "[4, 4]", "[2, 2]", "[123, 20, 2]", "[20, 2, 1, 0]", "[15, 5, 3, 0, 0, -8, -13]", "[5, 3]", "[5]", "[4, -4]", "[10, -10]", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/121_prompt1c", "code_candidates": [{"code": "def sum_odd_elements_in_even_positions(lst: List[int]) -> int:\n    total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["9", "0", "5", "0", "23", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/122_prompt1c", "code_candidates": [{"code": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 12 # sum of 9 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n    # Ensure arr is non-empty and k is within bounds\n    if not arr or k < 1 or k > len(arr):\n        return 0\n\n    # Sum elements with at most two digits from the first k elements\n    total = 0\n    for i in range(min(k, len(arr))):\n        if arr[i] < 100 and arr[i] > -100:\n            total += arr[i]\n\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["-4", "0", "125", "24", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/123_prompt1c", "code_candidates": [{"code": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in the Collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [5, 1] # The Collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are [5, 1].\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    odd_numbers = []\n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    odd_numbers.append(1)\n    return sorted(odd_numbers)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/124_prompt1c", "code_candidates": [{"code": "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    \"\"\"Validates a given date string and returns True if the date is valid, otherwise False.\n    The date is valid if:\n    1. The date string is not empty.\n    2. The number of days is valid for the given month and year.\n    3. The months are between 1 and 12.\n    4. The date is in the format: mm/dd/yyyy.\n    5. Days must be at least 1 for any month.\n    \"\"\"\n    if not date:\n        return False\n\n    # Check if the date matches the format mm/dd/yyyy\n    if not re.match(r'^\\d{2}/\\d{2}/\\d{4}$', date):\n        return False\n\n    try:\n        # Parse the date string\n        month, day, year = map(int, date.split('/'))\n\n        # Check if the month is between 1 and 12\n        if not (1 <= month <= 12):\n            return False\n\n        # Check if the day is at least 1\n        if day < 1:\n            return False\n\n        # Check if the date is valid for the given month and year\n        datetime(year, month, day)\n        return True\n\n    except ValueError:\n        return False", "index": 0, "passed_case": [1, 2, 5, 6, 7, 9, 11, 12, 13, 14, 15], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/125_prompt1c", "code_candidates": [{"code": "def split_words(txt: str) -> list[str] | int:\n    '''\n    Given a string of words, return a list of words split on whitespace. If no whitespaces exist, split on commas ','. If no commas exist, return the number of lowercase letters with odd order in the alphabet (ord('a') = 1, ord('b') = 2, ..., ord('z') = 26). If the string contains mixed whitespace and commas, split on whitespace first, then on commas. If the string contains only uppercase letters, return 0.\n    '''\n    if not txt:\n        return []\n    \n    # Check if the string contains only uppercase letters\n    if txt.isupper():\n        return 0\n    \n    # Split on whitespace first\n    words = txt.split()\n    \n    # If no whitespace, split on commas\n    if not words:\n        words = txt.split(',')\n    \n    # If no commas, count lowercase letters with odd order\n    if not words:\n        count = 0\n        for char in txt:\n            if char.islower():\n                if (ord(char) - ord('a') + 1) % 2 != 0:\n                    count += 1\n        return count\n    \n    return words", "index": 0, "passed_case": [0, 2, 3], "case_status": ["['Hello', 'world!']", "['Hello,world!']", "['Hello', 'world,!']", "['Hello,Hello,world', '!']", "['abcdef']", "['aaabb']", "['aaaBb']", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/126_prompt1c", "code_candidates": [{"code": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n    '''\n    if not lst:\n        return False\n    \n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return True\n        if lst[i] == lst[i + 1]:\n            return False\n    \n    return False", "index": 0, "passed_case": [9, 10], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/127_prompt1c", "code_candidates": [{"code": "from typing import Tuple\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection start and end\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # Check if there is an intersection\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = intersection_end - intersection_start + 1\n    \n    # Check if the length is a prime number\n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"", "index": 0, "passed_case": [0, 2, 3, 4, 5, 7], "case_status": ["NO", "YES", "YES", "YES", "NO", "NO", "YES", "NO"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/128_prompt1c", "code_candidates": [{"code": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    the sum of magnitudes of integers multiplied by the product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4]) == 1\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n    if not arr:\n        return None\n    \n    # Determine the sign of each number\n    signs = [1 if x > 0 else -1 if x < 0 else 0 for x in arr]\n    \n    # Calculate the product of all signs\n    product_of_signs = 1\n    for sign in signs:\n        if sign == 0:\n            product_of_signs = 0\n            break\n        product_of_signs *= sign\n    \n    # Calculate the sum of magnitudes\n    sum_of_magnitudes = sum(abs(x) for x in arr)\n    \n    return sum_of_magnitudes * product_of_signs", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["-9", "0", "-10", "None", "20", "4", "-4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/129_prompt1c", "code_candidates": [{"code": "from typing import List\nfrom itertools import product\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Generate all possible paths of length k\n    def generate_paths(path, x, y, length):\n        if length == k:\n            yield path\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                yield from generate_paths(path + [grid[nx][ny]], nx, ny, length + 1)\n    \n    # Initialize the minimum path with the lexicographically largest possible path\n    min_path = list(range(N*N, N*N - k, -1))\n    \n    # Iterate over all starting positions\n    for i, j in product(range(N), repeat=2):\n        for path in generate_paths([grid[i][j]], i, j, 1):\n            if path < min_path:\n                min_path = path\n    \n    return min_path", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 7, 8, 9, 10], "case_status": ["[1, 2, 1]", "[1]", "[1, 2, 1, 2]", "[1, 10, 1, 10, 1, 10, 1]", "[1, 7, 1, 7, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1]", "Timeout", "[1, 3, 1, 3, 1, 3, 1, 3]", "[1, 5, 1, 5, 1, 5, 1, 5]", "[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/130_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef tri(n: int) -> List[int]:\n    if n < 0:\n        return []\n    \n    # Initialize the first three values of the Tribonacci sequence\n    tribonacci_sequence = [0, 1, 1]\n    \n    # If n is less than 2, return the appropriate part of the sequence\n    if n <= 2:\n        return tribonacci_sequence[:n + 1]\n    \n    # Generate the Tribonacci sequence up to the nth number\n    for i in range(3, n + 1):\n        next_value = tribonacci_sequence[-1] + tribonacci_sequence[-2] + tribonacci_sequence[-3]\n        tribonacci_sequence.append(next_value)\n    \n    return tribonacci_sequence", "index": 0, "passed_case": [], "case_status": ["[0, 1, 1, 2]", "[0, 1, 1, 2, 4]", "[0, 1, 1, 2, 4, 7]", "[0, 1, 1, 2, 4, 7, 13]", "[0, 1, 1, 2, 4, 7, 13, 24]", "[0, 1, 1, 2, 4, 7, 13, 24, 44]", "[0, 1, 1, 2, 4, 7, 13, 24, 44, 81]", "[0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012]", "[0]", "[0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/131_prompt1c", "code_candidates": [{"code": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    product = 1\n    has_odd = False\n    \n    while n > 0:\n        digit = n % 10\n        if digit % 2 != 0:\n            product *= digit\n            has_odd = True\n        n = n // 10\n    \n    return product if has_odd else 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["5", "5", "5", "315", "2625", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/132_prompt1c", "code_candidates": [{"code": "def is_nested(string: str) -> bool:\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets\n    where at least one bracket in the subsequence is nested.\n    '''\n    stack = []\n    nested = False\n\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                continue  # Ignore unmatched closing brackets\n            stack.pop()\n            if len(stack) >= 1:\n                nested = True\n\n    return nested\n\n# Test cases\nprint(is_nested('[[]]'))         # True\nprint(is_nested('[]]]]]]][[[[[]'))  # True\nprint(is_nested('[][]'))         # False\nprint(is_nested('[]'))           # False\nprint(is_nested('[[][]]'))       # True\nprint(is_nested('[[]][['))       # False", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13], "case_status": ["True", "True", "False", "False", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/133_prompt1c", "code_candidates": [{"code": "import math\n\ndef sum_squares(lst):\n    if not lst:\n        return 0\n    return sum(math.ceil(x) ** 2 for x in lst)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/134_prompt1c", "code_candidates": [{"code": "import re\n\ndef check_if_last_char_is_a_letter(s: str) -> bool:\n    if not s:\n        return False\n    \n    # Find the last character\n    last_char = s[-1]\n    \n    # Check if the last character is an alphabetical character\n    if not last_char.isalpha():\n        return False\n    \n    # Use regex to check if the last character is part of a word\n    # A word is defined as a group of characters separated by space\n    # The regex looks for a word boundary (\\b) before the last character\n    return not bool(re.search(r'\\b\\w' + re.escape(last_char) + r'$', s))\n\n# Examples\n# print(check_if_last_char_is_a_letter('apple pie'))  # \u279e True\n# print(check_if_last_char_is_a_letter('apple pi e'))  # \u279e False\n# print(check_if_last_char_is_a_letter('apple pi e '))  # \u279e True\n# print(check_if_last_char_is_a_letter(''))  # \u279e False", "index": 0, "passed_case": [1, 3, 4, 5, 6, 7, 9], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/135_prompt1c", "code_candidates": [{"code": "def can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 2\n    can_arrange([1,2,3]) = 2\n    \"\"\"\n    if not arr:\n        return -1\n\n    max_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            max_index = i\n\n    return max_index", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "-1", "2", "4", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/136_prompt1c", "code_candidates": [{"code": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n    largest_negative = None\n    smallest_positive = None\n\n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return (largest_negative, smallest_positive)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/137_prompt1c", "code_candidates": [{"code": "import re\n\ndef compare_one(a, b):\n    def parse_number(value):\n        if isinstance(value, (int, float)):\n            return value\n        elif isinstance(value, str):\n            # Replace ',' with '.' and then try to convert to float\n            value = value.replace(',', '.')\n            if re.match(r'^-?\\d+(\\.\\d+)?$', value):\n                return float(value)\n        return None\n\n    parsed_a = parse_number(a)\n    parsed_b = parse_number(b)\n\n    if parsed_a is None or parsed_b is None:\n        return None\n\n    if parsed_a > parsed_b:\n        return a\n    elif parsed_b > parsed_a:\n        return b\n    else:\n        return None", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["2", "2.5", "3", "6", "2,3", "6", "2", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/138_prompt1c", "code_candidates": [{"code": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n    \n    Examples:\n    is_equal_to_sum_even(4) == True  # 2 + 2 + 0 + 0\n    is_equal_to_sum_even(6) == True  # 2 + 2 + 2 + 0\n    is_equal_to_sum_even(8) == True  # 2 + 2 + 2 + 2\n    \"\"\"\n    # Check if n is divisible by 2 and greater than or equal to 8\n    if n % 2 == 0 and n >= 8:\n        return True\n    # Special cases where n is 4 or 6\n    elif n == 4 or n == 6:\n        return True\n    else:\n        return False", "index": 0, "passed_case": [2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "True", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/139_prompt1c", "code_candidates": [{"code": "import math\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    result = 1\n    for i in range(1, n + 1):\n        result *= math.factorial(i)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/140_prompt1c", "code_candidates": [{"code": "def replace_spaces(text: str) -> str:\n    if not text:\n        return text\n    \n    # Replace all underscores with spaces to handle mixed cases\n    text = text.replace('_', ' ')\n    \n    # Split the text by spaces, but keep the delimiters\n    parts = text.split(' ')\n    \n    # Join the parts with underscores, but replace groups of more than 2 consecutive spaces with '-'\n    result = ''\n    consecutive_spaces = 0\n    \n    for part in parts:\n        if part == '':\n            consecutive_spaces += 1\n            if consecutive_spaces == 2:\n                result += '-'\n                consecutive_spaces = 0\n        else:\n            if consecutive_spaces > 0:\n                result += '_' * consecutive_spaces\n                consecutive_spaces = 0\n            result += part + '_'\n    \n    # Remove the trailing underscore if any\n    if result and result[-1] == '_':\n        result = result[:-1]\n    \n    return result", "index": 0, "passed_case": [0, 2], "case_status": ["Example", "Mudasir_Hanif", "Yellow_Yellow__Dirty__Fellow", "Exa_-mple", "-_Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/141_prompt1c", "code_candidates": [{"code": "import re\n\ndef file_name_check(file_name: str) -> str:\n    \"\"\"\n    Check if a file's name is valid based on the specified conditions.\n    \n    Args:\n        file_name (str): The file name to be checked.\n    \n    Returns:\n        str: 'Yes' if the file's name is valid, 'No' otherwise.\n    \"\"\"\n    # Check if there are more than three digits\n    if len(re.findall(r'\\d', file_name)) > 3:\n        return 'No'\n    \n    # Check if there is exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name is not empty and starts with a latin alphabet letter\n    if not name or not re.match(r'^[a-zA-Z]', name):\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "No", "No", "No", "No", "Yes", "No", "No", "No", "No", "No", "Yes", "Yes", "Yes", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/142_prompt1c", "code_candidates": [{"code": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be 4\n    \"\"\"\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            lst[i] = num ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = num ** 3\n    \n    return sum(lst)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["6", "14", "0", "9", "-3", "0", "-126", "3030", "0", "-14196", "-1448"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/143_prompt1c", "code_candidates": [{"code": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef words_in_sentence(sentence):\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["is", "go for", "there is no place", "Hi am Hussein", "go for it", "", "is"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/144_prompt1c", "code_candidates": [{"code": "from fractions import Fraction\n\ndef simplify(x, n):\n    \"\"\"\n    Simplifies the expression x * n and returns True if the result is a whole number, False otherwise.\n    \n    Args:\n    x (str): A string representation of a fraction in the format <numerator>/<denominator>.\n    n (str): A string representation of a fraction in the format <numerator>/<denominator>.\n    \n    Returns:\n    bool: True if x * n evaluates to a whole number, False otherwise.\n    \"\"\"\n    # Convert the string fractions to Fraction objects\n    fraction_x = Fraction(x)\n    fraction_n = Fraction(n)\n    \n    # Multiply the two fractions\n    result = fraction_x * fraction_n\n    \n    # Check if the result is a whole number\n    return result.denominator == 1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/145_prompt1c", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Sorts the given list of integers in ascending order according to the sum of their digits.\n    If there are several items with similar sum of their digits, order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [1, 11, -1, -12, -11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/146_prompt1c", "code_candidates": [{"code": "def specialFilter(nums):\n    \"\"\"\n    Takes an array of numbers as input and returns the number of elements in the array that are greater than 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9).\n    \"\"\"\n    def is_odd_digit(digit):\n        return digit in {1, 3, 5, 7, 9}\n\n    count = 0\n    for num in nums:\n        if num > 10:\n            # Convert number to positive if it's negative\n            abs_num = abs(num)\n            # Convert number to string to easily access first and last digits\n            num_str = str(abs_num)\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if is_odd_digit(first_digit) and is_odd_digit(last_digit):\n                count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "1", "2", "4", "3", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/147_prompt1c", "code_candidates": [{"code": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 0\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        There is no valid triple.\n    \"\"\"\n    if n < 3:\n        return 0\n\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "4", "36", "53361"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/148_prompt1c", "code_candidates": [{"code": "def bf(planet1, planet2):\n    '''\n    Returns a tuple containing all planets whose orbits are located between the orbit of planet1 and the orbit of planet2, sorted by the proximity to the sun.\n    Returns an empty tuple if planet1 or planet2 are not correct planet names.\n    Examples:\n    bf('Jupiter', 'Neptune') ==> ('Saturn', 'Uranus')\n    bf('Earth', 'Mercury') ==> ('Venus')\n    bf('Mercury', 'Uranus') ==> ('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\n    '''\n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    \n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    if index1 > index2:\n        index1, index2 = index2, index1\n    \n    return tuple(planets[index1 + 1:index2])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["('Saturn', 'Uranus')", "('Venus',)", "('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')", "('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')", "()", "()", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/149_prompt1c", "code_candidates": [{"code": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes the strings that have odd lengths,\n    and returns the resulted list sorted by length ascending, and alphabetically\n    for strings of the same length.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    sorted_lst = sorted(filtered_lst, key=lambda x: (len(x), x))\n    \n    return sorted_lst", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['aa']", "['AI', 'asdf', 'school']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['cc', 'dd', 'aaaa', 'bbbb']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/150_prompt1c", "code_candidates": [{"code": "import math\n\ndef x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 12\n    for x_or_y(15, 8, 5) == 8\n    \n    \"\"\"\n    if n < 2:\n        return y\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return y\n    return x", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["34", "5", "33", "3", "-1", "583", "129", "1234", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/151_prompt1c", "code_candidates": [{"code": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers in the list that are odd. Ignore numbers that are negative, not integers, or even.\n    \n    If the input list is empty, return 0.\n    '''\n    total = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            total += num ** 2\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "25", "0", "0", "0", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/152_prompt1c", "code_candidates": [{"code": "def compare(game, guess):\n    \"\"\"\n    Determines how far off each guess was from the actual scores.\n    \n    Args:\n    game (List[int]): The actual scores of the matches.\n    guess (List[int]): The guessed scores of the matches.\n    \n    Returns:\n    List[int]: An array where each element is 0 if the guess was correct, \n              or the absolute difference between the guess and the score otherwise.\n    \"\"\"\n    if len(game) != len(guess):\n        raise ValueError(\"The lengths of game and guess arrays must be equal.\")\n    \n    result = []\n    for actual, guessed in zip(game, guess):\n        if guessed == actual:\n            result.append(0)\n        else:\n            result.append(abs(guessed - actual))\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/153_prompt1c", "code_candidates": [{"code": "def Strongest_Extension(class_name: str, extensions: list) -> str:\n    \"\"\"\n    Finds the strongest extension based on the given criteria and returns the class name with the strongest extension.\n    \n    Parameters:\n    class_name (str): The name of the class.\n    extensions (list): A list of extension names.\n    \n    Returns:\n    str: A string in the format 'ClassName.StrongestExtensionName'.\n    \"\"\"\n    def calculate_strength(extension: str) -> float:\n        \"\"\"\n        Calculates the strength of an extension based on the number of uppercase and lowercase letters.\n        \n        Parameters:\n        extension (str): The name of the extension.\n        \n        Returns:\n        float: The strength of the extension.\n        \"\"\"\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        return CAP - SM\n    \n    if not extensions:\n        return f\"{class_name}.\"\n    \n    strongest_extension = max(extensions, key=calculate_strength)\n    return f\"{class_name}.{strongest_extension}\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["Watashi.eIGHt8OKe", "Boku123.YEs.WeCaNe", "__YESIMHERE.NuLl__", "K.TAR", "__HAHA.123", "YameRore.okIWILL123", "finNNalLLly.WoW", "_.Bb", "Sp.671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/154_prompt1c", "code_candidates": [{"code": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    Returns True if the second word or any of its rotations is a substring in the first word.\n    \"\"\"\n    if not a or not b:\n        return False\n\n    # Create all rotations of b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n\n    # Check if any rotation is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/155_prompt1c", "code_candidates": [{"code": "def even_odd_count(num: int) -> tuple:\n    \"\"\"Given an integer, return a tuple that has the number of even and odd digits respectively.\n\n    Example:\n       even_odd_count(-12) ==> (1, 1)\n       even_odd_count(123) ==> (2, 1)\n    \"\"\"\n    # Handle negative numbers by taking the absolute value\n    num = abs(num)\n    \n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each digit in the number\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(0, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/156_prompt1c", "code_candidates": [{"code": "def int_to_mini_roman(number):\n    \"\"\"\n    Given a positive integer, obtain its Roman numeral equivalent as a string,\n    and return it in lowercase.\n    Restrictions: 1 <= number <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000 inclusive.\")\n\n    roman_numerals = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n\n    result = []\n    for value, symbol in roman_numerals:\n        while number >= value:\n            result.append(symbol)\n            number -= value\n\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/157_prompt1c", "code_candidates": [{"code": "def right_angle_triangle(a, b, c):\n    # Create a list of the sides and sort them\n    sides = [a, b, c]\n    sides.sort()\n    \n    # Check if the triangle inequality holds\n    if sides[0] + sides[1] <= sides[2]:\n        return False\n    \n    # Apply the Pythagorean theorem\n    return sides[0]**2 + sides[1]**2 == sides[2]**2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/158_prompt1c", "code_candidates": [{"code": "def find_max(words):\n    \"\"\"\n    Accepts a list of strings and returns the word with the maximum number of unique characters.\n    If multiple strings have the maximum number of unique characters, return the one which comes first in lexicographical order.\n    \"\"\"\n    if not words:\n        return None\n\n    max_unique_count = -1\n    max_word = None\n\n    for word in words:\n        unique_chars = set(word)\n        unique_count = len(unique_chars)\n\n        if unique_count > max_unique_count or (unique_count == max_unique_count and (max_word is None or word < max_word)):\n            max_unique_count = unique_count\n            max_word = word\n\n    return max_word", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "enam", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/159_prompt1c", "code_candidates": [{"code": "def eat(initial_carrots: int, need: int) -> tuple[int, int]:\n    total_eaten = initial_carrots + min(need, initial_carrots)\n    remaining_carrots = max(initial_carrots - need, 0)\n    return total_eaten, remaining_carrots", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/160_prompt1c", "code_candidates": [{"code": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator and operand. The first list contains basic algebra operations, and the second list is a list of integers. Use the two given lists to build the algebraic expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + )\n    Subtraction ( - )\n    Multiplication ( * )\n    Floor division ( // )\n    Exponentiation ( ** )\n\n    Example:\n    operator = ['+', '*', '-']\n    operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 5\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    Additional Requirements:\n        - Validate that all operators in the operator list are valid. If an invalid operator is found, raise a ValueError.\n        - Handle division by zero in floor division by raising a ZeroDivisionError.\n    \"\"\"\n    # Valid operators\n    valid_operators = {'+', '-', '*', '//', '**'}\n    \n    # Validate operators\n    for op in operator:\n        if op not in valid_operators:\n            raise ValueError(f\"Invalid operator: {op}\")\n    \n    # Build the expression\n    expression = f\"{operand[0]}\"\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n    \n    # Evaluate the expression\n    try:\n        result = eval(expression)\n    except ZeroDivisionError:\n        raise ZeroDivisionError(\"Division by zero occurred in floor division.\")\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["37", "9", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/161_prompt1c", "code_candidates": [{"code": "def solve(s: str) -> str:\n    # Check if the string contains no letters\n    if not any(c.isalpha() for c in s):\n        return s[::-1]\n    \n    # Process each character in the string\n    result = ''.join(c.swapcase() if c.isalpha() else c for c in s)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["aSdF", "4321", "AB", "#A@c", "#aSDFw^45", "2@6#", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/162_prompt1c", "code_candidates": [{"code": "from typing import Union\nimport hashlib\n\ndef string_to_md5(text: str) -> Union[str, None]:\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '5eb63bbbe01eeed093cb22bb8f5acdc3'\n    >>> string_to_md5('') is None\n    \"\"\"\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/163_prompt1c", "code_candidates": [{"code": "def larger_even_number(a: int, b: int) -> int:\n    # Helper function to check if a number is even\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n\n    # Filter out non-even numbers\n    even_numbers = [x for x in [a, b] if is_even(x)]\n\n    # If there are no even numbers, return None\n    if not even_numbers:\n        return None\n\n    # Return the larger even number\n    return max(even_numbers)", "index": 0, "passed_case": [], "case_status": ["10", "10", "132", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/0_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if there are any two numbers in the list that are within a given threshold of each other. Specifically, return True if there exist two distinct indices i and j such that the absolute difference between numbers[i] and numbers[j] is less than or equal to the threshold, and False otherwise.\"\"\"\n    \n    # Iterate through all pairs of indices\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/1_prompt1p", "code_candidates": [{"code": "def extract_nested_parentheses(s: str) -> List[str]:\n    result = []\n    stack = []\n    current = \"\"\n    balance = 0\n\n    for char in s:\n        if char == '(':\n            if balance == 0:\n                stack.append(current)\n                current = \"\"\n            current += char\n            balance += 1\n        elif char == ')':\n            if balance > 0:\n                balance -= 1\n                current += char\n                if balance == 0:\n                    if current:\n                        result.append(current)\n                    current = stack.pop() if stack else \"\"\n            else:\n                return []\n        else:\n            if balance > 0:\n                current += char\n\n    if balance != 0:\n        return []\n\n    return result\n\n# Example usage:\n# extract_nested_parentheses(\"(())()\") should return [\"(())\", \"()\"]\n# extract_nested_parentheses(\"((a)(b))\") should return [\"((a)(b))\"]\n# extract_nested_parentheses(\"\") should return []\n# extract_nested_parentheses(\"no parentheses\") should return []\n# extract_nested_parentheses(\"(()\") should return []\n# extract_nested_parentheses(\"())\") should return []", "index": 0, "passed_case": [0, 1, 2], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['( )', '(( ))', '(( )( ))']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/2_prompt1p", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, decompose it into an integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1). Return the decimal part. If the input number is exactly an integer, return 0.0 as the decimal part.\"\"\"\n    if number < 0:\n        raise ValueError(\"Input number must be positive.\")\n    \n    integer_part = int(number)\n    decimal_part = number - integer_part\n    \n    return decimal_part if decimal_part > 0 else 0.0", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0.5", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/3_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero. \"\"\"\n    \n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/4_prompt1p", "code_candidates": [{"code": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation. \n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean_value = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(num - mean_value) for num in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/5_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert the 'delimeter' number between each element of the 'numbers' list.\n    If the list is empty, return an empty list.\n    If the list contains only one element, return the list unchanged.\n    Otherwise, insert the 'delimeter' number between each pair of elements, not at the end of the list.\n    \"\"\"\n    if not numbers:\n        return []\n    if len(numbers) == 1:\n        return numbers\n    \n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[5, 8, 6, 8, 3, 8, 2]", "[2, 2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/6_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef parse_parentheses_depth(s: str) -> List[int]:\n    if not s:\n        return []\n    \n    groups = s.split()\n    depths = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        stack = []\n        \n        for char in group:\n            if char == '(':\n                stack.append(char)\n                current_depth = len(stack)\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if not stack:\n                    raise ValueError(\"Unbalanced parentheses\")\n                stack.pop()\n            else:\n                continue\n        \n        if stack:\n            raise ValueError(\"Unbalanced parentheses\")\n        \n        depths.append(max_depth)\n    \n    return depths", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/7_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings to return only those strings that contain the specified substring.\n    If the input list is empty, return an empty list.\n    If the substring is an empty string, return the original list.\n    \"\"\"\n    if not strings:\n        return []\n    if not substring:\n        return strings\n    return [s for s in strings if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/8_prompt1p", "code_candidates": [{"code": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    \"\"\"\n    if not numbers:\n        return (0, 0)\n    \n    total_sum = sum(numbers)\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    \n    return (total_sum, total_product)", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["(0, 0)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/9_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef rolling_max(lst: List[int]) -> List[int]:\n    if not lst or len(lst) < 3:\n        return []\n    \n    result = []\n    for i in range(len(lst) - 2):\n        window = lst[i:i+3]\n        result.append(max(window))\n    \n    return result", "index": 0, "passed_case": [0], "case_status": ["[]", "[3, 4]", "[4, 3]", "[3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/10_prompt1p", "code_candidates": [{"code": "def make_palindrome(string: str) -> str:\n    \"\"\"\n    Find the shortest palindrome by appending the minimum number of characters to the input string to make it a palindrome.\n    If the input string is empty, return an empty string.\n    If the input string is already a palindrome, return the string as is.\n    Otherwise, find the longest palindromic suffix of the string. Append the reverse of the prefix (the part before the longest palindromic suffix) to the string to make it a palindrome.\n    \"\"\"\n    if not string:\n        return \"\"\n    \n    if string == string[::-1]:\n        return string\n    \n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if string[i:] == string[i:][::-1]:\n            # Append the reverse of the prefix\n            return string + string[:i][::-1]\n    \n    # If no palindromic suffix is found, append the reverse of the entire string\n    return string + string[:-1][::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "x", "xyzyx", "xyx", "jerryrrej"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/11_prompt1p", "code_candidates": [{"code": "def string_xor(a: str, b: str) -> str:\n    # Determine the maximum length\n    max_len = max(len(a), len(b))\n    \n    # Pad the shorter string with '0's\n    a = a.zfill(max_len)\n    b = b.zfill(max_len)\n    \n    # Perform the XOR operation\n    result = ''.join('1' if x != y else '0' for x, y in zip(a, b))\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/12_prompt1p", "code_candidates": [{"code": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return one of them. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \"\"\"\n    if not strings:\n        return None\n    \n    return max(strings, key=len)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/13_prompt1p", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b using the Euclidean algorithm.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return abs(a)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/14_prompt1p", "code_candidates": [{"code": "def get_prefixes(s: str) -> List[str]:\n    return [s[:i] for i in range(len(s) + 1)]", "index": 0, "passed_case": [], "case_status": ["['']", "['', 'a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['', 'W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/15_prompt1p", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    if n <= 0:\n        return \"\"\n    return \" \".join(str(i) for i in range(1, n + 1))", "index": 0, "passed_case": [], "case_status": ["", "1 2 3", "1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/16_prompt1p", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters does it consist of\n    \"\"\"\n    if string is None:\n        return 0\n    return len(set(string))", "index": 0, "passed_case": [0, 1], "case_status": ["0", "5", "9", "2", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/17_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    return [i + 1 for i in range(len(music_string))]", "index": 0, "passed_case": [0], "case_status": ["[]", "[1, 2, 3, 4, 5, 6, 7]", "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]", "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]", "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/18_prompt1p", "code_candidates": [{"code": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string.\n    \"\"\"\n    if not string or not substring:\n        return 0\n    count = 0\n    substring_length = len(substring)\n    string_length = len(string)\n    for i in range(string_length - substring_length + 1):\n        if string[i:i + substring_length] == substring:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/19_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Input is a space-delimited string of numerals. The function should sort the numerals in ascending order and return a space-delimited string of sorted numerals.\n    Non-numeric values should be ignored. If the input string is empty, return an empty string.\n    \"\"\"\n    if not numbers:\n        return \"\"\n    \n    # Split the input string by spaces and filter out non-numeric values\n    filtered_numbers = [num for num in numbers.split() if num.isdigit()]\n    \n    # Sort the numeric values\n    sorted_numbers = sorted(filtered_numbers, key=int)\n    \n    # Join the sorted numbers into a space-delimited string\n    return \" \".join(sorted_numbers)", "index": 0, "passed_case": [0], "case_status": ["", "", "", "", ""]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/20_prompt1p", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order.\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    numbers_sorted = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (numbers_sorted[0], numbers_sorted[1])\n    \n    for i in range(1, len(numbers_sorted)):\n        diff = abs(numbers_sorted[i] - numbers_sorted[i-1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers_sorted[i-1], numbers_sorted[i])\n    \n    return closest_pair", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/21_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef rescale(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        raise ValueError(\"All elements in the list are the same, cannot rescale.\")\n    \n    rescaled_numbers = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return rescaled_numbers", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/22_prompt1p", "code_candidates": [{"code": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any Python values and return only the integers.\n    If the input list is empty, return an empty list.\n    If the input list contains no integers, return an empty list.\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/23_prompt1p", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return length\n    \"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/24_prompt1p", "code_candidates": [{"code": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly\n    \"\"\"\n    if n == 0:\n        return 0\n    if n < 0:\n        n = -n\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/25_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer.\n    If `n` is less than 2, return an empty list.\n    If `n` is a prime number, return a list containing only `n`.\n    \"\"\"\n    if n < 2:\n        return []\n    \n    factors = []\n    divisor = 2\n    \n    while n >= divisor * divisor:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n    \n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/26_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef remove_duplicates(lst: List[int]) -> List[int]:\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "[1, 2, 3, 4]", "[1, 2, 3, 4, 5]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/27_prompt1p", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase characters to lowercase. Non-alphabetic characters should remain unchanged.\n    \"\"\"\n    return ''.join(char.upper() if char.islower() else char.lower() if char.isupper() else char for char in string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/28_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef concatenate_strings(strings: List[str], separator: str = None) -> str:\n    if separator is None:\n        return ''.join(strings)\n    else:\n        return separator.join(strings)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "xyz", "xyzwk"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/29_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], x: str) -> List[str]:\n    \"\"\" Filter an input list of strings to return only those that start with the given prefix `x`.\"\"\"\n    return [s for s in strings if s.startswith(x)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/30_prompt1p", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [x for x in l if x > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/31_prompt1p", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    \"\"\"Return true if 'n' is a prime number, and false otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/32_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef find_zero(xs: list) -> float:\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero finds a root (zero) of the polynomial using the Newton-Raphson method.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"The list of coefficients must not be empty.\")\n    \n    # Define the polynomial function\n    def polynomial(x: float) -> float:\n        return sum(coeff * (x ** (len(xs) - i - 1)) for i, coeff in enumerate(xs))\n    \n    # Define the derivative of the polynomial function\n    def derivative(x: float) -> float:\n        return sum((len(xs) - i - 1) * coeff * (x ** (len(xs) - i - 2)) for i, coeff in enumerate(xs[:-1]))\n    \n    # Initial guess\n    x0 = 0.0\n    \n    # Tolerance and maximum iterations\n    tolerance = 1e-7\n    max_iterations = 1000\n    \n    for _ in range(max_iterations):\n        fx = polynomial(x0)\n        dfx = derivative(x0)\n        \n        if abs(fx) < tolerance:\n            return x0\n        \n        if dfx == 0:\n            raise ValueError(\"Derivative is zero. Newton-Raphson method failed.\")\n        \n        x0 = x0 - fx / dfx\n    \n    raise ValueError(\"Failed to converge within the maximum number of iterations.\")\n\n# Example usage:\n# print(find_zero([1, -3, 2]))  # Should find a root of the polynomial x^2 - 3x + 2", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/33_prompt1p", "code_candidates": [{"code": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l.\n    \"\"\"\n    if not l:\n        return l\n    \n    # Extract elements at indices divisible by three and sort them\n    sorted_thirds = sorted(l[i] for i in range(0, len(l), 3))\n    \n    # Create a new list with sorted elements at indices divisible by three\n    result = l.copy()\n    sorted_index = 0\n    for i in range(0, len(l), 3):\n        if i < len(l):\n            result[i] = sorted_thirds[sorted_index]\n            sorted_index += 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[2, 6, 3, 4, 8, 9, 5]", "[2, 8, 3, 4, 6, 9, 5]", "[2, 6, 9, 4, 8, 3, 5]", "[2, 6, 3, 4, 8, 9, 5, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/34_prompt1p", "code_candidates": [{"code": "def unique(l: list):\n    \"\"\"Return a list of unique elements from the input list, maintaining the original order.\"\"\"\n    seen = set()\n    return [x for x in l if not (x in seen or seen.add(x))]", "index": 0, "passed_case": [], "case_status": ["[5, 3, 2, 9, 0, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/35_prompt1p", "code_candidates": [{"code": "def max_element(l: list): \n    \"\"\"Return the maximum element in the list.\"\"\"\n    if not l:\n        return None\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/36_prompt1p", "code_candidates": [{"code": "def fizz_buzz(n: int, divisor: int) -> int:\n    count = 0\n    for number in range(divisor, n, divisor):\n        count += str(number).count('7')\n    return count", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/37_prompt1p", "code_candidates": [{"code": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l.\n    \"\"\"\n    if not l:\n        return []\n    \n    # Extract even-indexed elements and sort them\n    even_elements = sorted(l[i] for i in range(0, len(l), 2))\n    \n    # Reconstruct the list with sorted even-indexed elements\n    result = []\n    even_index = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            result.append(even_elements[even_index])\n            even_index += 1\n        else:\n            result.append(l[i])\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[1, 2, 3]", "[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]", "[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/38_prompt1p", "code_candidates": [{"code": "def candidate(encoded_string: str) -> str:\n    \"\"\"\n    Decodes a string that was encoded using the 'encode_cyclic' function.\n\n    Parameters:\n    encoded_string (str): The string to be decoded.\n\n    Returns:\n    str: The decoded string.\n    \"\"\"\n    decoded_string = \"\"\n    for char in encoded_string:\n        # Assuming 'encode_cyclic' shifts each character by 1 in the alphabet\n        # Decoding involves shifting each character back by 1\n        if char.isalpha():\n            if char == 'a':\n                decoded_char = 'z'\n            elif char == 'A':\n                decoded_char = 'Z'\n            else:\n                decoded_char = chr(ord(char) - 1)\n            decoded_string += decoded_char\n        else:\n            decoded_string += char\n    return decoded_string", "index": 0, "passed_case": [], "case_status": ["zwcgghwcdwqurmbzbafg", "zqsvtfqmvnrgyzhyex", "hdjxjfblckkchysa", "clqqibsktfvraubgx", "gcbhnlketkfkuh", "bsteqtgewlhnvqtujgxx", "ayglhjfrbv", "toftnlhddwqghwq", "rlmgdkobpacxtedumys", "lslphnzuqwc", "xhqtjximcnzewhwxeppc", "tpifdsxekxpqsjzzcoky", "aggbbrobwqxxdd", "qeopshfqmwvxvifutlkn", "cgnbjgrqzrggbvzagt", "jbaghpofuqd", "ogroyyfcmumcmmkwanu", "catwjlcgyfqfdmnhnegb", "qcytqabxzemgofola", "zllyyhimnwyv", "voufidarfqawjawroa", "eapbepsbbglurgcsar", "mubrprhfjvjuhlgutdi", "xbjnszcbrfpqdkhbg", "eniviqytszupiuq", "hcdwqchidsf", "utfpohabhmhtzja", "hetnqwmqvcbz", "akqqdrdamkyi", "fukucgxqkm", "dgwyyemzewjemyywyug", "yvelacgfokinyg", "ufzjhlxhbtpkl", "jzqhecharsmcwykmsjpc", "fhrvmapyzuwqwuwf", "bumsjjcwupiimju", "iqvfmdluueswilrq", "ifiyrmtjsn", "ufnoypweybiuutpsj", "guxgyidzfag", "xbsmtnfvrlovgdltv", "xcxmgxyvep", "qgandcnuyqspxnjsw", "qnmwoehxnthgxpxtgo", "bvnghijqjddbgl", "fbvmjmnmqfma", "rvxxrzozlixkmqlw", "sgyghoozmjulyluenw", "qzsrrlzbumdt", "ahejfljjnlhxmhxbo", "qawgtkxtba", "fzgdgsoudc", "nvfxkhssevcweixrzci", "llufbvvtrcvgiuxycsy", "akymuqbpkjztocmktmn", "ewmthpyqsonx", "rhwgbjnghnrxulsj", "jeofkohjyh", "hqvpfzgwboqmgvxtvoo", "zbygligivrkuqpokm", "kvjhingchfjwwqcvex", "wofwrhpsxcfii", "eikvqzhadqiav", "xotzrcooijen", "ochlobrtbu", "dydibrcqgx", "sysgxslnpirnirms", "wcsftxhufb", "eqgezbnvmois", "ivgvniugbh", "uyrmcfgtqhddaebisywr", "cnnivvhplonqbs", "wjmhzsgubr", "xuzrahxexptohenmtro", "kmojujejcmv", "uliqaxbjnjchlpxzu", "manpkfxosnxtfhadiq", "ocvtszgvyiqeqmzbg", "ctnovdpvihm", "gnodlqspfdbwxyhmj", "zihirwuornqdkjoxqq", "jfngrvgxlajmovwy", "uyldotdpajcrcpnn", "dmwdbtyhoj", "ltvjubljqvxtqaobgst", "gwimcbtvxnecizvjyaai", "mdkpmguyreeeslb", "goudgrthnhunynzuqie", "krntmihnvif", "cgorklivrzuihzlr", "waxwosxyisyggtkshfux", "dtuttciyaarnwdkijbwm", "dyfkpqhepoyh", "jywnbcxgdwuuly", "bykzhlcnquwkhrutkl", "gousqzsgjtb", "vinmctaadocigqclndku", "rwmdmwcotmhsvkannf", "cukqtkalkfchn", "ftusztyjagd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/39_prompt1p", "code_candidates": [{"code": "from typing import List\nimport math\n\ndef is_prime(num: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef is_perfect_square(num: int) -> bool:\n    \"\"\"Check if a number is a perfect square.\"\"\"\n    sqrt = int(math.sqrt(num))\n    return sqrt * sqrt == num\n\ndef is_fibonacci(num: int) -> bool:\n    \"\"\"Check if a number is a Fibonacci number.\"\"\"\n    return is_perfect_square(5 * num * num + 4) or is_perfect_square(5 * num * num - 4)\n\ndef prime_fib(n: int) -> int:\n    \"\"\"Return the n-th number that is both a prime number and a Fibonacci number.\"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    count = 0\n    fib = 1\n    prev = 0\n    \n    while True:\n        next_fib = fib + prev\n        prev = fib\n        fib = next_fib\n        \n        if is_fibonacci(fib) and is_prime(fib):\n            count += 1\n            if count == n:\n                return fib\n\n# Example usage:\n# print(prime_fib(1))  # Output: 2\n# print(prime_fib(2))  # Output: 3\n# print(prime_fib(3))  # Output: 5\n# print(prime_fib(4))  # Output: 13", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "433494437"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/40_prompt1p", "code_candidates": [{"code": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    Takes a list of integers as an input.\n    Returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if len(l) < 3:\n        return False\n\n    # Sort the list to use two-pointer technique\n    l.sort()\n\n    # Iterate through the list to find triplets\n    for i in range(len(l) - 2):\n        # Skip duplicates\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        left = i + 1\n        right = len(l) - 1\n\n        while left < right:\n            total = l[i] + l[left] + l[right]\n            if total == 0:\n                return True\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/41_prompt1p", "code_candidates": [{"code": "def count_collisions(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between two sets of n cars moving towards each other.\n\n    Args:\n        n (int): The number of cars on each side of the road.\n\n    Returns:\n        int: The total number of collisions.\n    \"\"\"\n    if n == 0:\n        return 0\n    return n * n\n\n# Example usage:\n# print(count_collisions(0))  # Output: 0\n# print(count_collisions(1))  # Output: 1\n# print(count_collisions(2))  # Output: 4\n# print(count_collisions(3))  # Output: 9", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/42_prompt1p", "code_candidates": [{"code": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented.\n    \"\"\"\n    return [x + 1 for x in l]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/43_prompt1p", "code_candidates": [{"code": "def pairs_sum_to_zero(l: List[int]) -> bool:\n    \"\"\"\n    Takes a list of integers as an input.\n    Returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n    \"\"\"\n    seen = set()\n    for num in l:\n        if num == 0 and l.count(0) > 1:\n            return True\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/44_prompt1p", "code_candidates": [{"code": "def change_base(x: int, y: int):\n    \"\"\"Change numerical base of input number x to base y.\n    \"\"\"\n    if x < 0:\n        sign = -1\n        x = -x\n    else:\n        sign = 1\n\n    if y < 2:\n        raise ValueError(\"Base y must be greater than or equal to 2.\")\n\n    if x == 0:\n        return \"0\"\n\n    digits = []\n    while x > 0:\n        digits.append(str(x % y))\n        x = x // y\n\n    if sign == -1:\n        digits.append(\"-\")\n\n    digits.reverse()\n    return ''.join(digits)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/45_prompt1p", "code_candidates": [{"code": "def triangle_area(a, h): \n    \"\"\"Given the length of a side (a) and the corresponding height (h), return the area of the triangle, calculated as (a * h) / 2.\"\"\"\n    return (a * h) / 2", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/46_prompt1p", "code_candidates": [{"code": "def fib4(n: int) -> int:\n    \"\"\"\n    The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    This function efficiently computes the n-th element of the fib4 number sequence without using recursion.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    \n    a, b, c, d = 0, 0, 2, 0\n    \n    for _ in range(4, n + 1):\n        next_val = (a + b + c + d) % 2  # Only the last bit is needed for fib4 sequence\n        a, b, c, d = b, c, d, next_val\n    \n    return d", "index": 0, "passed_case": [], "case_status": ["0", "0", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/47_prompt1p", "code_candidates": [{"code": "def median(l: list):\n    \"\"\"Return the median value of the elements in the list l.\n    If the list has an odd number of elements, return the middle element.\n    If the list has an even number of elements, return the average of the two middle elements.\n    \"\"\"\n    if not l:\n        return None  # Return None for empty list\n    \n    sorted_l = sorted(l)\n    n = len(sorted_l)\n    mid = n // 2\n    \n    if n % 2 == 1:\n        return sorted_l[mid]\n    else:\n        return (sorted_l[mid - 1] + sorted_l[mid]) / 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "8.0", "5", "5.5", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/48_prompt1p", "code_candidates": [{"code": "def is_palindrome(text: str) -> bool:\n    \"\"\"\n    Checks if the given string is a palindrome, meaning it reads the same forwards and backwards.\n    \"\"\"\n    if not text:\n        return True  # An empty string is considered a palindrome\n    return text == text[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/49_prompt1p", "code_candidates": [{"code": "def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\"\"\"\n    if n < 0 or p <= 0:\n        raise ValueError(\"Both n must be non-negative and p must be positive.\")\n    return pow(2, n, p)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/50_prompt1p", "code_candidates": [{"code": "def candidate(s: str) -> str:\n    \"\"\"\n    Takes as input a string encoded with the encode_shift function and returns the decoded string by shifting every character back by 5 in the alphabet. The function handles both uppercase and lowercase letters, maintaining the original case, and leaves non-alphabetic characters unchanged.\n\n    Example:\n    - Input: 'fghij'\n    - Output: 'abcde'\n    - Input: 'FGHIJ'\n    - Output: 'ABCDE'\n    - Input: '123!@#'\n    - Output: '123!@#'\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\" if ch.islower() else \"A\")) % 26) + ord(\"a\" if ch.islower() else \"A\")) if ch.isalpha() else ch for ch in s])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/51_prompt1p", "code_candidates": [{"code": "def remove_vowels(text: str) -> str:\n    \"\"\"Remove all vowels (a, e, i, o, u, A, E, I, O, U) from the input string and return the resulting string without vowels.\"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/52_prompt1p", "code_candidates": [{"code": "def below_threshold(l: list, t: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are less than the threshold t.\"\"\"\n    if not l:\n        return True  # An empty list has no elements above the threshold\n    return all(num < t for num in l)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/53_prompt1p", "code_candidates": [{"code": "def add(x: int, y: int) -> int:\n    \"\"\"Return the sum of two integers x and y.\"\"\"\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/54_prompt1p", "code_candidates": [{"code": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create dictionaries to count character frequencies\n    from collections import Counter\n    count_s0 = Counter(s0)\n    count_s1 = Counter(s1)\n    \n    # Check if the character counts are the same\n    return count_s0 == count_s1", "index": 0, "passed_case": [3, 4, 5, 6], "case_status": ["False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/55_prompt1p", "code_candidates": [{"code": "def fib(n: int) -> int:\n    \"\"\"\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/56_prompt1p", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"<\" and \">\".\n\n    >>> correct_bracketing(\"<\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        elif bracket == \">\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/57_prompt1p", "code_candidates": [{"code": "def monotonic(l: list) -> bool:\n    \"\"\"\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if not l:\n        return True\n    \n    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n    \n    return increasing or decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/58_prompt1p", "code_candidates": [{"code": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return common elements between l1 and l2.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/59_prompt1p", "code_candidates": [{"code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            other_factor = n // i\n            if is_prime(other_factor):\n                return other_factor\n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/60_prompt1p", "code_candidates": [{"code": "def sum_to_n(n: int) -> int:\n    \"\"\"The function sums all integers from 1 to n, inclusive. If n is less than 1, the function should return 0.\"\"\"\n    if n < 1:\n        return 0\n    return sum(range(1, n + 1))", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/61_prompt1p", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"(\" and \")\".\n\n    >>> correct_bracketing(\"(\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            balance += 1\n        elif bracket == \")\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/62_prompt1p", "code_candidates": [{"code": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    \"\"\"\n    if not xs:\n        return []\n    \n    return [xs[i] * i for i in range(1, len(xs))]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/63_prompt1p", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"\n    if n == 0 or n == 1:\n        return 0\n    \n    # Initialize the first three FibFib numbers\n    fibfib_prev_prev = 0  # fibfib(0)\n    fibfib_prev = 0       # fibfib(1)\n    fibfib_current = 1    # fibfib(2)\n    \n    # Compute the FibFib sequence iteratively\n    for _ in range(3, n + 1):\n        fibfib_next = fibfib_prev_prev + fibfib_prev + fibfib_current\n        fibfib_prev_prev, fibfib_prev, fibfib_current = fibfib_prev, fibfib_current, fibfib_next\n    \n    return fibfib_current", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/64_prompt1p", "code_candidates": [{"code": "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n\n    vowels = set('aeiou')\n    count = 0\n\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n\n    # Check for 'y' at the end of the word\n    if s and s[-1].lower() == 'y':\n        count += 1\n\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/65_prompt1p", "code_candidates": [{"code": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits\n    and return the result as a string.\n    \"\"\"\n    if not isinstance(x, int) or not isinstance(shift, int):\n        raise ValueError(\"Both x and shift must be integers.\")\n    \n    x_str = str(x)\n    shift = shift % len(x_str)  # Ensure shift is within the bounds of the string length\n    \n    shifted_str = x_str[shift:] + x_str[:shift]\n    return shifted_str", "index": 0, "passed_case": [1, 3, 4], "case_status": ["010", "12", "97", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/66_prompt1p", "code_candidates": [{"code": "def digitSum(s: str) -> int:\n    \"\"\"\n    Returns the sum of the digits in the string.\n\n    Args:\n    s (str): The input string.\n\n    Returns:\n    int: The sum of the digits in the string.\n    \"\"\"\n    return sum(int(char) for char in s if char.isdigit())", "index": 0, "passed_case": [0], "case_status": ["0", "0", "0", "0", "0", "0", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/67_prompt1p", "code_candidates": [{"code": "def fruit_distribution(s: str, n: int) -> int:\n    # Split the string by ', ' to separate apples and oranges\n    parts = s.split(', ')\n    \n    # Initialize variables to store apple and orange counts\n    apple_count = 0\n    orange_count = 0\n    \n    # Iterate through the parts to find apple and orange counts\n    for part in parts:\n        if part.startswith('apples: '):\n            try:\n                apple_count = int(part.split(': ')[1])\n            except (IndexError, ValueError):\n                raise ValueError(\"Invalid format for apples count\")\n        elif part.startswith('oranges: '):\n            try:\n                orange_count = int(part.split(': ')[1])\n            except (IndexError, ValueError):\n                raise ValueError(\"Invalid format for oranges count\")\n    \n    # Check if both apple and orange counts were found\n    if apple_count == 0 or orange_count == 0:\n        raise ValueError(\"Invalid format for input string\")\n    \n    # Calculate the total number of apples and oranges\n    total_apples_oranges = apple_count + orange_count\n    \n    # Check if the total number of fruits is less than the sum of apples and oranges\n    if n < total_apples_oranges:\n        raise ValueError(\"Total number of fruits is less than the sum of apples and oranges\")\n    \n    # Calculate and return the number of mangoes\n    return n - total_apples_oranges", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/68_prompt1p", "code_candidates": [{"code": "from typing import List, Optional\n\ndef pluck_node(branch: List[int]) -> Optional[int]:\n    if not branch:\n        return None\n    return branch[0]", "index": 0, "passed_case": [], "case_status": ["4", "1", "None", "5", "1", "5", "7", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/69_prompt1p", "code_candidates": [{"code": "from collections import Counter\nfrom typing import List, Optional\n\ndef search(lst: List[int]) -> Optional[int]:\n    if not lst:\n        return None\n    \n    count = Counter(lst)\n    candidates = [num for num in count if num > 0 and count[num] > 1]\n    \n    if not candidates:\n        return None\n    \n    return max(candidates)", "index": 0, "passed_case": [1, 3, 6, 10], "case_status": ["5", "4", "3", "8", "3", "10", "2", "10", "8", "10", "1", "10", "None", "10", "10", "10", "10", "10", "10", "10", "None", "9", "10", "9", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/70_prompt1p", "code_candidates": [{"code": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in strange order.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left = 0\n    right = len(sorted_lst) - 1\n    \n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/71_prompt1p", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    '''\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        # Round the area to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return None if the sides do not form a valid triangle\n        return None", "index": 0, "passed_case": [0, 2, 3, 5, 7], "case_status": ["6.0", "None", "8.18", "1.73", "None", "16.25", "None", "0.43", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/72_prompt1p", "code_candidates": [{"code": "def will_it_fly(q, w):\n    '''\n    Returns True if the object q will fly, and False otherwise.\n    '''\n    # Check if the total weight of q is within the allowed maximum weight w\n    if sum(q) > w:\n        return False\n    \n    # Check if the object is balanced\n    # Calculate the center of mass\n    total_weight = sum(q)\n    if total_weight == 0:\n        return True  # An empty object or an object with zero weight is trivially balanced\n    \n    center_of_mass = sum(index * weight for index, weight in enumerate(q)) / total_weight\n    \n    # Check if the center of mass is at the center of the object\n    if center_of_mass == (len(q) - 1) / 2:\n        return True\n    else:\n        return False\n\n# Example usage:\n# print(will_it_fly([1, 2], 5))  # \u279e False\n# print(will_it_fly([3, 2, 3], 1))  # \u279e False\n# print(will_it_fly([3, 2, 3], 9))  # \u279e True\n# print(will_it_fly([3], 5))  # \u279e True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/73_prompt1p", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n    \"\"\"\n    if not arr:\n        return 0\n\n    changes = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n\n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/74_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef compare_string_lengths(list1: List[str], list2: List[str]) -> List[str]:\n    # Calculate the total number of characters in each list\n    total_chars_list1 = sum(len(s) for s in list1)\n    total_chars_list2 = sum(len(s) for s in list2)\n    \n    # Return the list with the greater total number of characters\n    # If both lists have the same total, return the first list\n    return list1 if total_chars_list1 >= total_chars_list2 else list2", "index": 0, "passed_case": [0, 6], "case_status": ["[]", "['hi', 'admin']", "['hi', 'hi', 'admin', 'project']", "['1', '2', '3', '4', '5']", "['hi', 'admin']", "['hi', 'admin']", "['hi', 'admin']", "['this']", "['this']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/75_prompt1p", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2:\n        return False\n\n    prime_factors = []\n    for i in range(2, a + 1):\n        if a % i == 0 and is_prime(i):\n            prime_factors.append(i)\n            a //= i\n            while a % i == 0:\n                prime_factors.append(i)\n                a //= i\n        if a == 1:\n            break\n\n    return len(prime_factors) >= 2\n\n# Example usage:\n# print(is_multiply_prime(30))  # Output: True", "index": 0, "passed_case": [0, 1, 2, 4, 5, 9], "case_status": ["False", "True", "True", "True", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/76_prompt1p", "code_candidates": [{"code": "def is_simple_power(x, n):\n    \"\"\"\n    Returns True if x is a simple power of n, otherwise False.\n    x is a simple power of n if there exists an integer k such that x = n^k.\n    \"\"\"\n    if n == 0:\n        return x == 0\n    if x == 0:\n        return False\n    if n == 1:\n        return x == 1\n    if x == 1:\n        return True\n    \n    power = 1\n    while power < x:\n        power *= n\n        if power == x:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/77_prompt1p", "code_candidates": [{"code": "def iscube(a: int) -> bool:\n    '''\n    Returns True if the integer a is a perfect cube, and False otherwise.\n    '''\n    if a < 0:\n        a = -a\n    \n    cube_root = round(a ** (1/3))\n    \n    return cube_root ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/78_prompt1p", "code_candidates": [{"code": "def hex_key(num: str) -> int:\n    \"\"\"\n    Counts the number of hexadecimal digits in the given string that are prime numbers.\n    \n    Parameters:\n    num (str): A string representing a hexadecimal number.\n    \n    Returns:\n    int: The count of prime hexadecimal digits in the string.\n    \"\"\"\n    # Define the prime hexadecimal digits\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count the occurrences of prime digits in the input string\n    count = 0\n    for char in num.upper():\n        if char in prime_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["1", "2", "4", "2", "6", "12", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/79_prompt1p", "code_candidates": [{"code": "def decimal_to_binary(decimal: int) -> str:\n    \"\"\"\n    Converts a given decimal number to its binary representation as a string.\n    The binary string will have an extra 'db' prefix.\n\n    Args:\n        decimal (int): The decimal number to convert.\n\n    Returns:\n        str: The binary representation of the decimal number with 'db' prefix.\n    \"\"\"\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    if decimal == 0:\n        return \"db0\"\n    \n    binary_str = \"\"\n    while decimal > 0:\n        binary_str = str(decimal % 2) + binary_str\n        decimal = decimal // 2\n    \n    return \"db\" + binary_str", "index": 0, "passed_case": [], "case_status": ["db0", "db100000", "db1100111", "db1111"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/80_prompt1p", "code_candidates": [{"code": "def is_happy(s: str) -> bool:\n    if not s:\n        return False\n    # Remove all non-alphanumeric characters and convert to lowercase\n    cleaned_s = ''.join(char.lower() for char in s if char.isalnum())\n    return 'happy' in cleaned_s", "index": 0, "passed_case": [0, 1, 3, 5, 7], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/81_prompt1p", "code_candidates": [{"code": "def numerical_letter_grade(grades):\n    \"\"\"\n    Converts a list of numerical GPAs to corresponding letter grades based on the following table:\n    \n    GPA Range:\n    4.0 - 3.7: A\n    3.69 - 3.3: B+\n    3.29 - 3.0: B\n    2.99 - 2.7: C+\n    2.69 - 2.3: C\n    2.29 - 2.0: D\n    Below 2.0: F\n    \n    Parameters:\n    grades (list of float): A list of numerical GPAs.\n    \n    Returns:\n    list of str: A list of corresponding letter grades.\n    \"\"\"\n    letter_grades = []\n    for gpa in grades:\n        if gpa >= 4.0:\n            letter_grades.append(\"A\")\n        elif 3.7 <= gpa < 4.0:\n            letter_grades.append(\"A\")\n        elif 3.3 <= gpa < 3.7:\n            letter_grades.append(\"B+\")\n        elif 3.0 <= gpa < 3.3:\n            letter_grades.append(\"B\")\n        elif 2.7 <= gpa < 3.0:\n            letter_grades.append(\"C+\")\n        elif 2.3 <= gpa < 2.7:\n            letter_grades.append(\"C\")\n        elif 2.0 <= gpa < 2.3:\n            letter_grades.append(\"D\")\n        else:\n            letter_grades.append(\"F\")\n    return letter_grades", "index": 0, "passed_case": [], "case_status": ["['A', 'B', 'F', 'D', 'B+']", "['F']", "['F']", "['F']", "['F', 'F', 'F', 'C+', 'B+']", "['F', 'F']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/82_prompt1p", "code_candidates": [{"code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_length(string):\n    length = len(string)\n    return is_prime(length)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/83_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef generate_n_digit_numbers(n: int) -> List[int]:\n    if n < 2:\n        return []\n    \n    numbers = []\n    start = 10**(n-1) + 1\n    end = 10**n\n    for num in range(start, end, 10):\n        numbers.append(num)\n    \n    return numbers", "index": 0, "passed_case": [], "case_status": ["[]", "[11, 21, 31, 41, 51, 61, 71, 81, 91]", "[101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, 211, 221, 231, 241, 251, 261, 271, 281, 291, 301, 311, 321, 331, 341, 351, 361, 371, 381, 391, 401, 411, 421, 431, 441, 451, 461, 471, 481, 491, 501, 511, 521, 531, 541, 551, 561, 571, 581, 591, 601, 611, 621, 631, 641, 651, 661, 671, 681, 691, 701, 711, 721, 731, 741, 751, 761, 771, 781, 791, 801, 811, 821, 831, 841, 851, 861, 871, 881, 891, 901, 911, 921, 931, 941, 951, 961, 971, 981, 991]", "[1001, 1011, 1021, 1031, 1041, 1051, 1061, 1071, 1081, 1091, 1101, 1111, 1121, 1131, 1141, 1151, 1161, 1171, 1181, 1191, 1201, 1211, 1221, 1231, 1241, 1251, 1261, 1271, 1281, 1291, 1301, 1311, 1321, 1331, 1341, 1351, 1361, 1371, 1381, 1391, 1401, 1411, 1421, 1431, 1441, 1451, 1461, 1471, 1481, 1491, 1501, 1511, 1521, 1531, 1541, 1551, 1561, 1571, 1581, 1591, 1601, 1611, 1621, 1631, 1641, 1651, 1661, 1671, 1681, 1691, 1701, 1711, 1721, 1731, 1741, 1751, 1761, 1771, 1781, 1791, 1801, 1811, 1821, 1831, 1841, 1851, 1861, 1871, 1881, 1891, 1901, 1911, 1921, 1931, 1941, 1951, 1961, 1971, 1981, 1991, 2001, 2011, 2021, 2031, 2041, 2051, 2061, 2071, 2081, 2091, 2101, 2111, 2121, 2131, 2141, 2151, 2161, 2171, 2181, 2191, 2201, 2211, 2221, 2231, 2241, 2251, 2261, 2271, 2281, 2291, 2301, 2311, 2321, 2331, 2341, 2351, 2361, 2371, 2381, 2391, 2401, 2411, 2421, 2431, 2441, 2451, 2461, 2471, 2481, 2491, 2501, 2511, 2521, 2531, 2541, 2551, 2561, 2571, 2581, 2591, 2601, 2611, 2621, 2631, 2641, 2651, 2661, 2671, 2681, 2691, 2701, 2711, 2721, 2731, 2741, 2751, 2761, 2771, 2781, 2791, 2801, 2811, 2821, 2831, 2841, 2851, 2861, 2871, 2881, 2891, 2901, 2911, 2921, 2931, 2941, 2951, 2961, 2971, 2981, 2991, 3001, 3011, 3021, 3031, 3041, 3051, 3061, 3071, 3081, 3091, 3101, 3111, 3121, 3131, 3141, 3151, 3161, 3171, 3181, 3191, 3201, 3211, 3221, 3231, 3241, 3251, 3261, 3271, 3281, 3291, 3301, 3311, 3321, 3331, 3341, 3351, 3361, 3371, 3381, 3391, 3401, 3411, 3421, 3431, 3441, 3451, 3461, 3471, 3481, 3491, 3501, 3511, 3521, 3531, 3541, 3551, 3561, 3571, 3581, 3591, 3601, 3611, 3621, 3631, 3641, 3651, 3661, 3671, 3681, 3691, 3701, 3711, 3721, 3731, 3741, 3751, 3761, 3771, 3781, 3791, 3801, 3811, 3821, 3831, 3841, 3851, 3861, 3871, 3881, 3891, 3901, 3911, 3921, 3931, 3941, 3951, 3961, 3971, 3981, 3991, 4001, 4011, 4021, 4031, 4041, 4051, 4061, 4071, 4081, 4091, 4101, 4111, 4121, 4131, 4141, 4151, 4161, 4171, 4181, 4191, 4201, 4211, 4221, 4231, 4241, 4251, 4261, 4271, 4281, 4291, 4301, 4311, 4321, 4331, 4341, 4351, 4361, 4371, 4381, 4391, 4401, 4411, 4421, 4431, 4441, 4451, 4461, 4471, 4481, 4491, 4501, 4511, 4521, 4531, 4541, 4551, 4561, 4571, 4581, 4591, 4601, 4611, 4621, 4631, 4641, 4651, 4661, 4671, 4681, 4691, 4701, 4711, 4721, 4731, 4741, 4751, 4761, 4771, 4781, 4791, 4801, 4811, 4821, 4831, 4841, 4851, 4861, 4871, 4881, 4891, 4901, 4911, 4921, 4931, 4941, 4951, 4961, 4971, 4981, 4991, 5001, 5011, 5021, 5031, 5041, 5051, 5061, 5071, 5081, 5091, 5101, 5111, 5121, 5131, 5141, 5151, 5161, 5171, 5181, 5191, 5201, 5211, 5221, 5231, 5241, 5251, 5261, 5271, 5281, 5291, 5301, 5311, 5321, 5331, 5341, 5351, 5361, 5371, 5381, 5391, 5401, 5411, 5421, 5431, 5441, 5451, 5461, 5471, 5481, 5491, 5501, 5511, 5521, 5531, 5541, 5551, 5561, 5571, 5581, 5591, 5601, 5611, 5621, 5631, 5641, 5651, 5661, 5671, 5681, 5691, 5701, 5711, 5721, 5731, 5741, 5751, 5761, 5771, 5781, 5791, 5801, 5811, 5821, 5831, 5841, 5851, 5861, 5871, 5881, 5891, 5901, 5911, 5921, 5931, 5941, 5951, 5961, 5971, 5981, 5991, 6001, 6011, 6021, 6031, 6041, 6051, 6061, 6071, 6081, 6091, 6101, 6111, 6121, 6131, 6141, 6151, 6161, 6171, 6181, 6191, 6201, 6211, 6221, 6231, 6241, 6251, 6261, 6271, 6281, 6291, 6301, 6311, 6321, 6331, 6341, 6351, 6361, 6371, 6381, 6391, 6401, 6411, 6421, 6431, 6441, 6451, 6461, 6471, 6481, 6491, 6501, 6511, 6521, 6531, 6541, 6551, 6561, 6571, 6581, 6591, 6601, 6611, 6621, 6631, 6641, 6651, 6661, 6671, 6681, 6691, 6701, 6711, 6721, 6731, 6741, 6751, 6761, 6771, 6781, 6791, 6801, 6811, 6821, 6831, 6841, 6851, 6861, 6871, 6881, 6891, 6901, 6911, 6921, 6931, 6941, 6951, 6961, 6971, 6981, 6991, 7001, 7011, 7021, 7031, 7041, 7051, 7061, 7071, 7081, 7091, 7101, 7111, 7121, 7131, 7141, 7151, 7161, 7171, 7181, 7191, 7201, 7211, 7221, 7231, 7241, 7251, 7261, 7271, 7281, 7291, 7301, 7311, 7321, 7331, 7341, 7351, 7361, 7371, 7381, 7391, 7401, 7411, 7421, 7431, 7441, 7451, 7461, 7471, 7481, 7491, 7501, 7511, 7521, 7531, 7541, 7551, 7561, 7571, 7581, 7591, 7601, 7611, 7621, 7631, 7641, 7651, 7661, 7671, 7681, 7691, 7701, 7711, 7721, 7731, 7741, 7751, 7761, 7771, 7781, 7791, 7801, 7811, 7821, 7831, 7841, 7851, 7861, 7871, 7881, 7891, 7901, 7911, 7921, 7931, 7941, 7951, 7961, 7971, 7981, 7991, 8001, 8011, 8021, 8031, 8041, 8051, 8061, 8071, 8081, 8091, 8101, 8111, 8121, 8131, 8141, 8151, 8161, 8171, 8181, 8191, 8201, 8211, 8221, 8231, 8241, 8251, 8261, 8271, 8281, 8291, 8301, 8311, 8321, 8331, 8341, 8351, 8361, 8371, 8381, 8391, 8401, 8411, 8421, 8431, 8441, 8451, 8461, 8471, 8481, 8491, 8501, 8511, 8521, 8531, 8541, 8551, 8561, 8571, 8581, 8591, 8601, 8611, 8621, 8631, 8641, 8651, 8661, 8671, 8681, 8691, 8701, 8711, 8721, 8731, 8741, 8751, 8761, 8771, 8781, 8791, 8801, 8811, 8821, 8831, 8841, 8851, 8861, 8871, 8881, 8891, 8901, 8911, 8921, 8931, 8941, 8951, 8961, 8971, 8981, 8991, 9001, 9011, 9021, 9031, 9041, 9051, 9061, 9071, 9081, 9091, 9101, 9111, 9121, 9131, 9141, 9151, 9161, 9171, 9181, 9191, 9201, 9211, 9221, 9231, 9241, 9251, 9261, 9271, 9281, 9291, 9301, 9311, 9321, 9331, 9341, 9351, 9361, 9371, 9381, 9391, 9401, 9411, 9421, 9431, 9441, 9451, 9461, 9471, 9481, 9491, 9501, 9511, 9521, 9531, 9541, 9551, 9561, 9571, 9581, 9591, 9601, 9611, 9621, 9631, 9641, 9651, 9661, 9671, 9681, 9691, 9701, 9711, 9721, 9731, 9741, 9751, 9761, 9771, 9781, 9791, 9801, 9811, 9821, 9831, 9841, 9851, 9861, 9871, 9881, 9891, 9901, 9911, 9921, 9931, 9941, 9951, 9961, 9971, 9981, 9991]", "[10001, 10011, 10021, 10031, 10041, 10051, 10061, 10071, 10081, 10091, 10101, 10111, 10121, 10131, 10141, 10151, 10161, 10171, 10181, 10191, 10201, 10211, 10221, 10231, 10241, 10251, 10261, 10271, 10281, 10291, 10301, 10311, 10321, 10331, 10341, 10351, 10361, 10371, 10381, 10391, 10401, 10411, 10421, 10431, 10441, 10451, 10461, 10471, 10481, 10491, 10501, 10511, 10521, 10531, 10541, 10551, 10561, 10571, 10581, 10591, 10601, 10611, 10621, 10631, 10641, 10651, 10661, 10671, 10681, 10691, 10701, 10711, 10721, 10731, 10741, 10751, 10761, 10771, 10781, 10791, 10801, 10811, 10821, 10831, 10841, 10851, 10861, 10871, 10881, 10891, 10901, 10911, 10921, 10931, 10941, 10951, 10961, 10971, 10981, 10991, 11001, 11011, 11021, 11031, 11041, 11051, 11061, 11071, 11081, 11091, 11101, 11111, 11121, 11131, 11141, 11151, 11161, 11171, 11181, 11191, 11201, 11211, 11221, 11231, 11241, 11251, 11261, 11271, 11281, 11291, 11301, 11311, 11321, 11331, 11341, 11351, 11361, 11371, 11381, 11391, 11401, 11411, 11421, 11431, 11441, 11451, 11461, 11471, 11481, 11491, 11501, 11511, 11521, 11531, 11541, 11551, 11561, 11571, 11581, 11591, 11601, 11611, 11621, 11631, 11641, 11651, 11661, 11671, 11681, 11691, 11701, 11711, 11721, 11731, 11741, 11751, 11761, 11771, 11781, 11791, 11801, 11811, 11821, 11831, 11841, 11851, 11861, 11871, 11881, 11891, 11901, 11911, 11921, 11931, 11941, 11951, 11961, 11971, 11981, 11991, 12001, 12011, 12021, 12031, 12041, 12051, 12061, 12071, 12081, 12091, 12101, 12111, 12121, 12131, 12141, 12151, 12161, 12171, 12181, 12191, 12201, 12211, 12221, 12231, 12241, 12251, 12261, 12271, 12281, 12291, 12301, 12311, 12321, 12331, 12341, 12351, 12361, 12371, 12381, 12391, 12401, 12411, 12421, 12431, 12441, 12451, 12461, 12471, 12481, 12491, 12501, 12511, 12521, 12531, 12541, 12551, 12561, 12571, 12581, 12591, 12601, 12611, 12621, 12631, 12641, 12651, 12661, 12671, 12681, 12691, 12701, 12711, 12721, 12731, 12741, 12751, 12761, 12771, 12781, 12791, 12801, 12811, 12821, 12831, 12841, 12851, 12861, 12871, 12881, 12891, 12901, 12911, 12921, 12931, 12941, 12951, 12961, 12971, 12981, 12991, 13001, 13011, 13021, 13031, 13041, 13051, 13061, 13071, 13081, 13091, 13101, 13111, 13121, 13131, 13141, 13151, 13161, 13171, 13181, 13191, 13201, 13211, 13221, 13231, 13241, 13251, 13261, 13271, 13281, 13291, 13301, 13311, 13321, 13331, 13341, 13351, 13361, 13371, 13381, 13391, 13401, 13411, 13421, 13431, 13441, 13451, 13461, 13471, 13481, 13491, 13501, 13511, 13521, 13531, 13541, 13551, 13561, 13571, 13581, 13591, 13601, 13611, 13621, 13631, 13641, 13651, 13661, 13671, 13681, 13691, 13701, 13711, 13721, 13731, 13741, 13751, 13761, 13771, 13781, 13791, 13801, 13811, 13821, 13831, 13841, 13851, 13861, 13871, 13881, 13891, 13901, 13911, 13921, 13931, 13941, 13951, 13961, 13971, 13981, 13991, 14001, 14011, 14021, 14031, 14041, 14051, 14061, 14071, 14081, 14091, 14101, 14111, 14121, 14131, 14141, 14151, 14161, 14171, 14181, 14191, 14201, 14211, 14221, 14231, 14241, 14251, 14261, 14271, 14281, 14291, 14301, 14311, 14321, 14331, 14341, 14351, 14361, 14371, 14381, 14391, 14401, 14411, 14421, 14431, 14441, 14451, 14461, 14471, 14481, 14491, 14501, 14511, 14521, 14531, 14541, 14551, 14561, 14571, 14581, 14591, 14601, 14611, 14621, 14631, 14641, 14651, 14661, 14671, 14681, 14691, 14701, 14711, 14721, 14731, 14741, 14751, 14761, 14771, 14781, 14791, 14801, 14811, 14821, 14831, 14841, 14851, 14861, 14871, 14881, 14891, 14901, 14911, 14921, 14931, 14941, 14951, 14961, 14971, 14981, 14991, 15001, 15011, 15021, 15031, 15041, 15051, 15061, 15071, 15081, 15091, 15101, 15111, 15121, 15131, 15141, 15151, 15161, 15171, 15181, 15191, 15201, 15211, 15221, 15231, 15241, 15251, 15261, 15271, 15281, 15291, 15301, 15311, 15321, 15331, 15341, 15351, 15361, 15371, 15381, 15391, 15401, 15411, 15421, 15431, 15441, 15451, 15461, 15471, 15481, 15491, 15501, 15511, 15521, 15531, 15541, 15551, 15561, 15571, 15581, 15591, 15601, 15611, 15621, 15631, 15641, 15651, 15661, 15671, 15681, 15691, 15701, 15711, 15721, 15731, 15741, 15751, 15761, 15771, 15781, 15791, 15801, 15811, 15821, 15831, 15841, 15851, 15861, 15871, 15881, 15891, 15901, 15911, 15921, 15931, 15941, 15951, 15961, 15971, 15981, 15991, 16001, 16011, 16021, 16031, 16041, 16051, 16061, 16071, 16081, 16091, 16101, 16111, 16121, 16131, 16141, 16151, 16161, 16171, 16181, 16191, 16201, 16211, 16221, 16231, 16241, 16251, 16261, 16271, 16281, 16291, 16301, 16311, 16321, 16331, 16341, 16351, 16361, 16371, 16381, 16391, 16401, 16411, 16421, 16431, 16441, 16451, 16461, 16471, 16481, 16491, 16501, 16511, 16521, 16531, 16541, 16551, 16561, 16571, 16581, 16591, 16601, 16611, 16621, 16631, 16641, 16651, 16661, 16671, 16681, 16691, 16701, 16711, 16721, 16731, 16741, 16751, 16761, 16771, 16781, 16791, 16801, 16811, 16821, 16831, 16841, 16851, 16861, 16871, 16881, 16891, 16901, 16911, 16921, 16931, 16941, 16951, 16961, 16971, 16981, 16991, 17001, 17011, 17021, 17031, 17041, 17051, 17061, 17071, 17081, 17091, 17101, 17111, 17121, 17131, 17141, 17151, 17161, 17171, 17181, 17191, 17201, 17211, 17221, 17231, 17241, 17251, 17261, 17271, 17281, 17291, 17301, 17311, 17321, 17331, 17341, 17351, 17361, 17371, 17381, 17391, 17401, 17411, 17421, 17431, 17441, 17451, 17461, 17471, 17481, 17491, 17501, 17511, 17521, 17531, 17541, 17551, 17561, 17571, 17581, 17591, 17601, 17611, 17621, 17631, 17641, 17651, 17661, 17671, 17681, 17691, 17701, 17711, 17721, 17731, 17741, 17751, 17761, 17771, 17781, 17791, 17801, 17811, 17821, 17831, 17841, 17851, 17861, 17871, 17881, 17891, 17901, 17911, 17921, 17931, 17941, 17951, 17961, 17971, 17981, 17991, 18001, 18011, 18021, 18031, 18041, 18051, 18061, 18071, 18081, 18091, 18101, 18111, 18121, 18131, 18141, 18151, 18161, 18171, 18181, 18191, 18201, 18211, 18221, 18231, 18241, 18251, 18261, 18271, 18281, 18291, 18301, 18311, 18321, 18331, 18341, 18351, 18361, 18371, 18381, 18391, 18401, 18411, 18421, 18431, 18441, 18451, 18461, 18471, 18481, 18491, 18501, 18511, 18521, 18531, 18541, 18551, 18561, 18571, 18581, 18591, 18601, 18611, 18621, 18631, 18641, 18651, 18661, 18671, 18681, 18691, 18701, 18711, 18721, 18731, 18741, 18751, 18761, 18771, 18781, 18791, 18801, 18811, 18821, 18831, 18841, 18851, 18861, 18871, 18881, 18891, 18901, 18911, 18921, 18931, 18941, 18951, 18961, 18971, 18981, 18991, 19001, 19011, 19021, 19031, 19041, 19051, 19061, 19071, 19081, 19091, 19101, 19111, 19121, 19131, 19141, 19151, 19161, 19171, 19181, 19191, 19201, 19211, 19221, 19231, 19241, 19251, 19261, 19271, 19281, 19291, 19301, 19311, 19321, 19331, 19341, 19351, 19361, 19371, 19381, 19391, 19401, 19411, 19421, 19431, 19441, 19451, 19461, 19471, 19481, 19491, 19501, 19511, 19521, 19531, 19541, 19551, 19561, 19571, 19581, 19591, 19601, 19611, 19621, 19631, 19641, 19651, 19661, 19671, 19681, 19691, 19701, 19711, 19721, 19731, 19741, 19751, 19761, 19771, 19781, 19791, 19801, 19811, 19821, 19831, 19841, 19851, 19861, 19871, 19881, 19891, 19901, 19911, 19921, 19931, 19941, 19951, 19961, 19971, 19981, 19991, 20001, 20011, 20021, 20031, 20041, 20051, 20061, 20071, 20081, 20091, 20101, 20111, 20121, 20131, 20141, 20151, 20161, 20171, 20181, 20191, 20201, 20211, 20221, 20231, 20241, 20251, 20261, 20271, 20281, 20291, 20301, 20311, 20321, 20331, 20341, 20351, 20361, 20371, 20381, 20391, 20401, 20411, 20421, 20431, 20441, 20451, 20461, 20471, 20481, 20491, 20501, 20511, 20521, 20531, 20541, 20551, 20561, 20571, 20581, 20591, 20601, 20611, 20621, 20631, 20641, 20651, 20661, 20671, 20681, 20691, 20701, 20711, 20721, 20731, 20741, 20751, 20761, 20771, 20781, 20791, 20801, 20811, 20821, 20831, 20841, 20851, 20861, 20871, 20881, 20891, 20901, 20911, 20921, 20931, 20941, 20951, 20961, 20971, 20981, 20991, 21001, 21011, 21021, 21031, 21041, 21051, 21061, 21071, 21081, 21091, 21101, 21111, 21121, 21131, 21141, 21151, 21161, 21171, 21181, 21191, 21201, 21211, 21221, 21231, 21241, 21251, 21261, 21271, 21281, 21291, 21301, 21311, 21321, 21331, 21341, 21351, 21361, 21371, 21381, 21391, 21401, 21411, 21421, 21431, 21441, 21451, 21461, 21471, 21481, 21491, 21501, 21511, 21521, 21531, 21541, 21551, 21561, 21571, 21581, 21591, 21601, 21611, 21621, 21631, 21641, 21651, 21661, 21671, 21681, 21691, 21701, 21711, 21721, 21731, 21741, 21751, 21761, 21771, 21781, 21791, 21801, 21811, 21821, 21831, 21841, 21851, 21861, 21871, 21881, 21891, 21901, 21911, 21921, 21931, 21941, 21951, 21961, 21971, 21981, 21991, 22001, 22011, 22021, 22031, 22041, 22051, 22061, 22071, 22081, 22091, 22101, 22111, 22121, 22131, 22141, 22151, 22161, 22171, 22181, 22191, 22201, 22211, 22221, 22231, 22241, 22251, 22261, 22271, 22281, 22291, 22301, 22311, 22321, 22331, 22341, 22351, 22361, 22371, 22381, 22391, 22401, 22411, 22421, 22431, 22441, 22451, 22461, 22471, 22481, 22491, 22501, 22511, 22521, 22531, 22541, 22551, 22561, 22571, 22581, 22591, 22601, 22611, 22621, 22631, 22641, 22651, 22661, 22671, 22681, 22691, 22701, 22711, 22721, 22731, 22741, 22751, 22761, 22771, 22781, 22791, 22801, 22811, 22821, 22831, 22841, 22851, 22861, 22871, 22881, 22891, 22901, 22911, 22921, 22931, 22941, 22951, 22961, 22971, 22981, 22991, 23001, 23011, 23021, 23031, 23041, 23051, 23061, 23071, 23081, 23091, 23101, 23111, 23121, 23131, 23141, 23151, 23161, 23171, 23181, 23191, 23201, 23211, 23221, 23231, 23241, 23251, 23261, 23271, 23281, 23291, 23301, 23311, 23321, 23331, 23341, 23351, 23361, 23371, 23381, 23391, 23401, 23411, 23421, 23431, 23441, 23451, 23461, 23471, 23481, 23491, 23501, 23511, 23521, 23531, 23541, 23551, 23561, 23571, 23581, 23591, 23601, 23611, 23621, 23631, 23641, 23651, 23661, 23671, 23681, 23691, 23701, 23711, 23721, 23731, 23741, 23751, 23761, 23771, 23781, 23791, 23801, 23811, 23821, 23831, 23841, 23851, 23861, 23871, 23881, 23891, 23901, 23911, 23921, 23931, 23941, 23951, 23961, 23971, 23981, 23991, 24001, 24011, 24021, 24031, 24041, 24051, 24061, 24071, 24081, 24091, 24101, 24111, 24121, 24131, 24141, 24151, 24161, 24171, 24181, 24191, 24201, 24211, 24221, 24231, 24241, 24251, 24261, 24271, 24281, 24291, 24301, 24311, 24321, 24331, 24341, 24351, 24361, 24371, 24381, 24391, 24401, 24411, 24421, 24431, 24441, 24451, 24461, 24471, 24481, 24491, 24501, 24511, 24521, 24531, 24541, 24551, 24561, 24571, 24581, 24591, 24601, 24611, 24621, 24631, 24641, 24651, 24661, 24671, 24681, 24691, 24701, 24711, 24721, 24731, 24741, 24751, 24761, 24771, 24781, 24791, 24801, 24811, 24821, 24831, 24841, 24851, 24861, 24871, 24881, 24891, 24901, 24911, 24921, 24931, 24941, 24951, 24961, 24971, 24981, 24991, 25001, 25011, 25021, 25031, 25041, 25051, 25061, 25071, 25081, 25091, 25101, 25111, 25121, 25131, 25141, 25151, 25161, 25171, 25181, 25191, 25201, 25211, 25221, 25231, 25241, 25251, 25261, 25271, 25281, 25291, 25301, 25311, 25321, 25331, 25341, 25351, 25361, 25371, 25381, 25391, 25401, 25411, 25421, 25431, 25441, 25451, 25461, 25471, 25481, 25491, 25501, 25511, 25521, 25531, 25541, 25551, 25561, 25571, 25581, 25591, 25601, 25611, 25621, 25631, 25641, 25651, 25661, 25671, 25681, 25691, 25701, 25711, 25721, 25731, 25741, 25751, 25761, 25771, 25781, 25791, 25801, 25811, 25821, 25831, 25841, 25851, 25861, 25871, 25881, 25891, 25901, 25911, 25921, 25931, 25941, 25951, 25961, 25971, 25981, 25991, 26001, 26011, 26021, 26031, 26041, 26051, 26061, 26071, 26081, 26091, 26101, 26111, 26121, 26131, 26141, 26151, 26161, 26171, 26181, 26191, 26201, 26211, 26221, 26231, 26241, 26251, 26261, 26271, 26281, 26291, 26301, 26311, 26321, 26331, 26341, 26351, 26361, 26371, 26381, 26391, 26401, 26411, 26421, 26431, 26441, 26451, 26461, 26471, 26481, 26491, 26501, 26511, 26521, 26531, 26541, 26551, 26561, 26571, 26581, 26591, 26601, 26611, 26621, 26631, 26641, 26651, 26661, 26671, 26681, 26691, 26701, 26711, 26721, 26731, 26741, 26751, 26761, 26771, 26781, 26791, 26801, 26811, 26821, 26831, 26841, 26851, 26861, 26871, 26881, 26891, 26901, 26911, 26921, 26931, 26941, 26951, 26961, 26971, 26981, 26991, 27001, 27011, 27021, 27031, 27041, 27051, 27061, 27071, 27081, 27091, 27101, 27111, 27121, 27131, 27141, 27151, 27161, 27171, 27181, 27191, 27201, 27211, 27221, 27231, 27241, 27251, 27261, 27271, 27281, 27291, 27301, 27311, 27321, 27331, 27341, 27351, 27361, 27371, 27381, 27391, 27401, 27411, 27421, 27431, 27441, 27451, 27461, 27471, 27481, 27491, 27501, 27511, 27521, 27531, 27541, 27551, 27561, 27571, 27581, 27591, 27601, 27611, 27621, 27631, 27641, 27651, 27661, 27671, 27681, 27691, 27701, 27711, 27721, 27731, 27741, 27751, 27761, 27771, 27781, 27791, 27801, 27811, 27821, 27831, 27841, 27851, 27861, 27871, 27881, 27891, 27901, 27911, 27921, 27931, 27941, 27951, 27961, 27971, 27981, 27991, 28001, 28011, 28021, 28031, 28041, 28051, 28061, 28071, 28081, 28091, 28101, 28111, 28121, 28131, 28141, 28151, 28161, 28171, 28181, 28191, 28201, 28211, 28221, 28231, 28241, 28251, 28261, 28271, 28281, 28291, 28301, 28311, 28321, 28331, 28341, 28351, 28361, 28371, 28381, 28391, 28401, 28411, 28421, 28431, 28441, 28451, 28461, 28471, 28481, 28491, 28501, 28511, 28521, 28531, 28541, 28551, 28561, 28571, 28581, 28591, 28601, 28611, 28621, 28631, 28641, 28651, 28661, 28671, 28681, 28691, 28701, 28711, 28721, 28731, 28741, 28751, 28761, 28771, 28781, 28791, 28801, 28811, 28821, 28831, 28841, 28851, 28861, 28871, 28881, 28891, 28901, 28911, 28921, 28931, 28941, 28951, 28961, 28971, 28981, 28991, 29001, 29011, 29021, 29031, 29041, 29051, 29061, 29071, 29081, 29091, 29101, 29111, 29121, 29131, 29141, 29151, 29161, 29171, 29181, 29191, 29201, 29211, 29221, 29231, 29241, 29251, 29261, 29271, 29281, 29291, 29301, 29311, 29321, 29331, 29341, 29351, 29361, 29371, 29381, 29391, 29401, 29411, 29421, 29431, 29441, 29451, 29461, 29471, 29481, 29491, 29501, 29511, 29521, 29531, 29541, 29551, 29561, 29571, 29581, 29591, 29601, 29611, 29621, 29631, 29641, 29651, 29661, 29671, 29681, 29691, 29701, 29711, 29721, 29731, 29741, 29751, 29761, 29771, 29781, 29791, 29801, 29811, 29821, 29831, 29841, 29851, 29861, 29871, 29881, 29891, 29901, 29911, 29921, 29931, 29941, 29951, 29961, 29971, 29981, 29991, 30001, 30011, 30021, 30031, 30041, 30051, 30061, 30071, 30081, 30091, 30101, 30111, 30121, 30131, 30141, 30151, 30161, 30171, 30181, 30191, 30201, 30211, 30221, 30231, 30241, 30251, 30261, 30271, 30281, 30291, 30301, 30311, 30321, 30331, 30341, 30351, 30361, 30371, 30381, 30391, 30401, 30411, 30421, 30431, 30441, 30451, 30461, 30471, 30481, 30491, 30501, 30511, 30521, 30531, 30541, 30551, 30561, 30571, 30581, 30591, 30601, 30611, 30621, 30631, 30641, 30651, 30661, 30671, 30681, 30691, 30701, 30711, 30721, 30731, 30741, 30751, 30761, 30771, 30781, 30791, 30801, 30811, 30821, 30831, 30841, 30851, 30861, 30871, 30881, 30891, 30901, 30911, 30921, 30931, 30941, 30951, 30961, 30971, 30981, 30991, 31001, 31011, 31021, 31031, 31041, 31051, 31061, 31071, 31081, 31091, 31101, 31111, 31121, 31131, 31141, 31151, 31161, 31171, 31181, 31191, 31201, 31211, 31221, 31231, 31241, 31251, 31261, 31271, 31281, 31291, 31301, 31311, 31321, 31331, 31341, 31351, 31361, 31371, 31381, 31391, 31401, 31411, 31421, 31431, 31441, 31451, 31461, 31471, 31481, 31491, 31501, 31511, 31521, 31531, 31541, 31551, 31561, 31571, 31581, 31591, 31601, 31611, 31621, 31631, 31641, 31651, 31661, 31671, 31681, 31691, 31701, 31711, 31721, 31731, 31741, 31751, 31761, 31771, 31781, 31791, 31801, 31811, 31821, 31831, 31841, 31851, 31861, 31871, 31881, 31891, 31901, 31911, 31921, 31931, 31941, 31951, 31961, 31971, 31981, 31991, 32001, 32011, 32021, 32031, 32041, 32051, 32061, 32071, 32081, 32091, 32101, 32111, 32121, 32131, 32141, 32151, 32161, 32171, 32181, 32191, 32201, 32211, 32221, 32231, 32241, 32251, 32261, 32271, 32281, 32291, 32301, 32311, 32321, 32331, 32341, 32351, 32361, 32371, 32381, 32391, 32401, 32411, 32421, 32431, 32441, 32451, 32461, 32471, 32481, 32491, 32501, 32511, 32521, 32531, 32541, 32551, 32561, 32571, 32581, 32591, 32601, 32611, 32621, 32631, 32641, 32651, 32661, 32671, 32681, 32691, 32701, 32711, 32721, 32731, 32741, 32751, 32761, 32771, 32781, 32791, 32801, 32811, 32821, 32831, 32841, 32851, 32861, 32871, 32881, 32891, 32901, 32911, 32921, 32931, 32941, 32951, 32961, 32971, 32981, 32991, 33001, 33011, 33021, 33031, 33041, 33051, 33061, 33071, 33081, 33091, 33101, 33111, 33121, 33131, 33141, 33151, 33161, 33171, 33181, 33191, 33201, 33211, 33221, 33231, 33241, 33251, 33261, 33271, 33281, 33291, 33301, 33311, 33321, 33331, 33341, 33351, 33361, 33371, 33381, 33391, 33401, 33411, 33421, 33431, 33441, 33451, 33461, 33471, 33481, 33491, 33501, 33511, 33521, 33531, 33541, 33551, 33561, 33571, 33581, 33591, 33601, 33611, 33621, 33631, 33641, 33651, 33661, 33671, 33681, 33691, 33701, 33711, 33721, 33731, 33741, 33751, 33761, 33771, 33781, 33791, 33801, 33811, 33821, 33831, 33841, 33851, 33861, 33871, 33881, 33891, 33901, 33911, 33921, 33931, 33941, 33951, 33961, 33971, 33981, 33991, 34001, 34011, 34021, 34031, 34041, 34051, 34061, 34071, 34081, 34091, 34101, 34111, 34121, 34131, 34141, 34151, 34161, 34171, 34181, 34191, 34201, 34211, 34221, 34231, 34241, 34251, 34261, 34271, 34281, 34291, 34301, 34311, 34321, 34331, 34341, 34351, 34361, 34371, 34381, 34391, 34401, 34411, 34421, 34431, 34441, 34451, 34461, 34471, 34481, 34491, 34501, 34511, 34521, 34531, 34541, 34551, 34561, 34571, 34581, 34591, 34601, 34611, 34621, 34631, 34641, 34651, 34661, 34671, 34681, 34691, 34701, 34711, 34721, 34731, 34741, 34751, 34761, 34771, 34781, 34791, 34801, 34811, 34821, 34831, 34841, 34851, 34861, 34871, 34881, 34891, 34901, 34911, 34921, 34931, 34941, 34951, 34961, 34971, 34981, 34991, 35001, 35011, 35021, 35031, 35041, 35051, 35061, 35071, 35081, 35091, 35101, 35111, 35121, 35131, 35141, 35151, 35161, 35171, 35181, 35191, 35201, 35211, 35221, 35231, 35241, 35251, 35261, 35271, 35281, 35291, 35301, 35311, 35321, 35331, 35341, 35351, 35361, 35371, 35381, 35391, 35401, 35411, 35421, 35431, 35441, 35451, 35461, 35471, 35481, 35491, 35501, 35511, 35521, 35531, 35541, 35551, 35561, 35571, 35581, 35591, 35601, 35611, 35621, 35631, 35641, 35651, 35661, 35671, 35681, 35691, 35701, 35711, 35721, 35731, 35741, 35751, 35761, 35771, 35781, 35791, 35801, 35811, 35821, 35831, 35841, 35851, 35861, 35871, 35881, 35891, 35901, 35911, 35921, 35931, 35941, 35951, 35961, 35971, 35981, 35991, 36001, 36011, 36021, 36031, 36041, 36051, 36061, 36071, 36081, 36091, 36101, 36111, 36121, 36131, 36141, 36151, 36161, 36171, 36181, 36191, 36201, 36211, 36221, 36231, 36241, 36251, 36261, 36271, 36281, 36291, 36301, 36311, 36321, 36331, 36341, 36351, 36361, 36371, 36381, 36391, 36401, 36411, 36421, 36431, 36441, 36451, 36461, 36471, 36481, 36491, 36501, 36511, 36521, 36531, 36541, 36551, 36561, 36571, 36581, 36591, 36601, 36611, 36621, 36631, 36641, 36651, 36661, 36671, 36681, 36691, 36701, 36711, 36721, 36731, 36741, 36751, 36761, 36771, 36781, 36791, 36801, 36811, 36821, 36831, 36841, 36851, 36861, 36871, 36881, 36891, 36901, 36911, 36921, 36931, 36941, 36951, 36961, 36971, 36981, 36991, 37001, 37011, 37021, 37031, 37041, 37051, 37061, 37071, 37081, 37091, 37101, 37111, 37121, 37131, 37141, 37151, 37161, 37171, 37181, 37191, 37201, 37211, 37221, 37231, 37241, 37251, 37261, 37271, 37281, 37291, 37301, 37311, 37321, 37331, 37341, 37351, 37361, 37371, 37381, 37391, 37401, 37411, 37421, 37431, 37441, 37451, 37461, 37471, 37481, 37491, 37501, 37511, 37521, 37531, 37541, 37551, 37561, 37571, 37581, 37591, 37601, 37611, 37621, 37631, 37641, 37651, 37661, 37671, 37681, 37691, 37701, 37711, 37721, 37731, 37741, 37751, 37761, 37771, 37781, 37791, 37801, 37811, 37821, 37831, 37841, 37851, 37861, 37871, 37881, 37891, 37901, 37911, 37921, 37931, 37941, 37951, 37961, 37971, 37981, 37991, 38001, 38011, 38021, 38031, 38041, 38051, 38061, 38071, 38081, 38091, 38101, 38111, 38121, 38131, 38141, 38151, 38161, 38171, 38181, 38191, 38201, 38211, 38221, 38231, 38241, 38251, 38261, 38271, 38281, 38291, 38301, 38311, 38321, 38331, 38341, 38351, 38361, 38371, 38381, 38391, 38401, 38411, 38421, 38431, 38441, 38451, 38461, 38471, 38481, 38491, 38501, 38511, 38521, 38531, 38541, 38551, 38561, 38571, 38581, 38591, 38601, 38611, 38621, 38631, 38641, 38651, 38661, 38671, 38681, 38691, 38701, 38711, 38721, 38731, 38741, 38751, 38761, 38771, 38781, 38791, 38801, 38811, 38821, 38831, 38841, 38851, 38861, 38871, 38881, 38891, 38901, 38911, 38921, 38931, 38941, 38951, 38961, 38971, 38981, 38991, 39001, 39011, 39021, 39031, 39041, 39051, 39061, 39071, 39081, 39091, 39101, 39111, 39121, 39131, 39141, 39151, 39161, 39171, 39181, 39191, 39201, 39211, 39221, 39231, 39241, 39251, 39261, 39271, 39281, 39291, 39301, 39311, 39321, 39331, 39341, 39351, 39361, 39371, 39381, 39391, 39401, 39411, 39421, 39431, 39441, 39451, 39461, 39471, 39481, 39491, 39501, 39511, 39521, 39531, 39541, 39551, 39561, 39571, 39581, 39591, 39601, 39611, 39621, 39631, 39641, 39651, 39661, 39671, 39681, 39691, 39701, 39711, 39721, 39731, 39741, 39751, 39761, 39771, 39781, 39791, 39801, 39811, 39821, 39831, 39841, 39851, 39861, 39871, 39881, 39891, 39901, 39911, 39921, 39931, 39941, 39951, 39961, 39971, 39981, 39991, 40001, 40011, 40021, 40031, 40041, 40051, 40061, 40071, 40081, 40091, 40101, 40111, 40121, 40131, 40141, 40151, 40161, 40171, 40181, 40191, 40201, 40211, 40221, 40231, 40241, 40251, 40261, 40271, 40281, 40291, 40301, 40311, 40321, 40331, 40341, 40351, 40361, 40371, 40381, 40391, 40401, 40411, 40421, 40431, 40441, 40451, 40461, 40471, 40481, 40491, 40501, 40511, 40521, 40531, 40541, 40551, 40561, 40571, 40581, 40591, 40601, 40611, 40621, 40631, 40641, 40651, 40661, 40671, 40681, 40691, 40701, 40711, 40721, 40731, 40741, 40751, 40761, 40771, 40781, 40791, 40801, 40811, 40821, 40831, 40841, 40851, 40861, 40871, 40881, 40891, 40901, 40911, 40921, 40931, 40941, 40951, 40961, 40971, 40981, 40991, 41001, 41011, 41021, 41031, 41041, 41051, 41061, 41071, 41081, 41091, 41101, 41111, 41121, 41131, 41141, 41151, 41161, 41171, 41181, 41191, 41201, 41211, 41221, 41231, 41241, 41251, 41261, 41271, 41281, 41291, 41301, 41311, 41321, 41331, 41341, 41351, 41361, 41371, 41381, 41391, 41401, 41411, 41421, 41431, 41441, 41451, 41461, 41471, 41481, 41491, 41501, 41511, 41521, 41531, 41541, 41551, 41561, 41571, 41581, 41591, 41601, 41611, 41621, 41631, 41641, 41651, 41661, 41671, 41681, 41691, 41701, 41711, 41721, 41731, 41741, 41751, 41761, 41771, 41781, 41791, 41801, 41811, 41821, 41831, 41841, 41851, 41861, 41871, 41881, 41891, 41901, 41911, 41921, 41931, 41941, 41951, 41961, 41971, 41981, 41991, 42001, 42011, 42021, 42031, 42041, 42051, 42061, 42071, 42081, 42091, 42101, 42111, 42121, 42131, 42141, 42151, 42161, 42171, 42181, 42191, 42201, 42211, 42221, 42231, 42241, 42251, 42261, 42271, 42281, 42291, 42301, 42311, 42321, 42331, 42341, 42351, 42361, 42371, 42381, 42391, 42401, 42411, 42421, 42431, 42441, 42451, 42461, 42471, 42481, 42491, 42501, 42511, 42521, 42531, 42541, 42551, 42561, 42571, 42581, 42591, 42601, 42611, 42621, 42631, 42641, 42651, 42661, 42671, 42681, 42691, 42701, 42711, 42721, 42731, 42741, 42751, 42761, 42771, 42781, 42791, 42801, 42811, 42821, 42831, 42841, 42851, 42861, 42871, 42881, 42891, 42901, 42911, 42921, 42931, 42941, 42951, 42961, 42971, 42981, 42991, 43001, 43011, 43021, 43031, 43041, 43051, 43061, 43071, 43081, 43091, 43101, 43111, 43121, 43131, 43141, 43151, 43161, 43171, 43181, 43191, 43201, 43211, 43221, 43231, 43241, 43251, 43261, 43271, 43281, 43291, 43301, 43311, 43321, 43331, 43341, 43351, 43361, 43371, 43381, 43391, 43401, 43411, 43421, 43431, 43441, 43451, 43461, 43471, 43481, 43491, 43501, 43511, 43521, 43531, 43541, 43551, 43561, 43571, 43581, 43591, 43601, 43611, 43621, 43631, 43641, 43651, 43661, 43671, 43681, 43691, 43701, 43711, 43721, 43731, 43741, 43751, 43761, 43771, 43781, 43791, 43801, 43811, 43821, 43831, 43841, 43851, 43861, 43871, 43881, 43891, 43901, 43911, 43921, 43931, 43941, 43951, 43961, 43971, 43981, 43991, 44001, 44011, 44021, 44031, 44041, 44051, 44061, 44071, 44081, 44091, 44101, 44111, 44121, 44131, 44141, 44151, 44161, 44171, 44181, 44191, 44201, 44211, 44221, 44231, 44241, 44251, 44261, 44271, 44281, 44291, 44301, 44311, 44321, 44331, 44341, 44351, 44361, 44371, 44381, 44391, 44401, 44411, 44421, 44431, 44441, 44451, 44461, 44471, 44481, 44491, 44501, 44511, 44521, 44531, 44541, 44551, 44561, 44571, 44581, 44591, 44601, 44611, 44621, 44631, 44641, 44651, 44661, 44671, 44681, 44691, 44701, 44711, 44721, 44731, 44741, 44751, 44761, 44771, 44781, 44791, 44801, 44811, 44821, 44831, 44841, 44851, 44861, 44871, 44881, 44891, 44901, 44911, 44921, 44931, 44941, 44951, 44961, 44971, 44981, 44991, 45001, 45011, 45021, 45031, 45041, 45051, 45061, 45071, 45081, 45091, 45101, 45111, 45121, 45131, 45141, 45151, 45161, 45171, 45181, 45191, 45201, 45211, 45221, 45231, 45241, 45251, 45261, 45271, 45281, 45291, 45301, 45311, 45321, 45331, 45341, 45351, 45361, 45371, 45381, 45391, 45401, 45411, 45421, 45431, 45441, 45451, 45461, 45471, 45481, 45491, 45501, 45511, 45521, 45531, 45541, 45551, 45561, 45571, 45581, 45591, 45601, 45611, 45621, 45631, 45641, 45651, 45661, 45671, 45681, 45691, 45701, 45711, 45721, 45731, 45741, 45751, 45761, 45771, 45781, 45791, 45801, 45811, 45821, 45831, 45841, 45851, 45861, 45871, 45881, 45891, 45901, 45911, 45921, 45931, 45941, 45951, 45961, 45971, 45981, 45991, 46001, 46011, 46021, 46031, 46041, 46051, 46061, 46071, 46081, 46091, 46101, 46111, 46121, 46131, 46141, 46151, 46161, 46171, 46181, 46191, 46201, 46211, 46221, 46231, 46241, 46251, 46261, 46271, 46281, 46291, 46301, 46311, 46321, 46331, 46341, 46351, 46361, 46371, 46381, 46391, 46401, 46411, 46421, 46431, 46441, 46451, 46461, 46471, 46481, 46491, 46501, 46511, 46521, 46531, 46541, 46551, 46561, 46571, 46581, 46591, 46601, 46611, 46621, 46631, 46641, 46651, 46661, 46671, 46681, 46691, 46701, 46711, 46721, 46731, 46741, 46751, 46761, 46771, 46781, 46791, 46801, 46811, 46821, 46831, 46841, 46851, 46861, 46871, 46881, 46891, 46901, 46911, 46921, 46931, 46941, 46951, 46961, 46971, 46981, 46991, 47001, 47011, 47021, 47031, 47041, 47051, 47061, 47071, 47081, 47091, 47101, 47111, 47121, 47131, 47141, 47151, 47161, 47171, 47181, 47191, 47201, 47211, 47221, 47231, 47241, 47251, 47261, 47271, 47281, 47291, 47301, 47311, 47321, 47331, 47341, 47351, 47361, 47371, 47381, 47391, 47401, 47411, 47421, 47431, 47441, 47451, 47461, 47471, 47481, 47491, 47501, 47511, 47521, 47531, 47541, 47551, 47561, 47571, 47581, 47591, 47601, 47611, 47621, 47631, 47641, 47651, 47661, 47671, 47681, 47691, 47701, 47711, 47721, 47731, 47741, 47751, 47761, 47771, 47781, 47791, 47801, 47811, 47821, 47831, 47841, 47851, 47861, 47871, 47881, 47891, 47901, 47911, 47921, 47931, 47941, 47951, 47961, 47971, 47981, 47991, 48001, 48011, 48021, 48031, 48041, 48051, 48061, 48071, 48081, 48091, 48101, 48111, 48121, 48131, 48141, 48151, 48161, 48171, 48181, 48191, 48201, 48211, 48221, 48231, 48241, 48251, 48261, 48271, 48281, 48291, 48301, 48311, 48321, 48331, 48341, 48351, 48361, 48371, 48381, 48391, 48401, 48411, 48421, 48431, 48441, 48451, 48461, 48471, 48481, 48491, 48501, 48511, 48521, 48531, 48541, 48551, 48561, 48571, 48581, 48591, 48601, 48611, 48621, 48631, 48641, 48651, 48661, 48671, 48681, 48691, 48701, 48711, 48721, 48731, 48741, 48751, 48761, 48771, 48781, 48791, 48801, 48811, 48821, 48831, 48841, 48851, 48861, 48871, 48881, 48891, 48901, 48911, 48921, 48931, 48941, 48951, 48961, 48971, 48981, 48991, 49001, 49011, 49021, 49031, 49041, 49051, 49061, 49071, 49081, 49091, 49101, 49111, 49121, 49131, 49141, 49151, 49161, 49171, 49181, 49191, 49201, 49211, 49221, 49231, 49241, 49251, 49261, 49271, 49281, 49291, 49301, 49311, 49321, 49331, 49341, 49351, 49361, 49371, 49381, 49391, 49401, 49411, 49421, 49431, 49441, 49451, 49461, 49471, 49481, 49491, 49501, 49511, 49521, 49531, 49541, 49551, 49561, 49571, 49581, 49591, 49601, 49611, 49621, 49631, 49641, 49651, 49661, 49671, 49681, 49691, 49701, 49711, 49721, 49731, 49741, 49751, 49761, 49771, 49781, 49791, 49801, 49811, 49821, 49831, 49841, 49851, 49861, 49871, 49881, 49891, 49901, 49911, 49921, 49931, 49941, 49951, 49961, 49971, 49981, 49991, 50001, 50011, 50021, 50031, 50041, 50051, 50061, 50071, 50081, 50091, 50101, 50111, 50121, 50131, 50141, 50151, 50161, 50171, 50181, 50191, 50201, 50211, 50221, 50231, 50241, 50251, 50261, 50271, 50281, 50291, 50301, 50311, 50321, 50331, 50341, 50351, 50361, 50371, 50381, 50391, 50401, 50411, 50421, 50431, 50441, 50451, 50461, 50471, 50481, 50491, 50501, 50511, 50521, 50531, 50541, 50551, 50561, 50571, 50581, 50591, 50601, 50611, 50621, 50631, 50641, 50651, 50661, 50671, 50681, 50691, 50701, 50711, 50721, 50731, 50741, 50751, 50761, 50771, 50781, 50791, 50801, 50811, 50821, 50831, 50841, 50851, 50861, 50871, 50881, 50891, 50901, 50911, 50921, 50931, 50941, 50951, 50961, 50971, 50981, 50991, 51001, 51011, 51021, 51031, 51041, 51051, 51061, 51071, 51081, 51091, 51101, 51111, 51121, 51131, 51141, 51151, 51161, 51171, 51181, 51191, 51201, 51211, 51221, 51231, 51241, 51251, 51261, 51271, 51281, 51291, 51301, 51311, 51321, 51331, 51341, 51351, 51361, 51371, 51381, 51391, 51401, 51411, 51421, 51431, 51441, 51451, 51461, 51471, 51481, 51491, 51501, 51511, 51521, 51531, 51541, 51551, 51561, 51571, 51581, 51591, 51601, 51611, 51621, 51631, 51641, 51651, 51661, 51671, 51681, 51691, 51701, 51711, 51721, 51731, 51741, 51751, 51761, 51771, 51781, 51791, 51801, 51811, 51821, 51831, 51841, 51851, 51861, 51871, 51881, 51891, 51901, 51911, 51921, 51931, 51941, 51951, 51961, 51971, 51981, 51991, 52001, 52011, 52021, 52031, 52041, 52051, 52061, 52071, 52081, 52091, 52101, 52111, 52121, 52131, 52141, 52151, 52161, 52171, 52181, 52191, 52201, 52211, 52221, 52231, 52241, 52251, 52261, 52271, 52281, 52291, 52301, 52311, 52321, 52331, 52341, 52351, 52361, 52371, 52381, 52391, 52401, 52411, 52421, 52431, 52441, 52451, 52461, 52471, 52481, 52491, 52501, 52511, 52521, 52531, 52541, 52551, 52561, 52571, 52581, 52591, 52601, 52611, 52621, 52631, 52641, 52651, 52661, 52671, 52681, 52691, 52701, 52711, 52721, 52731, 52741, 52751, 52761, 52771, 52781, 52791, 52801, 52811, 52821, 52831, 52841, 52851, 52861, 52871, 52881, 52891, 52901, 52911, 52921, 52931, 52941, 52951, 52961, 52971, 52981, 52991, 53001, 53011, 53021, 53031, 53041, 53051, 53061, 53071, 53081, 53091, 53101, 53111, 53121, 53131, 53141, 53151, 53161, 53171, 53181, 53191, 53201, 53211, 53221, 53231, 53241, 53251, 53261, 53271, 53281, 53291, 53301, 53311, 53321, 53331, 53341, 53351, 53361, 53371, 53381, 53391, 53401, 53411, 53421, 53431, 53441, 53451, 53461, 53471, 53481, 53491, 53501, 53511, 53521, 53531, 53541, 53551, 53561, 53571, 53581, 53591, 53601, 53611, 53621, 53631, 53641, 53651, 53661, 53671, 53681, 53691, 53701, 53711, 53721, 53731, 53741, 53751, 53761, 53771, 53781, 53791, 53801, 53811, 53821, 53831, 53841, 53851, 53861, 53871, 53881, 53891, 53901, 53911, 53921, 53931, 53941, 53951, 53961, 53971, 53981, 53991, 54001, 54011, 54021, 54031, 54041, 54051, 54061, 54071, 54081, 54091, 54101, 54111, 54121, 54131, 54141, 54151, 54161, 54171, 54181, 54191, 54201, 54211, 54221, 54231, 54241, 54251, 54261, 54271, 54281, 54291, 54301, 54311, 54321, 54331, 54341, 54351, 54361, 54371, 54381, 54391, 54401, 54411, 54421, 54431, 54441, 54451, 54461, 54471, 54481, 54491, 54501, 54511, 54521, 54531, 54541, 54551, 54561, 54571, 54581, 54591, 54601, 54611, 54621, 54631, 54641, 54651, 54661, 54671, 54681, 54691, 54701, 54711, 54721, 54731, 54741, 54751, 54761, 54771, 54781, 54791, 54801, 54811, 54821, 54831, 54841, 54851, 54861, 54871, 54881, 54891, 54901, 54911, 54921, 54931, 54941, 54951, 54961, 54971, 54981, 54991, 55001, 55011, 55021, 55031, 55041, 55051, 55061, 55071, 55081, 55091, 55101, 55111, 55121, 55131, 55141, 55151, 55161, 55171, 55181, 55191, 55201, 55211, 55221, 55231, 55241, 55251, 55261, 55271, 55281, 55291, 55301, 55311, 55321, 55331, 55341, 55351, 55361, 55371, 55381, 55391, 55401, 55411, 55421, 55431, 55441, 55451, 55461, 55471, 55481, 55491, 55501, 55511, 55521, 55531, 55541, 55551, 55561, 55571, 55581, 55591, 55601, 55611, 55621, 55631, 55641, 55651, 55661, 55671, 55681, 55691, 55701, 55711, 55721, 55731, 55741, 55751, 55761, 55771, 55781, 55791, 55801, 55811, 55821, 55831, 55841, 55851, 55861, 55871, 55881, 55891, 55901, 55911, 55921, 55931, 55941, 55951, 55961, 55971, 55981, 55991, 56001, 56011, 56021, 56031, 56041, 56051, 56061, 56071, 56081, 56091, 56101, 56111, 56121, 56131, 56141, 56151, 56161, 56171, 56181, 56191, 56201, 56211, 56221, 56231, 56241, 56251, 56261, 56271, 56281, 56291, 56301, 56311, 56321, 56331, 56341, 56351, 56361, 56371, 56381, 56391, 56401, 56411, 56421, 56431, 56441, 56451, 56461, 56471, 56481, 56491, 56501, 56511, 56521, 56531, 56541, 56551, 56561, 56571, 56581, 56591, 56601, 56611, 56621, 56631, 56641, 56651, 56661, 56671, 56681, 56691, 56701, 56711, 56721, 56731, 56741, 56751, 56761, 56771, 56781, 56791, 56801, 56811, 56821, 56831, 56841, 56851, 56861, 56871, 56881, 56891, 56901, 56911, 56921, 56931, 56941, 56951, 56961, 56971, 56981, 56991, 57001, 57011, 57021, 57031, 57041, 57051, 57061, 57071, 57081, 57091, 57101, 57111, 57121, 57131, 57141, 57151, 57161, 57171, 57181, 57191, 57201, 57211, 57221, 57231, 57241, 57251, 57261, 57271, 57281, 57291, 57301, 57311, 57321, 57331, 57341, 57351, 57361, 57371, 57381, 57391, 57401, 57411, 57421, 57431, 57441, 57451, 57461, 57471, 57481, 57491, 57501, 57511, 57521, 57531, 57541, 57551, 57561, 57571, 57581, 57591, 57601, 57611, 57621, 57631, 57641, 57651, 57661, 57671, 57681, 57691, 57701, 57711, 57721, 57731, 57741, 57751, 57761, 57771, 57781, 57791, 57801, 57811, 57821, 57831, 57841, 57851, 57861, 57871, 57881, 57891, 57901, 57911, 57921, 57931, 57941, 57951, 57961, 57971, 57981, 57991, 58001, 58011, 58021, 58031, 58041, 58051, 58061, 58071, 58081, 58091, 58101, 58111, 58121, 58131, 58141, 58151, 58161, 58171, 58181, 58191, 58201, 58211, 58221, 58231, 58241, 58251, 58261, 58271, 58281, 58291, 58301, 58311, 58321, 58331, 58341, 58351, 58361, 58371, 58381, 58391, 58401, 58411, 58421, 58431, 58441, 58451, 58461, 58471, 58481, 58491, 58501, 58511, 58521, 58531, 58541, 58551, 58561, 58571, 58581, 58591, 58601, 58611, 58621, 58631, 58641, 58651, 58661, 58671, 58681, 58691, 58701, 58711, 58721, 58731, 58741, 58751, 58761, 58771, 58781, 58791, 58801, 58811, 58821, 58831, 58841, 58851, 58861, 58871, 58881, 58891, 58901, 58911, 58921, 58931, 58941, 58951, 58961, 58971, 58981, 58991, 59001, 59011, 59021, 59031, 59041, 59051, 59061, 59071, 59081, 59091, 59101, 59111, 59121, 59131, 59141, 59151, 59161, 59171, 59181, 59191, 59201, 59211, 59221, 59231, 59241, 59251, 59261, 59271, 59281, 59291, 59301, 59311, 59321, 59331, 59341, 59351, 59361, 59371, 59381, 59391, 59401, 59411, 59421, 59431, 59441, 59451, 59461, 59471, 59481, 59491, 59501, 59511, 59521, 59531, 59541, 59551, 59561, 59571, 59581, 59591, 59601, 59611, 59621, 59631, 59641, 59651, 59661, 59671, 59681, 59691, 59701, 59711, 59721, 59731, 59741, 59751, 59761, 59771, 59781, 59791, 59801, 59811, 59821, 59831, 59841, 59851, 59861, 59871, 59881, 59891, 59901, 59911, 59921, 59931, 59941, 59951, 59961, 59971, 59981, 59991, 60001, 60011, 60021, 60031, 60041, 60051, 60061, 60071, 60081, 60091, 60101, 60111, 60121, 60131, 60141, 60151, 60161, 60171, 60181, 60191, 60201, 60211, 60221, 60231, 60241, 60251, 60261, 60271, 60281, 60291, 60301, 60311, 60321, 60331, 60341, 60351, 60361, 60371, 60381, 60391, 60401, 60411, 60421, 60431, 60441, 60451, 60461, 60471, 60481, 60491, 60501, 60511, 60521, 60531, 60541, 60551, 60561, 60571, 60581, 60591, 60601, 60611, 60621, 60631, 60641, 60651, 60661, 60671, 60681, 60691, 60701, 60711, 60721, 60731, 60741, 60751, 60761, 60771, 60781, 60791, 60801, 60811, 60821, 60831, 60841, 60851, 60861, 60871, 60881, 60891, 60901, 60911, 60921, 60931, 60941, 60951, 60961, 60971, 60981, 60991, 61001, 61011, 61021, 61031, 61041, 61051, 61061, 61071, 61081, 61091, 61101, 61111, 61121, 61131, 61141, 61151, 61161, 61171, 61181, 61191, 61201, 61211, 61221, 61231, 61241, 61251, 61261, 61271, 61281, 61291, 61301, 61311, 61321, 61331, 61341, 61351, 61361, 61371, 61381, 61391, 61401, 61411, 61421, 61431, 61441, 61451, 61461, 61471, 61481, 61491, 61501, 61511, 61521, 61531, 61541, 61551, 61561, 61571, 61581, 61591, 61601, 61611, 61621, 61631, 61641, 61651, 61661, 61671, 61681, 61691, 61701, 61711, 61721, 61731, 61741, 61751, 61761, 61771, 61781, 61791, 61801, 61811, 61821, 61831, 61841, 61851, 61861, 61871, 61881, 61891, 61901, 61911, 61921, 61931, 61941, 61951, 61961, 61971, 61981, 61991, 62001, 62011, 62021, 62031, 62041, 62051, 62061, 62071, 62081, 62091, 62101, 62111, 62121, 62131, 62141, 62151, 62161, 62171, 62181, 62191, 62201, 62211, 62221, 62231, 62241, 62251, 62261, 62271, 62281, 62291, 62301, 62311, 62321, 62331, 62341, 62351, 62361, 62371, 62381, 62391, 62401, 62411, 62421, 62431, 62441, 62451, 62461, 62471, 62481, 62491, 62501, 62511, 62521, 62531, 62541, 62551, 62561, 62571, 62581, 62591, 62601, 62611, 62621, 62631, 62641, 62651, 62661, 62671, 62681, 62691, 62701, 62711, 62721, 62731, 62741, 62751, 62761, 62771, 62781, 62791, 62801, 62811, 62821, 62831, 62841, 62851, 62861, 62871, 62881, 62891, 62901, 62911, 62921, 62931, 62941, 62951, 62961, 62971, 62981, 62991, 63001, 63011, 63021, 63031, 63041, 63051, 63061, 63071, 63081, 63091, 63101, 63111, 63121, 63131, 63141, 63151, 63161, 63171, 63181, 63191, 63201, 63211, 63221, 63231, 63241, 63251, 63261, 63271, 63281, 63291, 63301, 63311, 63321, 63331, 63341, 63351, 63361, 63371, 63381, 63391, 63401, 63411, 63421, 63431, 63441, 63451, 63461, 63471, 63481, 63491, 63501, 63511, 63521, 63531, 63541, 63551, 63561, 63571, 63581, 63591, 63601, 63611, 63621, 63631, 63641, 63651, 63661, 63671, 63681, 63691, 63701, 63711, 63721, 63731, 63741, 63751, 63761, 63771, 63781, 63791, 63801, 63811, 63821, 63831, 63841, 63851, 63861, 63871, 63881, 63891, 63901, 63911, 63921, 63931, 63941, 63951, 63961, 63971, 63981, 63991, 64001, 64011, 64021, 64031, 64041, 64051, 64061, 64071, 64081, 64091, 64101, 64111, 64121, 64131, 64141, 64151, 64161, 64171, 64181, 64191, 64201, 64211, 64221, 64231, 64241, 64251, 64261, 64271, 64281, 64291, 64301, 64311, 64321, 64331, 64341, 64351, 64361, 64371, 64381, 64391, 64401, 64411, 64421, 64431, 64441, 64451, 64461, 64471, 64481, 64491, 64501, 64511, 64521, 64531, 64541, 64551, 64561, 64571, 64581, 64591, 64601, 64611, 64621, 64631, 64641, 64651, 64661, 64671, 64681, 64691, 64701, 64711, 64721, 64731, 64741, 64751, 64761, 64771, 64781, 64791, 64801, 64811, 64821, 64831, 64841, 64851, 64861, 64871, 64881, 64891, 64901, 64911, 64921, 64931, 64941, 64951, 64961, 64971, 64981, 64991, 65001, 65011, 65021, 65031, 65041, 65051, 65061, 65071, 65081, 65091, 65101, 65111, 65121, 65131, 65141, 65151, 65161, 65171, 65181, 65191, 65201, 65211, 65221, 65231, 65241, 65251, 65261, 65271, 65281, 65291, 65301, 65311, 65321, 65331, 65341, 65351, 65361, 65371, 65381, 65391, 65401, 65411, 65421, 65431, 65441, 65451, 65461, 65471, 65481, 65491, 65501, 65511, 65521, 65531, 65541, 65551, 65561, 65571, 65581, 65591, 65601, 65611, 65621, 65631, 65641, 65651, 65661, 65671, 65681, 65691, 65701, 65711, 65721, 65731, 65741, 65751, 65761, 65771, 65781, 65791, 65801, 65811, 65821, 65831, 65841, 65851, 65861, 65871, 65881, 65891, 65901, 65911, 65921, 65931, 65941, 65951, 65961, 65971, 65981, 65991, 66001, 66011, 66021, 66031, 66041, 66051, 66061, 66071, 66081, 66091, 66101, 66111, 66121, 66131, 66141, 66151, 66161, 66171, 66181, 66191, 66201, 66211, 66221, 66231, 66241, 66251, 66261, 66271, 66281, 66291, 66301, 66311, 66321, 66331, 66341, 66351, 66361, 66371, 66381, 66391, 66401, 66411, 66421, 66431, 66441, 66451, 66461, 66471, 66481, 66491, 66501, 66511, 66521, 66531, 66541, 66551, 66561, 66571, 66581, 66591, 66601, 66611, 66621, 66631, 66641, 66651, 66661, 66671, 66681, 66691, 66701, 66711, 66721, 66731, 66741, 66751, 66761, 66771, 66781, 66791, 66801, 66811, 66821, 66831, 66841, 66851, 66861, 66871, 66881, 66891, 66901, 66911, 66921, 66931, 66941, 66951, 66961, 66971, 66981, 66991, 67001, 67011, 67021, 67031, 67041, 67051, 67061, 67071, 67081, 67091, 67101, 67111, 67121, 67131, 67141, 67151, 67161, 67171, 67181, 67191, 67201, 67211, 67221, 67231, 67241, 67251, 67261, 67271, 67281, 67291, 67301, 67311, 67321, 67331, 67341, 67351, 67361, 67371, 67381, 67391, 67401, 67411, 67421, 67431, 67441, 67451, 67461, 67471, 67481, 67491, 67501, 67511, 67521, 67531, 67541, 67551, 67561, 67571, 67581, 67591, 67601, 67611, 67621, 67631, 67641, 67651, 67661, 67671, 67681, 67691, 67701, 67711, 67721, 67731, 67741, 67751, 67761, 67771, 67781, 67791, 67801, 67811, 67821, 67831, 67841, 67851, 67861, 67871, 67881, 67891, 67901, 67911, 67921, 67931, 67941, 67951, 67961, 67971, 67981, 67991, 68001, 68011, 68021, 68031, 68041, 68051, 68061, 68071, 68081, 68091, 68101, 68111, 68121, 68131, 68141, 68151, 68161, 68171, 68181, 68191, 68201, 68211, 68221, 68231, 68241, 68251, 68261, 68271, 68281, 68291, 68301, 68311, 68321, 68331, 68341, 68351, 68361, 68371, 68381, 68391, 68401, 68411, 68421, 68431, 68441, 68451, 68461, 68471, 68481, 68491, 68501, 68511, 68521, 68531, 68541, 68551, 68561, 68571, 68581, 68591, 68601, 68611, 68621, 68631, 68641, 68651, 68661, 68671, 68681, 68691, 68701, 68711, 68721, 68731, 68741, 68751, 68761, 68771, 68781, 68791, 68801, 68811, 68821, 68831, 68841, 68851, 68861, 68871, 68881, 68891, 68901, 68911, 68921, 68931, 68941, 68951, 68961, 68971, 68981, 68991, 69001, 69011, 69021, 69031, 69041, 69051, 69061, 69071, 69081, 69091, 69101, 69111, 69121, 69131, 69141, 69151, 69161, 69171, 69181, 69191, 69201, 69211, 69221, 69231, 69241, 69251, 69261, 69271, 69281, 69291, 69301, 69311, 69321, 69331, 69341, 69351, 69361, 69371, 69381, 69391, 69401, 69411, 69421, 69431, 69441, 69451, 69461, 69471, 69481, 69491, 69501, 69511, 69521, 69531, 69541, 69551, 69561, 69571, 69581, 69591, 69601, 69611, 69621, 69631, 69641, 69651, 69661, 69671, 69681, 69691, 69701, 69711, 69721, 69731, 69741, 69751, 69761, 69771, 69781, 69791, 69801, 69811, 69821, 69831, 69841, 69851, 69861, 69871, 69881, 69891, 69901, 69911, 69921, 69931, 69941, 69951, 69961, 69971, 69981, 69991, 70001, 70011, 70021, 70031, 70041, 70051, 70061, 70071, 70081, 70091, 70101, 70111, 70121, 70131, 70141, 70151, 70161, 70171, 70181, 70191, 70201, 70211, 70221, 70231, 70241, 70251, 70261, 70271, 70281, 70291, 70301, 70311, 70321, 70331, 70341, 70351, 70361, 70371, 70381, 70391, 70401, 70411, 70421, 70431, 70441, 70451, 70461, 70471, 70481, 70491, 70501, 70511, 70521, 70531, 70541, 70551, 70561, 70571, 70581, 70591, 70601, 70611, 70621, 70631, 70641, 70651, 70661, 70671, 70681, 70691, 70701, 70711, 70721, 70731, 70741, 70751, 70761, 70771, 70781, 70791, 70801, 70811, 70821, 70831, 70841, 70851, 70861, 70871, 70881, 70891, 70901, 70911, 70921, 70931, 70941, 70951, 70961, 70971, 70981, 70991, 71001, 71011, 71021, 71031, 71041, 71051, 71061, 71071, 71081, 71091, 71101, 71111, 71121, 71131, 71141, 71151, 71161, 71171, 71181, 71191, 71201, 71211, 71221, 71231, 71241, 71251, 71261, 71271, 71281, 71291, 71301, 71311, 71321, 71331, 71341, 71351, 71361, 71371, 71381, 71391, 71401, 71411, 71421, 71431, 71441, 71451, 71461, 71471, 71481, 71491, 71501, 71511, 71521, 71531, 71541, 71551, 71561, 71571, 71581, 71591, 71601, 71611, 71621, 71631, 71641, 71651, 71661, 71671, 71681, 71691, 71701, 71711, 71721, 71731, 71741, 71751, 71761, 71771, 71781, 71791, 71801, 71811, 71821, 71831, 71841, 71851, 71861, 71871, 71881, 71891, 71901, 71911, 71921, 71931, 71941, 71951, 71961, 71971, 71981, 71991, 72001, 72011, 72021, 72031, 72041, 72051, 72061, 72071, 72081, 72091, 72101, 72111, 72121, 72131, 72141, 72151, 72161, 72171, 72181, 72191, 72201, 72211, 72221, 72231, 72241, 72251, 72261, 72271, 72281, 72291, 72301, 72311, 72321, 72331, 72341, 72351, 72361, 72371, 72381, 72391, 72401, 72411, 72421, 72431, 72441, 72451, 72461, 72471, 72481, 72491, 72501, 72511, 72521, 72531, 72541, 72551, 72561, 72571, 72581, 72591, 72601, 72611, 72621, 72631, 72641, 72651, 72661, 72671, 72681, 72691, 72701, 72711, 72721, 72731, 72741, 72751, 72761, 72771, 72781, 72791, 72801, 72811, 72821, 72831, 72841, 72851, 72861, 72871, 72881, 72891, 72901, 72911, 72921, 72931, 72941, 72951, 72961, 72971, 72981, 72991, 73001, 73011, 73021, 73031, 73041, 73051, 73061, 73071, 73081, 73091, 73101, 73111, 73121, 73131, 73141, 73151, 73161, 73171, 73181, 73191, 73201, 73211, 73221, 73231, 73241, 73251, 73261, 73271, 73281, 73291, 73301, 73311, 73321, 73331, 73341, 73351, 73361, 73371, 73381, 73391, 73401, 73411, 73421, 73431, 73441, 73451, 73461, 73471, 73481, 73491, 73501, 73511, 73521, 73531, 73541, 73551, 73561, 73571, 73581, 73591, 73601, 73611, 73621, 73631, 73641, 73651, 73661, 73671, 73681, 73691, 73701, 73711, 73721, 73731, 73741, 73751, 73761, 73771, 73781, 73791, 73801, 73811, 73821, 73831, 73841, 73851, 73861, 73871, 73881, 73891, 73901, 73911, 73921, 73931, 73941, 73951, 73961, 73971, 73981, 73991, 74001, 74011, 74021, 74031, 74041, 74051, 74061, 74071, 74081, 74091, 74101, 74111, 74121, 74131, 74141, 74151, 74161, 74171, 74181, 74191, 74201, 74211, 74221, 74231, 74241, 74251, 74261, 74271, 74281, 74291, 74301, 74311, 74321, 74331, 74341, 74351, 74361, 74371, 74381, 74391, 74401, 74411, 74421, 74431, 74441, 74451, 74461, 74471, 74481, 74491, 74501, 74511, 74521, 74531, 74541, 74551, 74561, 74571, 74581, 74591, 74601, 74611, 74621, 74631, 74641, 74651, 74661, 74671, 74681, 74691, 74701, 74711, 74721, 74731, 74741, 74751, 74761, 74771, 74781, 74791, 74801, 74811, 74821, 74831, 74841, 74851, 74861, 74871, 74881, 74891, 74901, 74911, 74921, 74931, 74941, 74951, 74961, 74971, 74981, 74991, 75001, 75011, 75021, 75031, 75041, 75051, 75061, 75071, 75081, 75091, 75101, 75111, 75121, 75131, 75141, 75151, 75161, 75171, 75181, 75191, 75201, 75211, 75221, 75231, 75241, 75251, 75261, 75271, 75281, 75291, 75301, 75311, 75321, 75331, 75341, 75351, 75361, 75371, 75381, 75391, 75401, 75411, 75421, 75431, 75441, 75451, 75461, 75471, 75481, 75491, 75501, 75511, 75521, 75531, 75541, 75551, 75561, 75571, 75581, 75591, 75601, 75611, 75621, 75631, 75641, 75651, 75661, 75671, 75681, 75691, 75701, 75711, 75721, 75731, 75741, 75751, 75761, 75771, 75781, 75791, 75801, 75811, 75821, 75831, 75841, 75851, 75861, 75871, 75881, 75891, 75901, 75911, 75921, 75931, 75941, 75951, 75961, 75971, 75981, 75991, 76001, 76011, 76021, 76031, 76041, 76051, 76061, 76071, 76081, 76091, 76101, 76111, 76121, 76131, 76141, 76151, 76161, 76171, 76181, 76191, 76201, 76211, 76221, 76231, 76241, 76251, 76261, 76271, 76281, 76291, 76301, 76311, 76321, 76331, 76341, 76351, 76361, 76371, 76381, 76391, 76401, 76411, 76421, 76431, 76441, 76451, 76461, 76471, 76481, 76491, 76501, 76511, 76521, 76531, 76541, 76551, 76561, 76571, 76581, 76591, 76601, 76611, 76621, 76631, 76641, 76651, 76661, 76671, 76681, 76691, 76701, 76711, 76721, 76731, 76741, 76751, 76761, 76771, 76781, 76791, 76801, 76811, 76821, 76831, 76841, 76851, 76861, 76871, 76881, 76891, 76901, 76911, 76921, 76931, 76941, 76951, 76961, 76971, 76981, 76991, 77001, 77011, 77021, 77031, 77041, 77051, 77061, 77071, 77081, 77091, 77101, 77111, 77121, 77131, 77141, 77151, 77161, 77171, 77181, 77191, 77201, 77211, 77221, 77231, 77241, 77251, 77261, 77271, 77281, 77291, 77301, 77311, 77321, 77331, 77341, 77351, 77361, 77371, 77381, 77391, 77401, 77411, 77421, 77431, 77441, 77451, 77461, 77471, 77481, 77491, 77501, 77511, 77521, 77531, 77541, 77551, 77561, 77571, 77581, 77591, 77601, 77611, 77621, 77631, 77641, 77651, 77661, 77671, 77681, 77691, 77701, 77711, 77721, 77731, 77741, 77751, 77761, 77771, 77781, 77791, 77801, 77811, 77821, 77831, 77841, 77851, 77861, 77871, 77881, 77891, 77901, 77911, 77921, 77931, 77941, 77951, 77961, 77971, 77981, 77991, 78001, 78011, 78021, 78031, 78041, 78051, 78061, 78071, 78081, 78091, 78101, 78111, 78121, 78131, 78141, 78151, 78161, 78171, 78181, 78191, 78201, 78211, 78221, 78231, 78241, 78251, 78261, 78271, 78281, 78291, 78301, 78311, 78321, 78331, 78341, 78351, 78361, 78371, 78381, 78391, 78401, 78411, 78421, 78431, 78441, 78451, 78461, 78471, 78481, 78491, 78501, 78511, 78521, 78531, 78541, 78551, 78561, 78571, 78581, 78591, 78601, 78611, 78621, 78631, 78641, 78651, 78661, 78671, 78681, 78691, 78701, 78711, 78721, 78731, 78741, 78751, 78761, 78771, 78781, 78791, 78801, 78811, 78821, 78831, 78841, 78851, 78861, 78871, 78881, 78891, 78901, 78911, 78921, 78931, 78941, 78951, 78961, 78971, 78981, 78991, 79001, 79011, 79021, 79031, 79041, 79051, 79061, 79071, 79081, 79091, 79101, 79111, 79121, 79131, 79141, 79151, 79161, 79171, 79181, 79191, 79201, 79211, 79221, 79231, 79241, 79251, 79261, 79271, 79281, 79291, 79301, 79311, 79321, 79331, 79341, 79351, 79361, 79371, 79381, 79391, 79401, 79411, 79421, 79431, 79441, 79451, 79461, 79471, 79481, 79491, 79501, 79511, 79521, 79531, 79541, 79551, 79561, 79571, 79581, 79591, 79601, 79611, 79621, 79631, 79641, 79651, 79661, 79671, 79681, 79691, 79701, 79711, 79721, 79731, 79741, 79751, 79761, 79771, 79781, 79791, 79801, 79811, 79821, 79831, 79841, 79851, 79861, 79871, 79881, 79891, 79901, 79911, 79921, 79931, 79941, 79951, 79961, 79971, 79981, 79991, 80001, 80011, 80021, 80031, 80041, 80051, 80061, 80071, 80081, 80091, 80101, 80111, 80121, 80131, 80141, 80151, 80161, 80171, 80181, 80191, 80201, 80211, 80221, 80231, 80241, 80251, 80261, 80271, 80281, 80291, 80301, 80311, 80321, 80331, 80341, 80351, 80361, 80371, 80381, 80391, 80401, 80411, 80421, 80431, 80441, 80451, 80461, 80471, 80481, 80491, 80501, 80511, 80521, 80531, 80541, 80551, 80561, 80571, 80581, 80591, 80601, 80611, 80621, 80631, 80641, 80651, 80661, 80671, 80681, 80691, 80701, 80711, 80721, 80731, 80741, 80751, 80761, 80771, 80781, 80791, 80801, 80811, 80821, 80831, 80841, 80851, 80861, 80871, 80881, 80891, 80901, 80911, 80921, 80931, 80941, 80951, 80961, 80971, 80981, 80991, 81001, 81011, 81021, 81031, 81041, 81051, 81061, 81071, 81081, 81091, 81101, 81111, 81121, 81131, 81141, 81151, 81161, 81171, 81181, 81191, 81201, 81211, 81221, 81231, 81241, 81251, 81261, 81271, 81281, 81291, 81301, 81311, 81321, 81331, 81341, 81351, 81361, 81371, 81381, 81391, 81401, 81411, 81421, 81431, 81441, 81451, 81461, 81471, 81481, 81491, 81501, 81511, 81521, 81531, 81541, 81551, 81561, 81571, 81581, 81591, 81601, 81611, 81621, 81631, 81641, 81651, 81661, 81671, 81681, 81691, 81701, 81711, 81721, 81731, 81741, 81751, 81761, 81771, 81781, 81791, 81801, 81811, 81821, 81831, 81841, 81851, 81861, 81871, 81881, 81891, 81901, 81911, 81921, 81931, 81941, 81951, 81961, 81971, 81981, 81991, 82001, 82011, 82021, 82031, 82041, 82051, 82061, 82071, 82081, 82091, 82101, 82111, 82121, 82131, 82141, 82151, 82161, 82171, 82181, 82191, 82201, 82211, 82221, 82231, 82241, 82251, 82261, 82271, 82281, 82291, 82301, 82311, 82321, 82331, 82341, 82351, 82361, 82371, 82381, 82391, 82401, 82411, 82421, 82431, 82441, 82451, 82461, 82471, 82481, 82491, 82501, 82511, 82521, 82531, 82541, 82551, 82561, 82571, 82581, 82591, 82601, 82611, 82621, 82631, 82641, 82651, 82661, 82671, 82681, 82691, 82701, 82711, 82721, 82731, 82741, 82751, 82761, 82771, 82781, 82791, 82801, 82811, 82821, 82831, 82841, 82851, 82861, 82871, 82881, 82891, 82901, 82911, 82921, 82931, 82941, 82951, 82961, 82971, 82981, 82991, 83001, 83011, 83021, 83031, 83041, 83051, 83061, 83071, 83081, 83091, 83101, 83111, 83121, 83131, 83141, 83151, 83161, 83171, 83181, 83191, 83201, 83211, 83221, 83231, 83241, 83251, 83261, 83271, 83281, 83291, 83301, 83311, 83321, 83331, 83341, 83351, 83361, 83371, 83381, 83391, 83401, 83411, 83421, 83431, 83441, 83451, 83461, 83471, 83481, 83491, 83501, 83511, 83521, 83531, 83541, 83551, 83561, 83571, 83581, 83591, 83601, 83611, 83621, 83631, 83641, 83651, 83661, 83671, 83681, 83691, 83701, 83711, 83721, 83731, 83741, 83751, 83761, 83771, 83781, 83791, 83801, 83811, 83821, 83831, 83841, 83851, 83861, 83871, 83881, 83891, 83901, 83911, 83921, 83931, 83941, 83951, 83961, 83971, 83981, 83991, 84001, 84011, 84021, 84031, 84041, 84051, 84061, 84071, 84081, 84091, 84101, 84111, 84121, 84131, 84141, 84151, 84161, 84171, 84181, 84191, 84201, 84211, 84221, 84231, 84241, 84251, 84261, 84271, 84281, 84291, 84301, 84311, 84321, 84331, 84341, 84351, 84361, 84371, 84381, 84391, 84401, 84411, 84421, 84431, 84441, 84451, 84461, 84471, 84481, 84491, 84501, 84511, 84521, 84531, 84541, 84551, 84561, 84571, 84581, 84591, 84601, 84611, 84621, 84631, 84641, 84651, 84661, 84671, 84681, 84691, 84701, 84711, 84721, 84731, 84741, 84751, 84761, 84771, 84781, 84791, 84801, 84811, 84821, 84831, 84841, 84851, 84861, 84871, 84881, 84891, 84901, 84911, 84921, 84931, 84941, 84951, 84961, 84971, 84981, 84991, 85001, 85011, 85021, 85031, 85041, 85051, 85061, 85071, 85081, 85091, 85101, 85111, 85121, 85131, 85141, 85151, 85161, 85171, 85181, 85191, 85201, 85211, 85221, 85231, 85241, 85251, 85261, 85271, 85281, 85291, 85301, 85311, 85321, 85331, 85341, 85351, 85361, 85371, 85381, 85391, 85401, 85411, 85421, 85431, 85441, 85451, 85461, 85471, 85481, 85491, 85501, 85511, 85521, 85531, 85541, 85551, 85561, 85571, 85581, 85591, 85601, 85611, 85621, 85631, 85641, 85651, 85661, 85671, 85681, 85691, 85701, 85711, 85721, 85731, 85741, 85751, 85761, 85771, 85781, 85791, 85801, 85811, 85821, 85831, 85841, 85851, 85861, 85871, 85881, 85891, 85901, 85911, 85921, 85931, 85941, 85951, 85961, 85971, 85981, 85991, 86001, 86011, 86021, 86031, 86041, 86051, 86061, 86071, 86081, 86091, 86101, 86111, 86121, 86131, 86141, 86151, 86161, 86171, 86181, 86191, 86201, 86211, 86221, 86231, 86241, 86251, 86261, 86271, 86281, 86291, 86301, 86311, 86321, 86331, 86341, 86351, 86361, 86371, 86381, 86391, 86401, 86411, 86421, 86431, 86441, 86451, 86461, 86471, 86481, 86491, 86501, 86511, 86521, 86531, 86541, 86551, 86561, 86571, 86581, 86591, 86601, 86611, 86621, 86631, 86641, 86651, 86661, 86671, 86681, 86691, 86701, 86711, 86721, 86731, 86741, 86751, 86761, 86771, 86781, 86791, 86801, 86811, 86821, 86831, 86841, 86851, 86861, 86871, 86881, 86891, 86901, 86911, 86921, 86931, 86941, 86951, 86961, 86971, 86981, 86991, 87001, 87011, 87021, 87031, 87041, 87051, 87061, 87071, 87081, 87091, 87101, 87111, 87121, 87131, 87141, 87151, 87161, 87171, 87181, 87191, 87201, 87211, 87221, 87231, 87241, 87251, 87261, 87271, 87281, 87291, 87301, 87311, 87321, 87331, 87341, 87351, 87361, 87371, 87381, 87391, 87401, 87411, 87421, 87431, 87441, 87451, 87461, 87471, 87481, 87491, 87501, 87511, 87521, 87531, 87541, 87551, 87561, 87571, 87581, 87591, 87601, 87611, 87621, 87631, 87641, 87651, 87661, 87671, 87681, 87691, 87701, 87711, 87721, 87731, 87741, 87751, 87761, 87771, 87781, 87791, 87801, 87811, 87821, 87831, 87841, 87851, 87861, 87871, 87881, 87891, 87901, 87911, 87921, 87931, 87941, 87951, 87961, 87971, 87981, 87991, 88001, 88011, 88021, 88031, 88041, 88051, 88061, 88071, 88081, 88091, 88101, 88111, 88121, 88131, 88141, 88151, 88161, 88171, 88181, 88191, 88201, 88211, 88221, 88231, 88241, 88251, 88261, 88271, 88281, 88291, 88301, 88311, 88321, 88331, 88341, 88351, 88361, 88371, 88381, 88391, 88401, 88411, 88421, 88431, 88441, 88451, 88461, 88471, 88481, 88491, 88501, 88511, 88521, 88531, 88541, 88551, 88561, 88571, 88581, 88591, 88601, 88611, 88621, 88631, 88641, 88651, 88661, 88671, 88681, 88691, 88701, 88711, 88721, 88731, 88741, 88751, 88761, 88771, 88781, 88791, 88801, 88811, 88821, 88831, 88841, 88851, 88861, 88871, 88881, 88891, 88901, 88911, 88921, 88931, 88941, 88951, 88961, 88971, 88981, 88991, 89001, 89011, 89021, 89031, 89041, 89051, 89061, 89071, 89081, 89091, 89101, 89111, 89121, 89131, 89141, 89151, 89161, 89171, 89181, 89191, 89201, 89211, 89221, 89231, 89241, 89251, 89261, 89271, 89281, 89291, 89301, 89311, 89321, 89331, 89341, 89351, 89361, 89371, 89381, 89391, 89401, 89411, 89421, 89431, 89441, 89451, 89461, 89471, 89481, 89491, 89501, 89511, 89521, 89531, 89541, 89551, 89561, 89571, 89581, 89591, 89601, 89611, 89621, 89631, 89641, 89651, 89661, 89671, 89681, 89691, 89701, 89711, 89721, 89731, 89741, 89751, 89761, 89771, 89781, 89791, 89801, 89811, 89821, 89831, 89841, 89851, 89861, 89871, 89881, 89891, 89901, 89911, 89921, 89931, 89941, 89951, 89961, 89971, 89981, 89991, 90001, 90011, 90021, 90031, 90041, 90051, 90061, 90071, 90081, 90091, 90101, 90111, 90121, 90131, 90141, 90151, 90161, 90171, 90181, 90191, 90201, 90211, 90221, 90231, 90241, 90251, 90261, 90271, 90281, 90291, 90301, 90311, 90321, 90331, 90341, 90351, 90361, 90371, 90381, 90391, 90401, 90411, 90421, 90431, 90441, 90451, 90461, 90471, 90481, 90491, 90501, 90511, 90521, 90531, 90541, 90551, 90561, 90571, 90581, 90591, 90601, 90611, 90621, 90631, 90641, 90651, 90661, 90671, 90681, 90691, 90701, 90711, 90721, 90731, 90741, 90751, 90761, 90771, 90781, 90791, 90801, 90811, 90821, 90831, 90841, 90851, 90861, 90871, 90881, 90891, 90901, 90911, 90921, 90931, 90941, 90951, 90961, 90971, 90981, 90991, 91001, 91011, 91021, 91031, 91041, 91051, 91061, 91071, 91081, 91091, 91101, 91111, 91121, 91131, 91141, 91151, 91161, 91171, 91181, 91191, 91201, 91211, 91221, 91231, 91241, 91251, 91261, 91271, 91281, 91291, 91301, 91311, 91321, 91331, 91341, 91351, 91361, 91371, 91381, 91391, 91401, 91411, 91421, 91431, 91441, 91451, 91461, 91471, 91481, 91491, 91501, 91511, 91521, 91531, 91541, 91551, 91561, 91571, 91581, 91591, 91601, 91611, 91621, 91631, 91641, 91651, 91661, 91671, 91681, 91691, 91701, 91711, 91721, 91731, 91741, 91751, 91761, 91771, 91781, 91791, 91801, 91811, 91821, 91831, 91841, 91851, 91861, 91871, 91881, 91891, 91901, 91911, 91921, 91931, 91941, 91951, 91961, 91971, 91981, 91991, 92001, 92011, 92021, 92031, 92041, 92051, 92061, 92071, 92081, 92091, 92101, 92111, 92121, 92131, 92141, 92151, 92161, 92171, 92181, 92191, 92201, 92211, 92221, 92231, 92241, 92251, 92261, 92271, 92281, 92291, 92301, 92311, 92321, 92331, 92341, 92351, 92361, 92371, 92381, 92391, 92401, 92411, 92421, 92431, 92441, 92451, 92461, 92471, 92481, 92491, 92501, 92511, 92521, 92531, 92541, 92551, 92561, 92571, 92581, 92591, 92601, 92611, 92621, 92631, 92641, 92651, 92661, 92671, 92681, 92691, 92701, 92711, 92721, 92731, 92741, 92751, 92761, 92771, 92781, 92791, 92801, 92811, 92821, 92831, 92841, 92851, 92861, 92871, 92881, 92891, 92901, 92911, 92921, 92931, 92941, 92951, 92961, 92971, 92981, 92991, 93001, 93011, 93021, 93031, 93041, 93051, 93061, 93071, 93081, 93091, 93101, 93111, 93121, 93131, 93141, 93151, 93161, 93171, 93181, 93191, 93201, 93211, 93221, 93231, 93241, 93251, 93261, 93271, 93281, 93291, 93301, 93311, 93321, 93331, 93341, 93351, 93361, 93371, 93381, 93391, 93401, 93411, 93421, 93431, 93441, 93451, 93461, 93471, 93481, 93491, 93501, 93511, 93521, 93531, 93541, 93551, 93561, 93571, 93581, 93591, 93601, 93611, 93621, 93631, 93641, 93651, 93661, 93671, 93681, 93691, 93701, 93711, 93721, 93731, 93741, 93751, 93761, 93771, 93781, 93791, 93801, 93811, 93821, 93831, 93841, 93851, 93861, 93871, 93881, 93891, 93901, 93911, 93921, 93931, 93941, 93951, 93961, 93971, 93981, 93991, 94001, 94011, 94021, 94031, 94041, 94051, 94061, 94071, 94081, 94091, 94101, 94111, 94121, 94131, 94141, 94151, 94161, 94171, 94181, 94191, 94201, 94211, 94221, 94231, 94241, 94251, 94261, 94271, 94281, 94291, 94301, 94311, 94321, 94331, 94341, 94351, 94361, 94371, 94381, 94391, 94401, 94411, 94421, 94431, 94441, 94451, 94461, 94471, 94481, 94491, 94501, 94511, 94521, 94531, 94541, 94551, 94561, 94571, 94581, 94591, 94601, 94611, 94621, 94631, 94641, 94651, 94661, 94671, 94681, 94691, 94701, 94711, 94721, 94731, 94741, 94751, 94761, 94771, 94781, 94791, 94801, 94811, 94821, 94831, 94841, 94851, 94861, 94871, 94881, 94891, 94901, 94911, 94921, 94931, 94941, 94951, 94961, 94971, 94981, 94991, 95001, 95011, 95021, 95031, 95041, 95051, 95061, 95071, 95081, 95091, 95101, 95111, 95121, 95131, 95141, 95151, 95161, 95171, 95181, 95191, 95201, 95211, 95221, 95231, 95241, 95251, 95261, 95271, 95281, 95291, 95301, 95311, 95321, 95331, 95341, 95351, 95361, 95371, 95381, 95391, 95401, 95411, 95421, 95431, 95441, 95451, 95461, 95471, 95481, 95491, 95501, 95511, 95521, 95531, 95541, 95551, 95561, 95571, 95581, 95591, 95601, 95611, 95621, 95631, 95641, 95651, 95661, 95671, 95681, 95691, 95701, 95711, 95721, 95731, 95741, 95751, 95761, 95771, 95781, 95791, 95801, 95811, 95821, 95831, 95841, 95851, 95861, 95871, 95881, 95891, 95901, 95911, 95921, 95931, 95941, 95951, 95961, 95971, 95981, 95991, 96001, 96011, 96021, 96031, 96041, 96051, 96061, 96071, 96081, 96091, 96101, 96111, 96121, 96131, 96141, 96151, 96161, 96171, 96181, 96191, 96201, 96211, 96221, 96231, 96241, 96251, 96261, 96271, 96281, 96291, 96301, 96311, 96321, 96331, 96341, 96351, 96361, 96371, 96381, 96391, 96401, 96411, 96421, 96431, 96441, 96451, 96461, 96471, 96481, 96491, 96501, 96511, 96521, 96531, 96541, 96551, 96561, 96571, 96581, 96591, 96601, 96611, 96621, 96631, 96641, 96651, 96661, 96671, 96681, 96691, 96701, 96711, 96721, 96731, 96741, 96751, 96761, 96771, 96781, 96791, 96801, 96811, 96821, 96831, 96841, 96851, 96861, 96871, 96881, 96891, 96901, 96911, 96921, 96931, 96941, 96951, 96961, 96971, 96981, 96991, 97001, 97011, 97021, 97031, 97041, 97051, 97061, 97071, 97081, 97091, 97101, 97111, 97121, 97131, 97141, 97151, 97161, 97171, 97181, 97191, 97201, 97211, 97221, 97231, 97241, 97251, 97261, 97271, 97281, 97291, 97301, 97311, 97321, 97331, 97341, 97351, 97361, 97371, 97381, 97391, 97401, 97411, 97421, 97431, 97441, 97451, 97461, 97471, 97481, 97491, 97501, 97511, 97521, 97531, 97541, 97551, 97561, 97571, 97581, 97591, 97601, 97611, 97621, 97631, 97641, 97651, 97661, 97671, 97681, 97691, 97701, 97711, 97721, 97731, 97741, 97751, 97761, 97771, 97781, 97791, 97801, 97811, 97821, 97831, 97841, 97851, 97861, 97871, 97881, 97891, 97901, 97911, 97921, 97931, 97941, 97951, 97961, 97971, 97981, 97991, 98001, 98011, 98021, 98031, 98041, 98051, 98061, 98071, 98081, 98091, 98101, 98111, 98121, 98131, 98141, 98151, 98161, 98171, 98181, 98191, 98201, 98211, 98221, 98231, 98241, 98251, 98261, 98271, 98281, 98291, 98301, 98311, 98321, 98331, 98341, 98351, 98361, 98371, 98381, 98391, 98401, 98411, 98421, 98431, 98441, 98451, 98461, 98471, 98481, 98491, 98501, 98511, 98521, 98531, 98541, 98551, 98561, 98571, 98581, 98591, 98601, 98611, 98621, 98631, 98641, 98651, 98661, 98671, 98681, 98691, 98701, 98711, 98721, 98731, 98741, 98751, 98761, 98771, 98781, 98791, 98801, 98811, 98821, 98831, 98841, 98851, 98861, 98871, 98881, 98891, 98901, 98911, 98921, 98931, 98941, 98951, 98961, 98971, 98981, 98991, 99001, 99011, 99021, 99031, 99041, 99051, 99061, 99071, 99081, 99091, 99101, 99111, 99121, 99131, 99141, 99151, 99161, 99171, 99181, 99191, 99201, 99211, 99221, 99231, 99241, 99251, 99261, 99271, 99281, 99291, 99301, 99311, 99321, 99331, 99341, 99351, 99361, 99371, 99381, 99391, 99401, 99411, 99421, 99431, 99441, 99451, 99461, 99471, 99481, 99491, 99501, 99511, 99521, 99531, 99541, 99551, 99561, 99571, 99581, 99591, 99601, 99611, 99621, 99631, 99641, 99651, 99661, 99671, 99681, 99691, 99701, 99711, 99721, 99731, 99741, 99751, 99761, 99771, 99781, 99791, 99801, 99811, 99821, 99831, 99841, 99851, 99861, 99871, 99881, 99891, 99901, 99911, 99921, 99931, 99941, 99951, 99961, 99971, 99981, 99991]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/84_prompt1p", "code_candidates": [{"code": "def solve(N: int) -> int:\n    \"\"\"Given a positive integer N, return the total sum of its digits.\n    \n    Example\n        For N = 1000, the sum of digits will be 1, the output should be 1.\n        For N = 150, the sum of digits will be 6, the output should be 6.\n    \"\"\"\n    return sum(int(digit) for digit in str(N))", "index": 0, "passed_case": [0], "case_status": ["1", "6", "12", "9", "18"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/85_prompt1p", "code_candidates": [{"code": "def add(lst: List[int]) -> int:\n    if not lst:\n        return 0\n    return sum(x for x in lst if x % 2 == 0)", "index": 0, "passed_case": [], "case_status": ["92", "134", "10", "22"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/86_prompt1p", "code_candidates": [{"code": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    \"\"\"\n    if not isinstance(s, str):\n        raise ValueError(\"Input must be a string\")\n    \n    return ''.join(sorted(s))", "index": 0, "passed_case": [0, 1, 2, 3, 5], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "!!!HWdellloor", "", "..?HHMMRaabeeeiiimnoooorrssttuwyy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/87_prompt1p", "code_candidates": [{"code": "def get_row(lst, x):\n    if not lst:\n        return None\n    for row in lst:\n        if x in row:\n            return row\n    return None", "index": 0, "passed_case": [], "case_status": ["None", "None", "[1, 2, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/88_prompt1p", "code_candidates": [{"code": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting.\n    Sort the array in ascending order if the sum of the first and last index values is odd.\n    If the sum is even, sort the array in descending order.\n    Handle edge cases such as an empty array by returning it as is, and an array with a single element by returning it as is.\n    \"\"\"\n    if not array:\n        return array\n    \n    first_value = array[0] if array else 0\n    last_value = array[-1] if array else 0\n    sum_indices = first_value + last_value\n    \n    if sum_indices % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/89_prompt1p", "code_candidates": [{"code": "def encrypt(text: str, shift: int = 3) -> str:\n    encrypted_text = \"\"\n    for char in text:\n        if char.isalpha():\n            shift_amount = shift % 26\n            if char.islower():\n                base = ord('a')\n            else:\n                base = ord('A')\n            encrypted_char = chr(base + (ord(char) - base + shift_amount) % 26)\n            encrypted_text += encrypted_char\n        else:\n            encrypted_text += char\n    return encrypted_text", "index": 0, "passed_case": [], "case_status": ["kl", "dvgijkmno", "ji", "hw"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/90_prompt1p", "code_candidates": [{"code": "def next_smallest(lst: list) -> int:\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    if all(x == lst[0] for x in lst):\n        return lst[0]\n    \n    sorted_lst = sorted(lst)\n    smallest = sorted_lst[0]\n    \n    for num in sorted_lst:\n        if num > smallest:\n            return num\n    \n    return smallest", "index": 0, "passed_case": [0, 1, 4, 6], "case_status": ["2", "2", "execution error: 1", "1", "1", "1", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/91_prompt1p", "code_candidates": [{"code": "def is_bored(S: str) -> int:\n    if not S:\n        return 0\n    count = 0\n    for i in range(len(S) - 3):\n        if S[i:i+3] == 'bor':\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 3, 5], "case_status": ["0", "0", "0", "0", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/92_prompt1p", "code_candidates": [{"code": "def any_int(x, y, z):\n    return 10 in (x, y, z) or x > 20 or y > 20 or z > 20", "index": 0, "passed_case": [1, 2, 3, 5, 9], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/93_prompt1p", "code_candidates": [{"code": "def encode(message: str) -> str:\n    if not message:\n        return \"\"\n    \n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    encoded_message = []\n    \n    for char in message:\n        if char.lower() in vowels:\n            if char == 'z':\n                new_char = 'a'\n            elif char == 'Z':\n                new_char = 'A'\n            else:\n                new_char = chr(ord(char) + 1)\n            encoded_message.append(new_char)\n        else:\n            encoded_message.append(char)\n    \n    return ''.join(encoded_message)", "index": 0, "passed_case": [], "case_status": ["TFST", "Mvdbsjr", "YFS", "Thjs js b mfssbgf", "J DpNt KnPw WhBt tP WrJtF"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/94_prompt1p", "code_candidates": [{"code": "def skjkasdkd(numbers: List[int]) -> int:\n    return sum(num ** 2 for num in numbers if num % 2 == 0)", "index": 0, "passed_case": [], "case_status": ["108108", "1700", "6935229388", "526296", "144", "68", "0", "15241383936", "67108864"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/95_prompt1p", "code_candidates": [{"code": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower case. Otherwise, return False.\n    \"\"\"\n    for key in dict:\n        if not isinstance(key, str) or not key.islower():\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 5], "case_status": ["True", "False", "False", "False", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/96_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef first_n_primes(n: int) -> List[int]:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if n == 0:\n        return []\n    \n    primes = []\n    candidate = 2\n    \n    while len(primes) < n:\n        if is_prime(candidate):\n            primes.append(candidate)\n        candidate += 1\n    \n    return primes\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [4], "case_status": ["[2, 3, 5, 7, 11]", "[2, 3, 5, 7, 11, 13]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79]", "[2]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/97_prompt1p", "code_candidates": [{"code": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns the product of the two integers.\"\"\"\n    return a * b", "index": 0, "passed_case": [6, 7], "case_status": ["60976", "532", "3739020", "-210", "5092", "459", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/98_prompt1p", "code_candidates": [{"code": "def count_upper(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in s. Uppercase vowels are defined as 'A', 'E', 'I', 'O', 'U'.\n    \"\"\"\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    for char in s:\n        if char in uppercase_vowels:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 2], "case_status": ["0", "1", "0", "4"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/99_prompt1p", "code_candidates": [{"code": "import math\n\ndef closest_integer(value: str) -> int:\n    # Strip leading and trailing spaces\n    value = value.strip()\n    \n    # Check for non-numeric characters\n    if not value.lstrip('-').replace('.', '', 1).isdigit():\n        raise ValueError(\"String contains non-numeric characters\")\n    \n    # Convert the string to a float\n    try:\n        number = float(value)\n    except OverflowError:\n        raise OverflowError(\"Number is too large to be represented as a float\")\n    \n    # Determine the closest integer\n    if number % 1 == 0.5:\n        # Bankers' rounding: round to the nearest even number\n        integer_part = int(number)\n        if integer_part % 2 == 0:\n            return integer_part\n        else:\n            return integer_part + 1\n    else:\n        # Standard rounding\n        return round(number)\n\n    # If the number is too large to be represented as an integer, raise an OverflowError\n    try:\n        return int(round(number))\n    except OverflowError:\n        raise OverflowError(\"Number is too large to be represented as an integer\")", "index": 0, "passed_case": [0, 3, 4], "case_status": ["10", "14", "-14", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/100_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef create_stone_pile(n: int) -> List[int]:\n    if n <= 0:\n        return []\n    \n    stone_counts = []\n    current_number = n\n    for _ in range(n):\n        stone_counts.append(current_number)\n        if current_number % 2 == 0:\n            current_number += 2\n        else:\n            current_number += 2\n    \n    return stone_counts", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/101_prompt1p", "code_candidates": [{"code": "def words_string(s: str) -> list:\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words.\n    \"\"\"\n    if not s:\n        return []\n    return s.replace(',', ' ').split()", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/102_prompt1p", "code_candidates": [{"code": "def choose_num(x, y):\n    # Ensure x and y are integers\n    x = int(x)\n    y = int(y)\n    \n    # Handle the case where both numbers are zero\n    if x == 0 and y == 0:\n        return 0\n    \n    # Determine the larger number\n    larger = max(x, y)\n    \n    # If the larger number is even, return it\n    if larger % 2 == 0:\n        return larger\n    \n    # If the larger number is odd, find the largest even number less than or equal to it\n    if larger > 0:\n        return larger - 1\n    else:\n        # If larger is negative, return 0 (since we are dealing with positive numbers)\n        return 0\n\n# Example usage:\n# print(choose_num(3, 7))  # Output: 6\n# print(choose_num(4, 8))  # Output: 8\n# print(choose_num(0, 5))  # Output: 4\n# print(choose_num(0, 0))  # Output: 0", "index": 0, "passed_case": [0, 2, 4, 7], "case_status": ["14", "12", "12354", "5234", "28", "26", "6", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/103_prompt1p", "code_candidates": [{"code": "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    \"\"\"\n    if n > m:\n        return 0  # If n is greater than m, the range is empty, so the average is 0.\n    total = sum(range(n, m + 1))\n    count = m - n + 1\n    return round(total / count)", "index": 0, "passed_case": [], "case_status": ["3", "10", "970", "996", "706", "366", "429", "626", "215", "0", "0", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/104_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef filter_unique_digit_numbers(x: List[int]) -> List[int]:\n    def has_unique_digits(num: int) -> bool:\n        digits = str(num)\n        return len(digits) == len(set(digits))\n    \n    if not x:\n        return []\n    \n    unique_digit_numbers = [num for num in x if has_unique_digits(num)]\n    \n    if not unique_digit_numbers:\n        return []\n    \n    return sorted(unique_digit_numbers)", "index": 0, "passed_case": [], "case_status": ["[1, 15]", "[10, 152]", "[12345]", "[31, 103, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/105_prompt1p", "code_candidates": [{"code": "from typing import List, Dict\n\ndef transform_digits(arr: List[int], digit_names: Dict[int, str]) -> List[str]:\n    # Filter and sort the digits between 1 and 9\n    filtered_digits = sorted([num for num in arr if 1 <= num <= 9])\n    \n    # Reverse the sorted list\n    reversed_digits = filtered_digits[::-1]\n    \n    # Replace each digit with its corresponding name\n    result = [digit_names[num] for num in reversed_digits]\n    \n    return result\n\n# Example usage:\ndigit_names = {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'}\narr = [5, 3, 9, 1, 10, 2, 8]\nprint(transform_digits(arr, digit_names))  # Output: ['nine', 'eight', 'five', 'three', 'two', 'one']", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/106_prompt1p", "code_candidates": [{"code": "from math import factorial\nfrom typing import List\n\ndef f(n: int) -> List[int]:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return [factorial(i) if i % 2 == 0 else 1 for i in range(n)]", "index": 0, "passed_case": [2], "case_status": ["[1, 1, 2, 1, 24]", "[1, 1, 2, 1, 24, 1, 720]", "[1]", "[1, 1, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/107_prompt1p", "code_candidates": [{"code": "def count_palindromes(n: int) -> tuple:\n    def is_palindrome(x: int) -> bool:\n        s = str(x)\n        return s == s[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/108_prompt1p", "code_candidates": [{"code": "def count_elements_with_digit_sum(lst: List[int], target_sum: int) -> int:\n    def digit_sum(number: int) -> int:\n        return sum(int(digit) for digit in str(abs(number)))\n    \n    count = 0\n    for number in lst:\n        if digit_sum(number) == target_sum:\n            count += 1\n    return count", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/109_prompt1p", "code_candidates": [{"code": "def move_one_ball(arr):\n    \"\"\"\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N]. The\n    numbers in the array will be randomly ordered. \n    You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n    \"\"\"\n    \n    if not arr:\n        return True\n    \n    # Find the index of the minimum element\n    min_index = arr.index(min(arr))\n    \n    # Check if the array can be formed by right shifts\n    for i in range(1, len(arr)):\n        if arr[(min_index + i) % len(arr)] != sorted(arr)[i]:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/110_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef exchange(lst1: List[int], lst2: List[int]) -> bool:\n    if not lst1 or not lst2:\n        return False\n    if len(lst1) != len(lst2):\n        return False\n    \n    set1 = set(lst1)\n    set2 = set(lst2)\n    \n    return set1.intersection(set2) != set()", "index": 0, "passed_case": [], "case_status": ["True", "True", "True", "False", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/111_prompt1p", "code_candidates": [{"code": "def histogram(test: str) -> dict:\n    result = {}\n    for char in test:\n        if char.isalpha():\n            if char in result:\n                result[char] += 1\n            else:\n                result[char] = 1\n    return result", "index": 0, "passed_case": [0, 2, 3, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2, 'c': 1}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4, 'a': 1}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/112_prompt1p", "code_candidates": [{"code": "def reverse_delete(s: str, c: str) -> bool:\n    # Delete all characters in s that are present in c\n    filtered_s = ''.join([char for char in s if char not in c])\n    \n    # Check if the resulting string is a palindrome\n    return filtered_s == filtered_s[::-1]", "index": 0, "passed_case": [], "case_status": ["False", "False", "True", "False", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/113_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef count_odd_digits(strings: List[str]) -> List[int]:\n    result = []\n    for s in strings:\n        if s == \"\":\n            result.append(0)\n        elif not s.isdigit():\n            result.append(-1)\n        else:\n            odd_count = sum(1 for c in s if int(c) % 2 != 0)\n            result.append(odd_count)\n    return result", "index": 0, "passed_case": [], "case_status": ["[4]", "[1, 8]", "[2, 3, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/114_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef min_subarray_sum(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    min_sum = current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/115_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    if not grid or capacity == 0:\n        return 0\n    \n    total_units = 0\n    for row in grid:\n        for well in row:\n            total_units += min(well, capacity)\n    \n    return total_units", "index": 0, "passed_case": [0, 2], "case_status": ["6", "9", "0", "8", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/116_prompt1p", "code_candidates": [{"code": "def sort_array(arr):\n    \"\"\"\n    Sort an array of non-negative integers based on the number of ones in their binary representation.\n    Sorting order: Ascending by the number of ones.\n    Tie-breaking rule: Ascending by numerical value when the number of ones is the same.\n    \"\"\"\n    # Define a key function that returns a tuple (number of ones, number)\n    def key_func(num):\n        return (bin(num).count('1'), num)\n    \n    # Sort the array using the key function\n    return sorted(arr, key=key_func)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[1, 2, 4, 3, 5]", "[-4, -2, -6, -5, -3]", "[0, 1, 2, 4, 3]", "[]", "[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "[32, 3, 5, 6, 12, 44]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/117_prompt1p", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    # Split the string into words using regex to match sequences of alphabetic characters\n    words = re.findall(r'\\b[a-zA-Z]+\\b', s)\n    # Filter words that are exactly n characters long\n    return [word for word in words if len(word) == n]", "index": 0, "passed_case": [2, 5], "case_status": ["['Mary', 'lamb']", "['had']", "[]", "[]", "['sam']", "[]", "['a', 'b', 'c', 'd', 'e', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/118_prompt1p", "code_candidates": [{"code": "def get_closest_vowel(word: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    for char in word:\n        if char in vowels:\n            return char\n    return None", "index": 0, "passed_case": [1, 5, 6], "case_status": ["o", "u", "e", "e", "a", "a", "o", "a", "a", "u", "a", "A", "A"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/119_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef can_form_valid_parentheses(parentheses_list: List[str]) -> bool:\n    if len(parentheses_list) != 2:\n        raise ValueError(\"The input list must contain exactly two strings.\")\n    \n    for s in parentheses_list:\n        if not isinstance(s, str) or not all(c in '()' for c in s):\n            raise ValueError(\"Each string in the list must consist only of '(' or ')'.\")\n    \n    def is_valid(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = parentheses_list\n    return is_valid(s1 + s2) or is_valid(s2 + s1)", "index": 0, "passed_case": [], "case_status": ["True", "False", "False", "True", "True", "False", "True", "False", "False", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/120_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef maximum(arr: List[int], k: int) -> List[int]:\n    if not arr or k <= 0:\n        return []\n    \n    # Sort the array in descending order and take the top k elements\n    top_k = sorted(arr, reverse=True)[:k]\n    \n    # Return the sorted list in ascending order\n    return sorted(top_k)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[4, 4]", "[2]", "[2, 20, 123]", "[0, 1, 2, 20]", "[-13, -8, 0, 0, 3, 5, 15]", "[3, 5]", "[5]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/121_prompt1p", "code_candidates": [{"code": "def solution(lst: list[int]) -> int:\n    return sum(x for x in lst if x % 2 != 0)", "index": 0, "passed_case": [3], "case_status": ["15", "334", "14", "0", "36", "25"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/122_prompt1p", "code_candidates": [{"code": "def add_elements(arr):\n    \"\"\"\n    Given a non-empty array of integers arr, return the sum of the elements with at most two digits.\n    If arr is empty or no elements have at most two digits, return 0.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    return sum(x for x in arr if -99 <= x <= 99)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/123_prompt1p", "code_candidates": [{"code": "def collatz_odd_sequence(n: int) -> List[int]:\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    odd_numbers = []\n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    odd_numbers.append(1)  # The sequence ends with 1\n    return odd_numbers", "index": 0, "passed_case": [3], "case_status": ["[7, 11, 17, 13, 5, 1]", "[5, 1]", "[3, 5, 1]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/124_prompt1p", "code_candidates": [{"code": "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    # Check if the date matches the 'YYYY-MM-DD' format\n    if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', date):\n        return False\n\n    year, month, day = map(int, date.split('-'))\n\n    # Check if the year is between 1900 and 2099\n    if not (1900 <= year <= 2099):\n        return False\n\n    # Check if the month is between 1 and 12\n    if not (1 <= month <= 12):\n        return False\n\n    # Check if the day is valid for the given month and year\n    try:\n        datetime(year, month, day)\n        return True\n    except ValueError:\n        return False", "index": 0, "passed_case": [1, 2, 5, 6, 7, 9, 11, 12, 13, 15], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/125_prompt1p", "code_candidates": [{"code": "def split_words(txt: str) -> list:\n    if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return [txt]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['Hello', 'world!']", "['Hello', 'world!']", "['Hello', 'world,!']", "['Hello,Hello,world', '!']", "['abcdef']", "['aaabb']", "['aaaBb']", "['']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/126_prompt1p", "code_candidates": [{"code": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number,\n    '''\n    if not lst:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/127_prompt1p", "code_candidates": [{"code": "def intersection(interval1, interval2):\n    \"\"\"\n    Determines whether two closed intervals intersect.\n    \n    Args:\n        interval1 (tuple): A tuple of two integers (start1, end1).\n        interval2 (tuple): A tuple of two integers (start2, end2).\n    \n    Returns:\n        bool: True if the intervals intersect, False otherwise.\n    \"\"\"\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Check if there is any overlap\n    return not (end1 < start2 or end2 < start1)", "index": 0, "passed_case": [], "case_status": ["True", "True", "True", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/128_prompt1p", "code_candidates": [{"code": "def prod_signs(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by \n    \"\"\"\n    if arr is None:\n        return 0\n    \n    total = 0\n    for num in arr:\n        if num > 0:\n            total += num * 1\n        elif num < 0:\n            total += num * -1\n    \n    return total", "index": 0, "passed_case": [4, 5], "case_status": ["9", "1", "10", "0", "20", "4", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/129_prompt1p", "code_candidates": [{"code": "from typing import List\nimport heapq\n\ndef minPath(grid: List[List[int]], k: int) -> int:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    \"\"\"\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Priority queue to store (current_sum, x, y, visited_cells)\n    heap = []\n    \n    # Initialize the heap with all possible starting positions\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(heap, (grid[i][j], i, j, [(i, j)]))\n    \n    while heap:\n        current_sum, x, y, path = heapq.heappop(heap)\n        \n        # If we have reached the required path length, return the sum\n        if len(path) == k:\n            return current_sum\n        \n        # Explore neighbors\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in path:\n                heapq.heappush(heap, (current_sum + grid[nx][ny], nx, ny, path + [(nx, ny)]))\n    \n    # If no path is found, return -1 (though the problem guarantees a solution)\n    return -1", "index": 0, "passed_case": [], "case_status": ["6", "1", "10", "38", "23", "53", "79", "36", "37", "-1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/130_prompt1p", "code_candidates": [{"code": "def tri(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    else:\n        a, b, c = 0, 1, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c", "index": 0, "passed_case": [], "case_status": ["2", "4", "7", "13", "24", "44", "81", "66012", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/131_prompt1p", "code_candidates": [{"code": "def product_of_digits(n: int) -> int:\n    if n == 0:\n        return 0\n    product = 1\n    while n > 0:\n        digit = n % 10\n        product *= digit\n        n = n // 10\n    return product", "index": 0, "passed_case": [0], "case_status": ["5", "20", "0", "15120", "63000", "384"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/132_prompt1p", "code_candidates": [{"code": "def is_nested(s: str) -> bool:\n    stack = []\n    for char in s:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack", "index": 0, "passed_case": [0, 1, 4, 5, 6, 7, 8, 10, 12, 13], "case_status": ["True", "False", "True", "True", "True", "False", "True", "False", "False", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/133_prompt1p", "code_candidates": [{"code": "def sum_squares(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared values.\n    \"\"\"\n    if lst is None:\n        return 0\n    return sum(x ** 2 for x in lst)", "index": 0, "passed_case": [0, 2, 5, 6, 9, 10, 11], "case_status": ["14", "14.0", "84", "19.6", "7.76", "10230", "200000000", "62.809999999999995", "1075.59", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/134_prompt1p", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    if not txt:\n        return False\n    last_char = txt[-1]\n    return last_char.isalpha()", "index": 0, "passed_case": [1, 3, 4, 5, 6, 7, 9], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/135_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef find_largest_index(arr: List[int], value: int) -> int:\n    if not arr:\n        return -1\n    \n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] < value:\n            return i\n    \n    return -1", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/136_prompt1p", "code_candidates": [{"code": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers\n    '''\n    largest_negative = None\n    for num in lst:\n        if isinstance(num, int) and num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n    return (largest_negative, None)", "index": 0, "passed_case": [5, 6, 7, 8], "case_status": ["(None, None)", "(None, None)", "(-2, None)", "(-7, None)", "(-9, None)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, None)", "(-3, None)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/137_prompt1p", "code_candidates": [{"code": "def compare_one(a, b):\n    if isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return a if a > b else b if b > a else None\n    elif isinstance(a, str) and isinstance(b, str):\n        try:\n            a_num = float(a)\n            b_num = float(b)\n            return a if a_num > b_num else b if b_num > a_num else None\n        except ValueError:\n            return None\n    else:\n        return None", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7], "case_status": ["2", "2.5", "3", "6", "None", "None", "2", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/138_prompt1p", "code_candidates": [{"code": "def is_equal_to_sum_even(n: int) -> bool:\n    # Check if n is divisible by 2 and if n/2 is divisible by 2\n    if n % 2 == 0 and (n // 2) % 2 == 0:\n        return True\n    else:\n        return False\n\n# Edge cases:\n# - Negative numbers: Cannot be expressed as sum of 4 even integers\n# - Zero: 0 + 0 + 0 + 0 = 0, which is valid\n# - Very large numbers: If divisible by 4, it can be expressed as sum of 4 even integers", "index": 0, "passed_case": [1, 2, 4, 5, 6, 7], "case_status": ["True", "False", "True", "False", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/139_prompt1p", "code_candidates": [{"code": "def special_factorial(n: int) -> int:\n    if n < 1:\n        return 1\n    \n    result = 1\n    for i in range(1, n + 1):\n        if i % 3 != 0:\n            result *= i\n    \n    return result", "index": 0, "passed_case": [3], "case_status": ["8", "40", "280", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/140_prompt1p", "code_candidates": [{"code": "def replace_spaces_with_underscores(text: str) -> str:\n    if not text:\n        return text\n    return '_'.join(text.split())", "index": 0, "passed_case": [0], "case_status": ["Example", "Mudasir_Hanif", "Yellow_Yellow_Dirty_Fellow", "Exa_mple", "Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/141_prompt1p", "code_candidates": [{"code": "import re\n\ndef is_valid_filename(filename: str) -> str:\n    if not filename:\n        return 'No'\n    if not re.match(r'^[a-zA-Z]', filename):\n        return 'No'\n    if not re.match(r'^[a-zA-Z0-9_.]+$', filename):\n        return 'No'\n    return 'Yes'", "index": 0, "passed_case": [0, 1, 3, 4, 6, 7, 8, 10, 12, 13, 16, 17, 19, 23, 24], "case_status": ["Yes", "No", "Yes", "Yes", "Yes", "Yes", "No", "No", "No", "Yes", "Yes", "Yes", "No", "No", "Yes", "Yes", "Yes", "Yes", "No", "No", "Yes", "Yes", "Yes", "No", "No", "Yes"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/142_prompt1p", "code_candidates": [{"code": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4.\n    The function shall then return the sum of all entries.\n    \"\"\"\n    if lst is None:\n        return 0\n    \n    for i in range(len(lst)):\n        if i % 3 == 0 or i % 4 == 0:\n            lst[i] = lst[i] ** 2\n    \n    return sum(lst)", "index": 0, "passed_case": [0, 1, 2, 3, 5], "case_status": ["6", "14", "0", "9", "1", "0", "24", "3042", "2", "6044", "1252"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/143_prompt1p", "code_candidates": [{"code": "def words_in_sentence(sentence: str) -> str:\n    if not sentence:\n        return \"\"\n    words = sentence.split()\n    return words[0] if words else \"\"", "index": 0, "passed_case": [], "case_status": ["This", "lets", "there", "Hi", "go", "here", "here"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/144_prompt1p", "code_candidates": [{"code": "from math import gcd\n\ndef simplify(x, n):\n    numerator_x, denominator_x = x\n    numerator_n, denominator_n = n\n    \n    # Calculate the new numerator and denominator\n    new_numerator = numerator_x * denominator_n\n    new_denominator = denominator_x * numerator_n\n    \n    # Simplify the fraction by dividing both numerator and denominator by their GCD\n    common_divisor = gcd(new_numerator, new_denominator)\n    simplified_numerator = new_numerator // common_divisor\n    simplified_denominator = new_denominator // common_divisor\n    \n    return (simplified_numerator, simplified_denominator)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/145_prompt1p", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    return sorted(nums, key=lambda x: (sum_of_digits(x), nums.index(x)))", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/146_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef specialFilter(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    return sum(1 for num in nums if num > 10)", "index": 0, "passed_case": [0, 5, 6], "case_status": ["0", "2", "4", "5", "4", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/147_prompt1p", "code_candidates": [{"code": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n    \"\"\"\n    if n < 1:\n        return 0\n    \n    max_triples = 0\n    for i in range(1, n + 1):\n        a_i = i * i - i + 1\n        if a_i > max_triples:\n            max_triples = a_i\n    \n    return max_triples", "index": 0, "passed_case": [], "case_status": ["21", "31", "91", "9901"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/148_prompt1p", "code_candidates": [{"code": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: the closest to the Sun \n    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2. \n    '''\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are in the list\n    if planet1 not in planets or planet2 not in planets:\n        return None\n    \n    # Get the indices of the planets\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    # Return the planet that is closer to the Sun\n    return planet1 if index1 < index2 else planet2", "index": 0, "passed_case": [], "case_status": ["Jupiter", "Mercury", "Mercury", "Venus", "Earth", "Earth", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/149_prompt1p", "code_candidates": [{"code": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings as a parameter,\n    deletes the strings that have odd lengths from it,\n    and returns the sum of the lengths of the remaining strings.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Calculate the sum of the lengths of the remaining strings\n    return sum(len(s) for s in filtered_lst)", "index": 0, "passed_case": [], "case_status": ["2", "12", "0", "8", "6", "0", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/150_prompt1p", "code_candidates": [{"code": "def x_or_y(n: int, x: int, y: int) -> int:\n    if n % 7 == 0 and n % 15 == 0:\n        return x\n    elif n % 7 == 0:\n        return x\n    elif n % 15 == 0:\n        return y\n    else:\n        return None\n\n# Examples\n# n is divisible by 7 and 15\nprint(x_or_y(105, 1, 2))  # Output: 1\n\n# n is divisible by 7 only\nprint(x_or_y(14, 1, 2))   # Output: 1\n\n# n is divisible by 15 only\nprint(x_or_y(30, 1, 2))   # Output: 2\n\n# n is not divisible by 7 or 15\nprint(x_or_y(10, 1, 2))   # Output: None\n\n# Edge case: n is 0\nprint(x_or_y(0, 1, 2))    # Output: 1 (since 0 is divisible by any number)\n\n# Edge case: negative n\nprint(x_or_y(-14, 1, 2))  # Output: 1\nprint(x_or_y(-30, 1, 2))  # Output: 2\nprint(x_or_y(-10, 1, 2))  # Output: None", "index": 0, "passed_case": [0, 1], "case_status": ["34", "5", "None", "None", "None", "None", "56", "None", "None", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/151_prompt1p", "code_candidates": [{"code": "def double_the_difference(lst):\n    \"\"\"\n    Given a list of numbers, return the sum of squares of the positive numbers in the list.\n    If the input list is empty, return 0.\n    \"\"\"\n    if not lst:\n        return 0\n    return sum(x**2 for x in lst if x > 0)", "index": 0, "passed_case": [0, 3, 6], "case_status": ["0", "41", "0.14", "0", "64", "34.04", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/152_prompt1p", "code_candidates": [{"code": "def compare(game: List[int], guess: List[int]) -> Tuple[int, int]:\n    if len(game) != len(guess):\n        raise ValueError(\"The lengths of game and guess must be the same.\")\n    \n    correct_positions = 0\n    correct_numbers = 0\n    \n    # Count correct positions\n    for g, u in zip(game, guess):\n        if g == u:\n            correct_positions += 1\n    \n    # Count correct numbers\n    game_count = {}\n    guess_count = {}\n    \n    for g in game:\n        game_count[g] = game_count.get(g, 0) + 1\n    \n    for u in guess:\n        guess_count[u] = guess_count.get(u, 0) + 1\n    \n    for num in game_count:\n        if num in guess_count:\n            correct_numbers += min(game_count[num], guess_count[num])\n    \n    # Subtract correct positions from correct numbers to avoid double-counting\n    correct_numbers -= correct_positions\n    \n    return (correct_positions, correct_numbers)", "index": 0, "passed_case": [], "case_status": ["(4, 0)", "(6, 0)", "(0, 0)", "(2, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/153_prompt1p", "code_candidates": [{"code": "def Strongest_Extension(class_name: str, extensions: list) -> str:\n    \"\"\"Given a class name (a string) and a list of extensions (strings),\n    calculate the strength of each extension based on the number of uppercase\n    letters (CAP) and lowercase letters (SM) in the extension's name.\n    The strength is defined as CAP - SM.\n    Return the extension with the highest strength.\n    If there are no extensions, return None.\n    If there is a tie, return any of the tied extensions.\n    \"\"\"\n    if not extensions:\n        return None\n    \n    max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        cap = sum(1 for char in extension if char.isupper())\n        sm = sum(1 for char in extension if char.islower())\n        strength = cap - sm\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return strongest_extension", "index": 0, "passed_case": [], "case_status": ["eIGHt8OKe", "YEs.WeCaNe", "NuLl__", "TAR", "123", "okIWILL123", "WoW", "Bb", "671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/154_prompt1p", "code_candidates": [{"code": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    Check if string `b` is a cyclic pattern of string `a`.\n\n    Args:\n        a (str): The main string.\n        b (str): The pattern to check.\n\n    Returns:\n        bool: True if `b` is a cyclic pattern of `a`, False otherwise.\n    \"\"\"\n    if not a or not b:\n        return False\n\n    # Double the main string to account for all cyclic shifts\n    doubled_a = a + a\n\n    # Check if `b` is a substring of the doubled string\n    return b in doubled_a\n\n# Test cases\nprint(cycpattern_check(\"abcd\", \"abd\"))  # False\nprint(cycpattern_check(\"hello\", \"ell\"))  # True\nprint(cycpattern_check(\"whassup\", \"psus\"))  # False\nprint(cycpattern_check(\"abab\", \"baa\"))  # True\nprint(cycpattern_check(\"efef\", \"eeff\"))  # False\nprint(cycpattern_check(\"himenss\", \"simen\"))  # True", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["False", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/155_prompt1p", "code_candidates": [{"code": "def even_odd_count(num: int) -> tuple[int, int]:\n    \"\"\"\n    Counts the number of even and odd digits in a given integer.\n\n    Args:\n        num (int): The integer to analyze.\n\n    Returns:\n        tuple[int, int]: A tuple where the first element is the count of even digits\n                         and the second element is the count of odd digits.\n    \"\"\"\n    # Handle the case where num is 0\n    if num == 0:\n        return (1, 0)\n    \n    # Convert the number to its absolute value to handle negative numbers\n    num = abs(num)\n    \n    even_count = 0\n    odd_count = 0\n    \n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(1, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/156_prompt1p", "code_candidates": [{"code": "def int_to_mini_roman(number: int) -> str:\n    \"\"\"\n    Converts an integer to a minimal Roman numeral representation.\n\n    Restrictions: 1 <= number <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000 inclusive.\")\n\n    roman_numerals = {\n        1000: 'm', 900: 'cm', 500: 'd', 400: 'cd',\n        100: 'c', 90: 'xc', 50: 'l', 40: 'xl',\n        10: 'x', 9: 'ix', 5: 'v', 4: 'iv',\n        1: 'i'\n    }\n\n    result = []\n    for value, numeral in roman_numerals.items():\n        while number >= value:\n            result.append(numeral)\n            number -= value\n\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/157_prompt1p", "code_candidates": [{"code": "def is_right_angled(a: float, b: float, c: float) -> bool:\n    # Create a list of sides and sort them\n    sides = [a, b, c]\n    sides.sort()\n    \n    # Check if the sides form a valid triangle\n    if sides[0] + sides[1] <= sides[2]:\n        raise ValueError(\"The sides do not form a valid triangle.\")\n    \n    # Check the Pythagorean theorem\n    return sides[0]**2 + sides[1]**2 == sides[2]**2", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["True", "execution error: 1", "True", "False", "True", "False", "True", "True", "True", "False", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/158_prompt1p", "code_candidates": [{"code": "def find_max(words):\n    \"\"\"\n    Write a function that accepts a list of strings. The function should return the longest word from the list.\n    If there is a tie, return the word that appears first in the list. Handle edge cases such as an empty list by\n    returning `None`.\n    \"\"\"\n    if not words:\n        return None\n    \n    max_word = words[0]\n    max_length = len(max_word)\n    \n    for word in words:\n        if len(word) > max_length:\n            max_word = word\n            max_length = len(word)\n    \n    return max_word", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "name", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/159_prompt1p", "code_candidates": [{"code": "def eat(number: int, need: int, remaining: int) -> int:\n    if need <= 0:\n        return 0\n    if remaining <= 0:\n        return 0\n    if number >= need:\n        return 0\n    \n    additional_needed = need - number\n    return min(additional_needed, remaining)", "index": 0, "passed_case": [], "case_status": ["1", "4", "9", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/160_prompt1p", "code_candidates": [{"code": "def do_algebra(operator: List[str], operand: List[int]):\n    \"\"\"\n    Given two lists: 'operator', which contains basic algebra operations as strings (e.g., '+', '-'), and 'operand', which is a list of integers.\n    The function should perform the corresponding operations on the integers in sequence.\n    If the lists are of different lengths, the function should raise a ValueError.\n    If the 'operator' list contains invalid operations (not in ['+', '-', '*', '/']), the function should raise a ValueError.\n    \"\"\"\n    # Check if the lists are of different lengths\n    if len(operator) != len(operand):\n        raise ValueError(\"The 'operator' and 'operand' lists must be of the same length.\")\n    \n    # Define valid operations\n    valid_operations = {'+', '-', '*', '/'}\n    \n    # Initialize the result with the first operand\n    result = operand[0]\n    \n    # Iterate through the lists and perform the operations\n    for op, num in zip(operator[1:], operand[1:]):\n        if op not in valid_operations:\n            raise ValueError(f\"Invalid operation: {op}. Valid operations are {valid_operations}.\")\n        if op == '+':\n            result += num\n        elif op == '-':\n            result -= num\n        elif op == '*':\n            result *= num\n        elif op == '/':\n            if num == 0:\n                raise ValueError(\"Division by zero is not allowed.\")\n            result /= num\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/161_prompt1p", "code_candidates": [{"code": "def transform_string(input_str: str) -> str:\n    if input_str is None:\n        return \"\"\n    return input_str[::-1].upper()", "index": 0, "passed_case": [1, 5], "case_status": ["FDSA", "4321", "BA", "C@A#", "54^WFDSA#", "2@6#", "D^A$#", "CCC#"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/162_prompt1p", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if text is None:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "index": 0, "passed_case": [0, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "d41d8cd98f00b204e9800998ecf8427e", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/163_prompt1p", "code_candidates": [{"code": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between\n    \"\"\"\n    if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0):\n        raise ValueError(\"Both a and b must be positive integers.\")\n    \n    even_digits = []\n    for num in range(a, b + 1):\n        digits = [int(d) for d in str(num)]\n        for digit in digits:\n            if digit % 2 == 0:\n                even_digits.append(digit)\n    \n    return even_digits", "index": 0, "passed_case": [], "case_status": ["[2, 4, 6, 8, 0]", "[]", "[]", "[8, 2, 0, 2, 2, 2, 2, 2, 4, 2, 2, 6, 2, 2, 8, 2, 0, 2, 4, 6, 8, 4, 0, 4, 4, 2, 4, 4, 4, 4, 4, 6, 4, 4, 8, 4, 0, 2, 4, 6, 8, 6, 0, 6, 6, 2, 6, 6, 4, 6, 6, 6, 6, 6, 8, 6, 0, 2, 4, 6, 8, 8, 0, 8, 8, 2, 8, 8, 4, 8, 8, 6, 8, 8, 8, 8]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/0_prompt2ac", "code_candidates": [{"code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers meeting a certain condition (e.g. closer to or larger than each other than\n    given threshold).\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    True\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    False\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n\n    for i, num1 in enumerate(numbers):\n        for num2 in numbers[i+1:]:\n            if abs(num1 - num2) < threshold:\n                return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/1_prompt2ac", "code_candidates": [{"code": "from typing import List\nimport re\n\ndef separate_parentheses_groups(s: str) -> List[str]:\n    # Remove all spaces from the input string\n    s = s.replace(\" \", \"\")\n    \n    # Initialize variables\n    result = []\n    stack = []\n    current_group = \"\"\n    \n    for char in s:\n        if char == '(':\n            # Push to stack and start a new group\n            stack.append(char)\n            current_group += char\n        elif char == ')':\n            if stack:\n                # Pop from stack and close the current group\n                stack.pop()\n                current_group += char\n                if not stack:\n                    # If stack is empty, we have a balanced group\n                    result.append(current_group)\n                    current_group = \"\"\n            else:\n                # Unbalanced closing parenthesis, reset current group\n                current_group = \"\"\n        else:\n            # Ignore characters that are not parentheses\n            continue\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/2_prompt2ac", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return a certain part of the number (e.g. integer or decimal or another)\n    >>> truncate_number(3.5)\n    3\n    \"\"\"\n    return int(number)", "index": 0, "passed_case": [], "case_status": ["3", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/3_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef has_negative_balance(operations: List[float]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/4_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(data: List[float]) -> float:\n    if not data:\n        return 0.0\n    if len(data) == 1:\n        return 0.0\n    \n    mean_value = sum(data) / len(data)\n    absolute_deviations = [abs(x - mean_value) for x in data]\n    mad = sum(absolute_deviations) / len(data)\n    \n    return mad", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/5_prompt2ac", "code_candidates": [{"code": "def insert_number(numbers: list, x: int, count: int) -> list:\n    \"\"\"\n    Inserts the number 'x' into the list 'numbers' 'count' times.\n\n    :param numbers: The list to insert into.\n    :param x: The number to insert.\n    :param count: The number of times to insert 'x'.\n    :return: The modified list with 'x' inserted 'count' times.\n    \"\"\"\n    for _ in range(count):\n        numbers.append(x)\n    return numbers", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/6_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by certain characters.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (() ()) has maximum two levels of nesting while ((( ))) has three.\n\n    >>> parse_nested_parens('(()())((()))()((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    current_depth = 0\n    max_depth = 0\n    in_group = False\n\n    for char in paren_string:\n        if char == '(':\n            if in_group:\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            else:\n                in_group = True\n                current_depth = 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n        elif char == ')':\n            if in_group:\n                current_depth -= 1\n                if current_depth == 0:\n                    result.append(max_depth)\n                    max_depth = 0\n                    in_group = False\n\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/7_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef filter_strings_with_substring(input_list: List[str], substring: str) -> List[str]:\n    if not input_list:\n        return []\n    return [s for s in input_list if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/8_prompt2ac", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of the sum and the product of all integers in the list.\n    If the list is empty, return (0, 1).\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    \n    return (total_sum, total_product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/9_prompt2ac", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum elements found until given moment in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_so_far = numbers[0]\n    result = [max_so_far]\n    \n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/10_prompt2ac", "code_candidates": [{"code": "def candidate(string: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    if not string:\n        return string\n\n    for i in range(len(string), 0, -1):\n        if is_palindrome(string[:i]):\n            prefix = string[i:]\n            return string + prefix[::-1]\n\n    # If no palindrome found, return the string reversed\n    return string + string[::-1]", "index": 0, "passed_case": [0, 1, 3], "case_status": ["", "x", "xyzzy", "xyx", "jerryyrre"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/11_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform certain bitwise operation on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '011'\n    \"\"\"\n    if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length\")\n    \n    result = []\n    for char_a, char_b in zip(a, b):\n        if char_a not in '01' or char_b not in '01':\n            raise ValueError(\"Input strings must contain only '0' and '1'\")\n        xor_result = '0' if char_a == char_b else '1'\n        result.append(xor_result)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/12_prompt2ac", "code_candidates": [{"code": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n    None\n    >>> longest(['a', 'b', 'c'])\n    'c'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    return max(strings, key=len)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/13_prompt2ac", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    >>> greatest_common_divisor(12, 18)\n    6\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/14_prompt2ac", "code_candidates": [{"code": "def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return a list of all prefixes of the input string, ordered from longest to shortest.\n    >>> all_prefixes('abc')\n    ['abc', 'ab', 'a']\n    >>> all_prefixes('')\n    []\n    >>> all_prefixes('a')\n    ['a']\n    \"\"\"\n    return [string[:i] for i in range(len(string), 0, -1)]", "index": 0, "passed_case": [0], "case_status": ["[]", "['asdfgh', 'asdfg', 'asdf', 'asd', 'as', 'a']", "['WWW', 'WW', 'W']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/15_prompt2ac", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing dot or space-delimited numbers starting from 0 upto a certain number inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0.1.2.3.4.5'\n    \"\"\"\n    if n < 0:\n        return \"\"\n    return \".\".join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0], "case_status": ["0", "0.1.2.3", "0.1.2.3.4.5.6.7.8.9.10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/16_prompt2ac", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    6\n    >>> count_distinct_characters('Jerry')\n    5\n    \"\"\"\n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    # Use a set to store unique characters\n    unique_characters = set(string)\n    # Return the number of unique characters\n    return len(unique_characters)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/17_prompt2ac", "code_candidates": [{"code": "def parse_notes(notes: str) -> List[int]:\n    note_mapping = {\n        'o': 1,\n        'o|': 2,\n        '.|': 1\n    }\n    parsed_beats = []\n    i = 0\n    while i < len(notes):\n        # Check for 'o|'\n        if i + 1 < len(notes) and notes[i] == 'o' and notes[i + 1] == '|':\n            parsed_beats.append(note_mapping['o|'])\n            i += 2\n        # Check for '.|'\n        elif i + 1 < len(notes) and notes[i] == '.' and notes[i + 1] == '|':\n            parsed_beats.append(note_mapping['.|'])\n            i += 2\n        # Check for 'o'\n        elif notes[i] == 'o':\n            parsed_beats.append(note_mapping['o'])\n            i += 1\n        # Skip unknown symbols\n        else:\n            i += 1\n    return parsed_beats", "index": 0, "passed_case": [0, 2], "case_status": ["[]", "[1, 1, 1, 1]", "[1, 1, 1, 1]", "[2, 2, 1, 1, 1, 1, 1, 1]", "[2, 1, 2, 1, 1, 2, 1, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/18_prompt2ac", "code_candidates": [{"code": "def how_many_times(a: str, b: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    2\n    \"\"\"\n    if not b:\n        return 0\n    \n    count = 0\n    start = 0\n    while True:\n        start = a.find(b, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            break\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/19_prompt2ac", "code_candidates": [{"code": "def sort_numerals_descending(numerals: str) -> str:\n    numeral_to_value = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    \n    # Split the input string by spaces\n    numeral_list = numerals.split()\n    \n    # Filter out invalid numerals and convert valid ones to their numeric values\n    valid_numerals = [numeral_to_value[num] for num in numeral_list if num in numeral_to_value]\n    \n    # If there are no valid numerals, return an empty string\n    if not valid_numerals:\n        return \"\"\n    \n    # Remove duplicates by converting to a set and back to a list\n    unique_numerals = list(set(valid_numerals))\n    \n    # Sort the unique numerals in descending order\n    unique_numerals.sort(reverse=True)\n    \n    # Convert the sorted numeric values back to numeral strings\n    sorted_numerals = [list(numeral_to_value.keys())[list(numeral_to_value.values()).index(num)] for num in unique_numerals]\n    \n    # Join the sorted numeral strings with spaces\n    return ' '.join(sorted_numerals)", "index": 0, "passed_case": [0, 1], "case_status": ["", "three", "nine five three", "nine eight seven five four zero", "six five four three two one zero"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/20_prompt2ac", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef find_pair(numbers: List[int], farthest: bool) -> Tuple[int, int]:\n    if not numbers or len(numbers) < 2:\n        return None, None\n    \n    sorted_numbers = sorted(numbers)\n    if farthest:\n        return sorted_numbers[0], sorted_numbers[-1]\n    else:\n        min_diff = float('inf')\n        pair = (sorted_numbers[0], sorted_numbers[1])\n        for i in range(1, len(sorted_numbers)):\n            diff = sorted_numbers[i] - sorted_numbers[i - 1]\n            if 0 < diff < min_diff:\n                min_diff = diff\n                pair = (sorted_numbers[i - 1], sorted_numbers[i])\n        return pair\n\n# Example usage:\n# For farthest = True\nprint(find_pair([1, 5, 9, 2], True))  # Output: (1, 9)\n\n# For farthest = False\nprint(find_pair([1, 5, 9, 2], False))  # Output: (1, 2)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/21_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef linear_transform(numbers: List[float]) -> List[float]:\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two elements.\")\n    \n    first = numbers[0]\n    last = numbers[-1]\n    \n    if first == last:\n        raise ValueError(\"The first and last elements must be different.\")\n    \n    transformed = []\n    for num in numbers:\n        transformed_num = (num - last) / (first - last)\n        transformed.append(transformed_num)\n    \n    return transformed", "index": 0, "passed_case": [1], "case_status": ["[1.0, -0.0]", "[1.0, 0.0]", "[1.0, 0.75, 0.5, 0.25, -0.0]", "[1.0, 1.5, -0.5, 0.5, -0.0]", "[1.0, 1.5, -0.5, 0.5, -0.0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/22_prompt2ac", "code_candidates": [{"code": "from typing import List, Any\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/23_prompt2ac", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return the length of the Longest Palindrome Substring of the given string.\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    1  # Length of the Longest Palindrome Substring 'a' or 'b' or 'c'\n    \"\"\"\n    n = len(string)\n    if n == 0:\n        return 0\n\n    # Create a table to store results of subproblems\n    dp = [[False] * n for _ in range(n)]\n\n    max_length = 1  # All substrings of length 1 are palindromes\n\n    # Single character palindromes\n    for i in range(n):\n        dp[i][i] = True\n\n    # Check for palindromes of length 2\n    for i in range(n - 1):\n        if string[i] == string[i + 1]:\n            dp[i][i + 1] = True\n            max_length = 2\n\n    # Check for lengths greater than 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if string[i] == string[j] and dp[i + 1][j - 1]:\n                dp[i][j] = True\n                max_length = length\n\n    return max_length", "index": 0, "passed_case": [0, 1], "case_status": ["0", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/24_prompt2ac", "code_candidates": [{"code": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    >>> largest_divisor(25)\n    5\n    >>> largest_divisor(17)\n    1\n    \"\"\"\n    if n <= 1:\n        return 1\n    \n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/25_prompt2ac", "code_candidates": [{"code": "from collections import Counter\nfrom typing import List\n\ndef get_factors_descending(n: int) -> List[int]:\n    if n <= 0:\n        return []\n    \n    factors = []\n    temp = n\n    for i in range(2, n + 1):\n        while temp % i == 0:\n            factors.append(i)\n            temp //= i\n        if temp == 1:\n            break\n    \n    factor_counts = Counter(factors)\n    result = []\n    for factor in sorted(factor_counts.keys(), reverse=True):\n        result.extend([factor] * factor_counts[factor])\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[19, 3]", "[19, 19, 3, 3]", "[19, 19, 19, 3, 3, 3]", "[19, 19, 19, 3]", "[3, 3, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/26_prompt2ac", "code_candidates": [{"code": "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int], K: int) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur exactly K times.\n    Keep the order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4], 1)\n    [1, 3, 4]\n    >>> remove_duplicates([1, 2, 2, 3, 3, 3, 4], 2)\n    [1, 3, 3, 3, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    count = Counter(numbers)\n    return [num for num in numbers if count[num] != K]", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/27_prompt2ac", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase characters to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    >>> flip_case('hello')\n    'HELLO'\n    >>> flip_case('HeLLo')\n    'hEllO'\n    \"\"\"\n    return ''.join(char.lower() if char.isupper() else char.upper() for char in string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/28_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef concatenate_and_reverse_strings(strings: List[str]) -> str:\n    if not strings:\n        return \"\"\n    reversed_strings = strings[::-1]\n    return \" \".join(reversed_strings)", "index": 0, "passed_case": [0], "case_status": ["", "z y x", "k w z y x"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/29_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with the given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/30_prompt2ac", "code_candidates": [{"code": "def get_positive(l: list): \n    return [x for x in l if x < 0]", "index": 0, "passed_case": [3], "case_status": ["[-1, -2]", "[-5, -10]", "[-1, -2]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/31_prompt2ac", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False", "index": 0, "passed_case": [], "case_status": ["True", "False", "False", "False", "False", "True", "True", "False", "False", "False", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/32_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef candidate(xs: List[float]) -> float:\n    # Check if the list has an even number of coefficients\n    if len(xs) % 2 != 0:\n        raise ValueError(\"The list 'xs' must have an even number of coefficients.\")\n    \n    # Check if the largest non-zero coefficient is present\n    if all(x == 0 for x in xs):\n        raise ValueError(\"The list 'xs' must contain at least one non-zero coefficient.\")\n    \n    # Define the polynomial function\n    def polynomial(x: float) -> float:\n        return sum(coef * (x ** i) for i, coef in enumerate(xs))\n    \n    # Bisection method parameters\n    a, b = -1000, 1000  # Initial interval\n    tol = 1e-6  # Tolerance for convergence\n    max_iter = 1000  # Maximum number of iterations\n    \n    # Ensure the signs of the polynomial at the endpoints are different\n    if polynomial(a) * polynomial(b) > 0:\n        raise ValueError(\"The polynomial does not change sign over the initial interval.\")\n    \n    # Bisection method implementation\n    for _ in range(max_iter):\n        c = (a + b) / 2\n        if abs(polynomial(c)) < tol or (b - a) / 2 < tol:\n            return c\n        if polynomial(c) * polynomial(a) < 0:\n            b = c\n        else:\n            a = c\n    \n    raise ValueError(\"Bisection method did not converge within the maximum number of iterations.\")", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/33_prompt2ac", "code_candidates": [{"code": "def sort_third(l: list):\n    if not l:\n        return l\n\n    indices_to_sort = [i for i in range(len(l)) if (i + 1) % 3 == 0]\n    values_to_sort = [l[i] for i in indices_to_sort]\n    values_to_sort.sort(reverse=True)\n\n    for idx, val in zip(indices_to_sort, values_to_sort):\n        l[idx] = val\n\n    return l", "index": 0, "passed_case": [], "case_status": ["[5, 6, 9, 4, 8, 3, 2]", "[5, 8, 9, 4, 6, 3, 2]", "[5, 6, 9, 4, 8, 3, 2]", "[5, 6, 9, 4, 8, 3, 2, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/34_prompt2ac", "code_candidates": [{"code": "def unique(l: list): \n    return sorted(set(l))", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/35_prompt2ac", "code_candidates": [{"code": "def max_element(l: list): \n    if not l:\n        raise ValueError(\"The list is empty\")\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/36_prompt2ac", "code_candidates": [{"code": "def fizz_buzz(n: int) -> int:\n    if n <= 0:\n        return 0\n    \n    count = 0\n    limit = n * n\n    \n    for i in range(1, limit):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    \n    return count", "index": 0, "passed_case": [], "case_status": ["113", "289", "295", "639", "2560", "1704904", "Timeout", "Timeout"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/37_prompt2ac", "code_candidates": [{"code": "def sort_even(l: list):\n    if not l:\n        return\n    \n    # Extract values at even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort even values in descending order\n    even_values.sort(reverse=True)\n    \n    # Reassign sorted even values back to the list\n    for i, value in enumerate(even_values):\n        l[2 * i] = value\n\n# Example usage:\n# l = [3, 1, 2, 4, 5, 0]\n# sort_even(l)\n# print(l)  # Output: [5, 1, 3, 4, 2, 0]", "index": 0, "passed_case": [], "case_status": ["None", "None", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/38_prompt2ac", "code_candidates": [{"code": "def candidate(s: str) -> str:\n    \"\"\"\n    Takes as input a string decoded with the encode_cyclic function. Returns the encoded or decoded string based on a specified condition or input characteristics.\n    \"\"\"\n    # Placeholder logic for demonstration purposes\n    # In a real implementation, this would check the input characteristics or condition\n    if s.startswith(\"encoded:\"):\n        return s[len(\"encoded:\"):]  # Return the decoded string\n    else:\n        return \"encoded:\" + s  # Return the encoded string", "index": 0, "passed_case": [], "case_status": ["encoded:axdhhixdexrvsncacbgh", "encoded:artwugrnwoshzaizfy", "encoded:iekykgcmdlldiztb", "encoded:dmrrjctlugwsbvchy", "encoded:hdciomlfulglvi", "encoded:ctufruhfxmiowruvkhyy", "encoded:bzhmikgscw", "encoded:upguomieexrhixr", "encoded:smnhelpcqbdyufevnzt", "encoded:mtmqioavrxd", "encoded:yirukyjndoafxixyfqqd", "encoded:uqjgetyflyqrtkaadplz", "encoded:bhhccspcxryyee", "encoded:rfpqtigrnxwywjgvumlo", "encoded:dhockhsrashhcwabhu", "encoded:kcbhiqpgvre", "encoded:phspzzgdnvndnnlxbov", "encoded:dbuxkmdhzgrgenoiofhc", "encoded:rdzurbcyafnhpgpmb", "encoded:ammzzijnoxzw", "encoded:wpvgjebsgrbxkbxspb", "encoded:fbqcfqtcchmvshdtbs", "encoded:nvcsqsigkwkvimhvuej", "encoded:yckotadcsgqrelich", "encoded:fojwjrzutavqjvr", "encoded:idexrdijetg", "encoded:vugqpibciniuakb", "encoded:ifuorxnrwdca", "encoded:blrresebnlzj", "encoded:gvlvdhyrln", "encoded:ehxzzfnafxkfnzzxzvh", "encoded:zwfmbdhgpljozh", "encoded:vgakimyicuqlm", "encoded:karifdibstndxzlntkqd", "encoded:giswnbqzavxrxvxg", "encoded:cvntkkdxvqjjnkv", "encoded:jrwgnemvvftxjmsr", "encoded:jgjzsnukto", "encoded:vgopzqxfzcjvvuqtk", "encoded:hvyhzjeagbh", "encoded:yctnuogwsmpwhemuw", "encoded:ydynhyzwfq", "encoded:rhboedovzrtqyoktx", "encoded:ronxpfiyouihyqyuhp", "encoded:cwohijkrkeechm", "encoded:gcwnknonrgnb", "encoded:swyysapamjylnrmx", "encoded:thzhippankvmzmvfox", "encoded:ratssmacvneu", "encoded:bifkgmkkomiyniycp", "encoded:rbxhulyucb", "encoded:gahehtpved", "encoded:owgylittfwdxfjysadj", "encoded:mmvgcwwusdwhjvyzdtz", "encoded:blznvrcqlkaupdnluno", "encoded:fxnuiqzrtpoy", "encoded:sixhckohiosyvmtk", "encoded:kfpglpikzi", "encoded:irwqgahxcprnhwyuwpp", "encoded:aczhmjhjwslvrqpln", "encoded:lwkijohdigkxxrdwfy", "encoded:xpgxsiqtydgjj", "encoded:fjlwraiberjbw", "encoded:ypuasdppjkfo", "encoded:pdimpcsucv", "encoded:ezejcsdrhy", "encoded:tzthytmoqjsojsnt", "encoded:xdtguyivgc", "encoded:frhfacownpjt", "encoded:jwhwojvhci", "encoded:vzsndghurieebfcjtzxs", "encoded:doojwwiqmporct", "encoded:xkniathvcs", "encoded:yvasbiyfyqupifonusp", "encoded:lnpkvkfkdnw", "encoded:vmjrbyckokdimqyav", "encoded:nboqlgyptoyugibejr", "encoded:pdwutahwzjrfrnach", "encoded:duopweqwjin", "encoded:hopemrtqgecxyzink", "encoded:ajijsxvpsorelkpyrr", "encoded:kgohswhymbknpwxz", "encoded:vzmepueqbkdsdqoo", "encoded:enxecuzipk", "encoded:muwkvcmkrwyurbpchtu", "encoded:hxjndcuwyofdjawkzbbj", "encoded:nelqnhvzsffftmc", "encoded:hpvehsuioivozoavrjf", "encoded:lsounjiowjg", "encoded:dhpslmjwsavjiams", "encoded:xbyxptyzjtzhhultigvy", "encoded:euvuudjzbbsoxeljkcxn", "encoded:ezglqrifqpzi", "encoded:kzxocdyhexvvmz", "encoded:czlaimdorvxlisvulm", "encoded:hpvtrathkuc", "encoded:wjondubbepdjhrdmoelv", "encoded:sxnenxdpunitwlboog", "encoded:dvlrulbmlgdio", "encoded:guvtauzkbhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/39_prompt2ac", "code_candidates": [{"code": "from typing import List\nimport math\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef fibonacci_sequence(limit: int) -> List[int]:\n    fib_sequence = [0, 1]\n    while True:\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        if next_fib > limit:\n            break\n        fib_sequence.append(next_fib)\n    return fib_sequence\n\ndef prime_fib(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer.\")\n    \n    fib_numbers = fibonacci_sequence(1000000)  # Arbitrary large limit\n    prime_fib_numbers = [num for num in fib_numbers if is_prime(num)]\n    \n    if n > len(prime_fib_numbers):\n        raise ValueError(\"Not enough prime Fibonacci numbers found within the given limit.\")\n    \n    return prime_fib_numbers[n-1]\n\n# Examples\n# print(prime_fib(1))  # Output: 2\n# print(prime_fib(2))  # Output: 3\n# print(prime_fib(3))  # Output: 5\n# print(prime_fib(4))  # Output: 13\n# print(prime_fib(5))  # Output: 89", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/40_prompt2ac", "code_candidates": [{"code": "def triples_sum_to_zero(l: list) -> bool:\n    \"\"\"\n    Return True if there are three distinct elements in the list that sum to zero, and False otherwise.\n    \"\"\"\n    # Handle edge cases\n    if len(l) < 3:\n        return False\n\n    # Sort the list to make it easier to find triplets\n    l.sort()\n\n    # Iterate through the list to find triplets\n    for i in range(len(l) - 2):\n        # Skip duplicates\n        if i > 0 and l[i] == l[i - 1]:\n            continue\n\n        left = i + 1\n        right = len(l) - 1\n\n        while left < right:\n            current_sum = l[i] + l[left] + l[right]\n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/41_prompt2ac", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    \"\"\"Determine if the integer `n` is a prime number.\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [], "case_status": ["True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/42_prompt2ac", "code_candidates": [{"code": "def incr_list(l: list) -> list:\n    return [x + 2 for x in l]", "index": 0, "passed_case": [0], "case_status": ["[]", "[5, 4, 3]", "[7, 4, 7, 4, 5, 5, 11, 2, 125]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/43_prompt2ac", "code_candidates": [{"code": "def pairs_sum_to_zero(l):\n    # Handle edge cases\n    if not l or len(l) < 2:\n        return False\n\n    # Use a set to store seen elements\n    seen = set()\n\n    for num in l:\n        # Check if the negative of the current number has been seen\n        if -num in seen:\n            return True\n        seen.add(num)\n\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/44_prompt2ac", "code_candidates": [{"code": "def change_base(x: int, y: int) -> str:\n    if y < 2 or y >= 10:\n        raise ValueError(\"Base y must be between 2 and 9 inclusive.\")\n    \n    if x == 0:\n        return \"0\"\n    \n    result = []\n    is_negative = x < 0\n    x = abs(x)\n    \n    while x > 0:\n        result.append(str(x % y))\n        x = x // y\n    \n    if is_negative:\n        result.append(\"-\")\n    \n    return ''.join(reversed(result))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/45_prompt2ac", "code_candidates": [{"code": "def triangle_area(x, y):\n    \"\"\"Given length of a side and height, return the area of a triangle.\n    >>> triangle_area(5, 3)\n    15\n    \"\"\"\n    return x * y / 2", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/46_prompt2ac", "code_candidates": [{"code": "def fib4(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    \n    # Initialize the first four elements\n    fib_sequence = [0, 0, 2, 0]\n    \n    # Compute the sequence iteratively\n    for i in range(4, n + 1):\n        next_fib = fib_sequence[i - 1] + fib_sequence[i - 2] + fib_sequence[i - 3] + fib_sequence[i - 4]\n        fib_sequence.append(next_fib)\n    \n    return fib_sequence[n]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["4", "28", "104", "386"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/47_prompt2ac", "code_candidates": [{"code": "from typing import List, Optional\n\ndef get_max_value(lst: List[int]) -> Optional[int]:\n    if not lst:\n        return None\n    if not all(isinstance(x, int) for x in lst):\n        raise ValueError(\"List contains non-numeric values\")\n    return max(lst)", "index": 0, "passed_case": [2], "case_status": ["5", "1000", "5", "6", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/48_prompt2ac", "code_candidates": [{"code": "def is_palindrome(text: str) -> bool:\n    \"\"\"Checks if the given string is a palindrome.\n    \n    A palindrome is a string that reads the same forwards and backwards.\n    \n    Args:\n        text (str): The string to check.\n    \n    Returns:\n        bool: True if the string is a palindrome, False otherwise.\n    \"\"\"\n    if not text:\n        return True  # An empty string is considered a palindrome\n    \n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    \n    return cleaned_text == cleaned_text[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/49_prompt2ac", "code_candidates": [{"code": "def return_second_parameter(x: int, y: int) -> int:\n    return y", "index": 0, "passed_case": [], "case_status": ["5", "101", "101", "11", "101", "5", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/50_prompt2ac", "code_candidates": [{"code": "def encode_string(s: str) -> str:\n    encoded_chars = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            encoded_char = chr((ord(char) - ord('a') + 3) % 26 + ord('a'))\n            encoded_chars.append(encoded_char)\n        elif 'A' <= char <= 'Z':\n            encoded_char = chr((ord(char) - ord('A') + 3) % 26 + ord('A'))\n            encoded_chars.append(encoded_char)\n        else:\n            encoded_chars.append(char)\n    return ''.join(encoded_chars)", "index": 0, "passed_case": [], "case_status": ["lifqppmfldfzkavjikop", "bizoecezvpwaqhighn", "sqmogslkulttbqhj", "zlukzrcbtaoekjdpg", "kpluqwctnttodq", "ckbcnzfpnwuqcezpdsgg", "pjhsuqkoae", "ocxucwmqmpfzzqf", "vautpmyxkgjlmcnhdvb", "uubwyqzidfl", "zgqgcslrvnwiffqygnyl", "rcybomtgnzgyibsxilth", "pjpakkfxkgzgmm", "xznqybvozgfeoerudctw", "wlppksiazpapikecjp", "jskypqdxozm", "axphxhvolldvtvvwfjd", "cljufshlpoozwmvnqwpk", "hzljczikgpnvxxouj", "uiuqhhwrvefh", "dexmorojafzjfsjjax", "ynjyknkbkdpulapabj", "kvdaaysqodespqumdcr", "sgkiwbalkzoyqmtkp", "rnwzerbhcyidzrd", "mqllfzmqrbo", "odcqyxqjkcvqjis", "cqnfwzevzilk", "zjtazmvmjrth", "todpdltgzv", "fmpnhhnvinfshvhdfhp", "nhelujxpowtrhp", "idousqkgqtcyu", "zsilqnaqjlbvtfhsvbyl", "aoqjeviyhzdfffdo", "vkdsbsdlfryrdvs", "erzmovdudfnbaruz", "rrovhabcsw", "wdoyxhhfndkrydcbs", "gpdrphomijp", "bgkwvcaoeeuxupmce", "gglgvpnhey", "jzplwmhwdyzbsgwbf", "vzwnfxwqgpcqggyxcp", "wkerpqsszkmmpu", "eokvvszwvjov", "gaeigauxitrguvzf", "hbpxpqvxiusddhufnw", "bziuaadikcvm", "njqusowssguqgvqkx", "fzjtpckgcj", "poibmpmxdl", "oweqgtnbbfelgnrlair", "duueokaecplegrdbhlh", "hjtzvdtkycsivxlvtcw", "vnfycqbhzgxw", "faqspkqwpgwabdus", "xsnxothqsq", "eqziyokpfvxzgpexcex", "hikrpueprdatxzytv", "stewqrqplfoslfzgen", "ofxqfagybrlor", "tnriezmqjjzre", "cgxliarxxwsn", "qxlkuxkacd", "mmharkplzg", "bbhbpgyuwwravrab", "bflgocoqdk", "pnzknivwebxr", "prerewkdpq", "adhovlzpcmqmkjnhrbfa", "wlwereuqyzxwkb", "vfsbqikpda", "igdqajggnxycwqnavcx", "xtvssdlnsve", "rdugzjwksqslguyid", "wvjoytbgxcwgjoqzmr", "exlicbhpenrzizvkp", "wlcmxeryeqv", "xpwzmuobyfmkqghvs", "qirfraadxmwzxtszgz", "wsoepaupgvjsfxeh", "udhcmxjmyaslwlyw", "fmvcmkxhqs", "eucksdzuscegxzjbkpc", "rpfkvlgcelwnerijshjr", "tvmpyvadhnnnkbu", "dpxampwcqwqdihwrdzn", "wtarcveqwro", "xlpuatareriduqia", "gfjbfxrghpbhtpcobqdg", "dmclccjrhwjatfmkrsfv", "omhztyyqnqxh", "fshlwkmgpdfduh", "tkhuiqzlwtdfdqauct", "dpxibzsbpck", "wercvlmjjrxllpzmuwtd", "vaffmvclxbvqjetoww", "tldtzctjuqolw", "doccbijhspm"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/51_prompt2ac", "code_candidates": [{"code": "def remove_vowels(input_string: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in input_string if char not in vowels])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/52_prompt2ac", "code_candidates": [{"code": "def below_threshold(l: list, t: int) -> bool:\n    if not l:\n        return True\n    return all(x <= t for x in l)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/53_prompt2ac", "code_candidates": [{"code": "def perform_operation(operation: str, a: int, b: int) -> int:\n    if operation == 'add':\n        return a + b\n    elif operation == 'multiply':\n        return a * b\n    elif operation == 'subtract':\n        return a - b\n    else:\n        raise ValueError(\"Invalid operation. Supported operations are 'add', 'multiply', and 'subtract'.\")", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/54_prompt2ac", "code_candidates": [{"code": "def same_chars(s0: str, s1: str) -> bool:\n    # Handle edge case where both strings are empty\n    if s0 == \"\" and s1 == \"\":\n        return True\n    \n    # If the lengths of the strings are different, s1 cannot form s0\n    if len(s0) != len(s1):\n        return False\n    \n    # Count the frequency of each character in both strings\n    from collections import Counter\n    return Counter(s0) == Counter(s1)", "index": 0, "passed_case": [3, 4, 5, 6], "case_status": ["False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/55_prompt2ac", "code_candidates": [{"code": "def fib(n: int) -> int:\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/56_prompt2ac", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has K corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    True\n    >>> correct_bracketing(\"<>\")\n    False\n    >>> correct_bracketing(\"<<><>>\")\n    False\n    >>> correct_bracketing(\"><<>\")\n    True\n    \"\"\"\n    count = 0\n    for bracket in brackets:\n        if bracket == '<':\n            count += 1\n        elif bracket == '>':\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/57_prompt2ac", "code_candidates": [{"code": "def monotonic(l: list):\n    \"\"\"Return True if the list elements are strictly increasing or strictly decreasing.\n    If the list is empty or contains a single element, return True.\n    >>> monotonic([1, 2, 4, 20])\n    False\n    >>> monotonic([1, 20, 4, 10])\n    True\n    >>> monotonic([4, 1, 0, -10])\n    False\n    >>> monotonic([])\n    True\n    >>> monotonic([5])\n    True\n    \"\"\"\n    if not l or len(l) == 1:\n        return True\n    \n    increasing = all(l[i] < l[i+1] for i in range(len(l)-1))\n    decreasing = all(l[i] > l[i+1] for i in range(len(l)-1))\n    \n    return increasing or decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 5, 6], "case_status": ["True", "True", "False", "True", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/58_prompt2ac", "code_candidates": [{"code": "def common(l1: list, l2: list) -> list:\n    # Find common elements using set intersection\n    common_elements = set(l1).intersection(set(l2))\n    \n    # Convert the set to a sorted list in descending order\n    sorted_common_elements = sorted(common_elements, reverse=True)\n    \n    return sorted_common_elements", "index": 0, "passed_case": [3], "case_status": ["[653, 5, 1]", "[3, 2]", "[4, 3, 2]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/59_prompt2ac", "code_candidates": [{"code": "def largest_prime_factor(n: int) -> int:\n    def is_prime(x: int) -> bool:\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            other_factor = n // i\n            if is_prime(other_factor):\n                return other_factor\n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/60_prompt2ac", "code_candidates": [{"code": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    A function that sums up all numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    if n < 1:\n        return 0\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/61_prompt2ac", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    \n    for char in brackets:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n        else:\n            return False  # If there are characters other than brackets\n    \n    return not stack", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/62_prompt2ac", "code_candidates": [{"code": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return first or second derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [20, 12, 4, 1]\n    >>> derivative([1, 2, 3])\n    [6, 2]\n    \"\"\"\n    if not xs:\n        return []\n    \n    # Determine the order of the derivative\n    if len(xs) < 2:\n        return []\n    \n    # Calculate the first derivative\n    first_derivative = [xs[i] * i for i in range(1, len(xs))]\n    \n    # Calculate the second derivative\n    second_derivative = [first_derivative[i] * i for i in range(1, len(first_derivative))]\n    \n    # Return the second derivative if it exists, otherwise return the first derivative\n    return second_derivative if second_derivative else first_derivative", "index": 0, "passed_case": [4], "case_status": ["[4, 24, 60]", "[6]", "[2]", "[2, 0, 48]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/63_prompt2ac", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute an element of the fibfib number sequence.\n    >>> fibfib(0)\n    0\n    >>> fibfib(1)\n    0\n    >>> fibfib(2)\n    1\n    >>> fibfib(3)\n    1\n    >>> fibfib(4)\n    2\n    >>> fibfib(5)\n    4\n    >>> fibfib(6)\n    8\n    >>> fibfib(7)\n    15\n    >>> fibfib(8)\n    29\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/64_prompt2ac", "code_candidates": [{"code": "def vowels_count(s: str) -> int:\n    if not s:\n        return 0\n    \n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    \n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    \n    # Check if 'y' is at the end of the word\n    if s and s[-1].lower() == 'y':\n        count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/65_prompt2ac", "code_candidates": [{"code": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits left or right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"12\"\n    >>> circular_shift(12, 2)\n    \"21\"\n    \"\"\"\n    x_str = str(x)\n    length = len(x_str)\n    \n    if shift > length:\n        return x_str[::-1]\n    \n    shift = shift % length  # Ensure shift is within the bounds of the number of digits\n    \n    if shift == 0:\n        return x_str\n    \n    shifted_str = x_str[shift:] + x_str[:shift]\n    return shifted_str", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["010", "12", "79", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/66_prompt2ac", "code_candidates": [{"code": "def upperCountSum(s: str) -> int:\n    return sum(1 for char in s if char.isupper())", "index": 0, "passed_case": [0], "case_status": ["0", "2", "1", "1", "2", "2", "2", "4"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/67_prompt2ac", "code_candidates": [{"code": "def fruit_distribution(s, n):\n    # Calculate the number of mangoes by subtracting the total number of apples and oranges from the total number of fruits\n    return s - n", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/68_prompt2ac", "code_candidates": [{"code": "def pluck(arr):\n    \"\"\"\n    Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the value.\n    If multiple nodes with the value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ value, its index ],\n    If there are no values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [4, 0]\n        Explanation\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [3, 2]\n        Explanation\n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [5, 0]\n        Explanation\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if not arr:\n        return []\n    \n    # Find the node with the maximum value and the smallest index\n    max_value = -1\n    max_index = -1\n    \n    for index, value in enumerate(arr):\n        if value > max_value:\n            max_value = value\n            max_index = index\n    \n    return [max_value, max_index]", "index": 0, "passed_case": [2], "case_status": ["[4, 0]", "[3, 2]", "[]", "[5, 0]", "[5, 4]", "[8, 2]", "[7, 0]", "[9, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/69_prompt2ac", "code_candidates": [{"code": "from collections import Counter\n\ndef search(lst):\n    # Count the frequency of each integer in the list\n    frequency = Counter(lst)\n    \n    # Initialize the result to -1\n    result = -1\n    \n    # Iterate through the frequency dictionary\n    for num, freq in frequency.items():\n        # Check if the number is greater than zero and its frequency matches its value\n        if num > 0 and freq == num:\n            # If result is -1 or the current number is smaller than the result, update the result\n            if result == -1 or num < result:\n                result = num\n                \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7, 8, 12, 13, 16, 19, 20, 24], "case_status": ["1", "4", "-1", "8", "-1", "-1", "2", "1", "-1", "-1", "-1", "3", "1", "4", "1", "-1", "4", "1", "1", "-1", "-1", "-1", "-1", "-1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/70_prompt2ac", "code_candidates": [{"code": "def strange_sort_list(lst):\n    '''\n    Given a list of integers, return the list sorted in a 'strange' order.\n    The 'strange' sorting starts with the minimum value, then the maximum of the remaining integers,\n    then the next minimum, and so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n    if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left, right = 0, len(sorted_lst) - 1\n    \n    while left <= right:\n        if left == right:\n            result.append(sorted_lst[left])\n        else:\n            result.append(sorted_lst[left])\n            result.append(sorted_lst[right])\n        left += 1\n        right -= 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/71_prompt2ac", "code_candidates": [{"code": "def triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the perimeter\n        perimeter = a + b + c\n        # Return the perimeter rounded to 2 decimal points\n        return round(perimeter, 2)\n    else:\n        # Return -1 if the sides do not form a valid triangle\n        return -1", "index": 0, "passed_case": [1, 4, 6, 8], "case_status": ["12", "-1", "17", "6", "-1", "22", "-1", "3", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/72_prompt2ac", "code_candidates": [{"code": "def will_it_fly(q, w):\n    '''\n    Returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is more than or less than or equal the weight w.\n    '''\n    # Check if q is a palindromic list\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of elements in q\n    total_weight = sum(q)\n    \n    # Determine if the object will fly based on the conditions\n    return is_balanced and total_weight != w\n\n# Example usage:\n# print(will_it_fly([1, 2], 5))  # \u279e True\n# print(will_it_fly([3, 2, 3], 1))  # \u279e True\n# print(will_it_fly([3, 2, 3], 9))  # \u279e False\n# print(will_it_fly([3], 5))  # \u279e False", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/73_prompt2ac", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that need to be changed \n    to make the array palindromic. A palindromic array is an array that is read the same backwards \n    and forwards. In one change, you can change one element to any other element. \n    The function should return the minimum number of changes required.\n    \"\"\"\n    if not arr:\n        return 0\n\n    changes = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n\n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/74_prompt2ac", "code_candidates": [{"code": "def total_match(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has\n    the total number of characters in all strings of the list more than the other list.\n\n    If the two lists have the same number of characters, return the first list.\n\n    Examples\n    total_match([], []) \u279e []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) \u279e ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) \u279e ['hi', 'hi', 'admin', 'project']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) \u279e ['hi', 'admin']\n    total_match(['4'], ['1', '2', '3', '4', '5']) \u279e ['1', '2', '3', '4', '5']\n    '''\n    def total_chars(lst):\n        return sum(len(s) for s in lst)\n\n    total_chars_lst1 = total_chars(lst1)\n    total_chars_lst2 = total_chars(lst2)\n\n    if total_chars_lst1 >= total_chars_lst2:\n        return lst1\n    else:\n        return lst2", "index": 0, "passed_case": [0, 6], "case_status": ["[]", "['hi', 'admin']", "['hi', 'hi', 'admin', 'project']", "['1', '2', '3', '4', '5']", "['hi', 'admin']", "['hi', 'admin']", "['hi', 'admin']", "['this']", "['this']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/75_prompt2ac", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_multiply_prime(a: int) -> bool:\n    if a < 2:\n        return False\n    \n    prime_factors = 0\n    for i in range(2, a):\n        if a % i == 0 and is_prime(i):\n            prime_factors += 1\n            if prime_factors > 2:\n                return False\n    return prime_factors == 2\n\n# Example usage:\n# print(is_multiply_prime(30))  # Output: False", "index": 0, "passed_case": [0, 6, 7], "case_status": ["False", "False", "False", "True", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/76_prompt2ac", "code_candidates": [{"code": "def is_simple_power(a, b):\n    \"\"\"\n    Returns true if a number a is a simple power of b, false otherwise.\n    A number a is a simple power of b if b**k = a for some integer k.\n    \"\"\"\n    if b == 1:\n        # Any number is a power of 1, except when a is not 1\n        return a == 1\n    \n    power = 1\n    while power < a:\n        power *= b\n    \n    return power == a\n\n# Examples\nprint(is_simple_power(1, 4))  # False\nprint(is_simple_power(2, 2))  # False\nprint(is_simple_power(8, 2))  # False\nprint(is_simple_power(3, 2))  # True\nprint(is_simple_power(3, 1))  # True\nprint(is_simple_power(5, 3))  # True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/77_prompt2ac", "code_candidates": [{"code": "import math\n\ndef iscube(a: int) -> bool:\n    if a < 0:\n        a = -a\n    \n    cube_root = round(a ** (1/3))\n    \n    return cube_root ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/78_prompt2ac", "code_candidates": [{"code": "def hex_key(num: str) -> int:\n    # Define the prime hexadecimal digits\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Handle the edge case of an empty string\n    if not num:\n        return 0\n    \n    # Count the number of prime digits in the input string\n    count = 0\n    for digit in num:\n        if digit in prime_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/79_prompt2ac", "code_candidates": [{"code": "def decimal_to_binary(decimal):\n    \"\"\"\n    Converts a decimal number to a binary string with 'db' characters at different positions.\n\n    Parameters:\n    decimal (int): The decimal number to convert.\n\n    Returns:\n    str: The binary representation with 'db' characters.\n    \"\"\"\n    if not isinstance(decimal, int):\n        raise ValueError(\"Input must be an integer.\")\n    \n    binary_str = \"\"\n    if decimal == 0:\n        binary_str = \"0\"\n    else:\n        while decimal > 0:\n            remainder = decimal % 3\n            binary_str = str(remainder) + binary_str\n            decimal = decimal // 3\n    \n    return f\"db{binary_str}db\"", "index": 0, "passed_case": [0], "case_status": ["db0db", "db1012db", "db10211db", "db120db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/80_prompt2ac", "code_candidates": [{"code": "def is_happy(s: str) -> bool:\n    if len(s) < 3:\n        return False\n\n    substrings = []\n    i = 0\n    while i < len(s):\n        if s[i].isalpha():\n            j = i\n            while j < len(s) and s[j].isalpha():\n                j += 1\n            substring = s[i:j]\n            if substring in substrings:\n                return False\n            substrings.append(substring)\n            i = j\n        else:\n            i += 1\n\n    return True", "index": 0, "passed_case": [0, 1, 2, 4, 6], "case_status": ["False", "False", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/81_prompt2ac", "code_candidates": [{"code": "def numerical_letter_grade(grades):\n    \"\"\"Convert a list of GPAs to a list of corresponding letter grades based on the provided grading scale.\n    Handle exact GPA values and define a rule for GPAs outside the specified range.\n    Example:\n    numerical_letter_grade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B+', 'C', 'C+', 'A']\"\"\"\n    \n    # Define the grading scale\n    grading_scale = {\n        4.0: 'A+',\n        3.7: 'A',\n        3.3: 'B+',\n        3.0: 'B',\n        2.7: 'C+',\n        2.3: 'C',\n        2.0: 'D',\n        1.7: 'D-'\n    }\n    \n    # Define a rule for GPAs outside the specified range\n    default_grade = 'F'\n    \n    # Convert each GPA to a letter grade\n    letter_grades = []\n    for gpa in grades:\n        # Find the closest lower GPA in the grading scale\n        for key in sorted(grading_scale.keys(), reverse=True):\n            if gpa >= key:\n                letter_grades.append(grading_scale[key])\n                break\n        else:\n            # If no matching GPA is found, assign the default grade\n            letter_grades.append(default_grade)\n    \n    return letter_grades", "index": 0, "passed_case": [], "case_status": ["['A+', 'B', 'D-', 'D', 'B+']", "['F']", "['F']", "['F']", "['F', 'F', 'F', 'C+', 'B+']", "['F', 'F']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/82_prompt2ac", "code_candidates": [{"code": "def prime_length(string: str) -> bool:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    return is_prime(len(string))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/84_prompt2ac", "code_candidates": [{"code": "def solve(N: int, base: int) -> str:\n    if N < 0:\n        raise ValueError(\"N must be a positive integer\")\n    if base < 2:\n        raise ValueError(\"Base must be at least 2\")\n    \n    total_sum = 0\n    while N > 0:\n        total_sum += N % base\n        N = N // base\n    \n    return str(total_sum)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/85_prompt2ac", "code_candidates": [{"code": "def add(lst: list[int]) -> int:\n    # Define the specified indices to consider\n    specified_indices = [1, 3, 5]\n    \n    # Initialize the sum\n    total = 0\n    \n    # Iterate through the list and add even elements at specified indices\n    for index in specified_indices:\n        if index < len(lst) and lst[index] % 2 == 0:\n            total += lst[index]\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["88", "122", "0", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/86_prompt2ac", "code_candidates": [{"code": "def anti_shuffle(s: str) -> str:\n    \"\"\"\n    Takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    descending or ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        # Sort characters in ascending order based on ASCII value\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    # Join the ordered words back into a sentence with spaces preserved\n    return ' '.join(ordered_words)\n\n# Example usage:\n# print(anti_shuffle('Hi'))  # Output: 'iH'\n# print(anti_shuffle('hello'))  # Output: 'ehllo'\n# print(anti_shuffle('Hello World!!!'))  # Output: 'ehllo dlorW!!!'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello !!!Wdlor", "", ".Hi My aemn is Meirst .Rboot How aer ?ouy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/87_prompt2ac", "code_candidates": [{"code": "def get_row(lst, x):\n    coordinates = []\n    for row_idx, row in enumerate(lst):\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    return coordinates", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/88_prompt2ac", "code_candidates": [{"code": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting.\n    Sort the array in ascending order if the sum of the first and last index values is odd,\n    or sort it in descending order if the sum is even.\n\n    Note:\n    * Don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [5, 4, 3, 2, 1, 0]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [0, 1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if not array:\n        return []\n    \n    first_value = array[0] if array else 0\n    last_value = array[-1] if array else 0\n    sum_first_last = first_value + last_value\n    \n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/89_prompt2ac", "code_candidates": [{"code": "def encrypt(s: str) -> str:\n    encrypted_str = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted_char = chr((ord(char) - ord('a') + 13) % 26 + ord('a'))\n            encrypted_str += encrypted_char\n        elif 'A' <= char <= 'Z':\n            encrypted_char = chr((ord(char) - ord('A') + 13) % 26 + ord('A'))\n            encrypted_str += encrypted_char\n        else:\n            encrypted_str += char\n    return encrypted_str", "index": 0, "passed_case": [], "case_status": ["uv", "nfqstuwxy", "ts", "rg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/90_prompt2ac", "code_candidates": [{"code": "def next_smallest(lst):\n    if not lst:\n        return None\n    sorted_lst = sorted(lst)\n    if len(sorted_lst) < 3:\n        return sorted_lst[0]\n    return sorted_lst[2]", "index": 0, "passed_case": [2, 4], "case_status": ["3", "3", "None", "1", "1", "1", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/91_prompt2ac", "code_candidates": [{"code": "def is_bored(S: str) -> int:\n    \"\"\"\n    Count the number of boredoms in a string. A boredom is a sentence that starts\n    with a given word (such as \"W\", \"I\"). Sentences are delimited by '.', '?' or '!'.\n\n    Args:\n        S (str): The input string containing sentences.\n\n    Returns:\n        int: The number of boredoms in the string.\n    \"\"\"\n    if not S:\n        return 0\n\n    sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n\n    count = 0\n    for sentence in sentences:\n        sentence = sentence.strip()\n        if sentence and sentence[0] in {'W', 'I'}:\n            count += 1\n\n    return count", "index": 0, "passed_case": [0, 3, 5], "case_status": ["0", "3", "3", "0", "4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/92_prompt2ac", "code_candidates": [{"code": "def any_int(x: int, y: int, z: int) -> bool:\n    '''\n    Create a function that takes 3 integers.\n    Returns true if one of the numbers is larger than or equal to the sum of the other two.\n    Returns false in any other cases.\n    '''\n    sum_of_two = x + y + z - max(x, y, z)\n    return max(x, y, z) >= sum_of_two", "index": 0, "passed_case": [0, 1, 4, 5, 6, 7, 8], "case_status": ["True", "False", "True", "True", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/93_prompt2ac", "code_candidates": [{"code": "def encode(s: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result = []\n    \n    for char in s:\n        if char.isalpha():\n            # Swap the case\n            if char.islower():\n                new_char = char.upper()\n            else:\n                new_char = char.lower()\n            \n            # Replace vowel with the letter 5 places ahead\n            if new_char in vowels:\n                if new_char.islower():\n                    new_char = chr(((ord(new_char) - ord('a') + 5) % 26) + ord('a'))\n                else:\n                    new_char = chr(((ord(new_char) - ord('A') + 5) % 26) + ord('A'))\n            \n            result.append(new_char)\n        else:\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [], "case_status": ["tjst", "mZDFSNR", "yjs", "tHNS NS F MJSSFGJ", "n dTnT kNtW wHfT Tt wRnTj"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/94_prompt2ac", "code_candidates": [{"code": "from typing import List\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef skjkasdkd(lst: List[int]) -> int:\n    primes = [x for x in lst if is_prime(x)]\n    if not primes:\n        return None\n    return min(primes) if min(primes) < max(primes) else max(primes)", "index": 0, "passed_case": [4], "case_status": ["2", "2", "3", "5", "3", "2", "8191", "7", "97"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/95_prompt2ac", "code_candidates": [{"code": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if some or all keys are strings in lower \n    case or some or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    \"\"\"\n    if not dict:\n        return False\n    \n    has_lower = False\n    has_upper = False\n    \n    for key in dict:\n        if isinstance(key, str):\n            if key.islower():\n                has_lower = True\n            elif key.isupper():\n                has_upper = True\n            if has_lower and has_upper:\n                return True\n    \n    return has_lower or has_upper", "index": 0, "passed_case": [0, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/96_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n: int) -> List[int]:\n    if n < 2:\n        return []\n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    return primes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/97_prompt2ac", "code_candidates": [{"code": "def multiply(a: int, b: int) -> int:\n    # Extract the unit digits\n    unit_digit_a = a % 10\n    unit_digit_b = b % 10\n    \n    # Return the product of the unit digits\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/98_prompt2ac", "code_candidates": [{"code": "def count_upper(s: str) -> int:\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    for i, char in enumerate(s):\n        if i % 2 == 0 and char in uppercase_vowels:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/99_prompt2ac", "code_candidates": [{"code": "def closest_integer(value: str) -> int:\n    number = float(value)\n    if number >= 0:\n        if number % 1 >= 0.5:\n            return int(number) + 1\n        else:\n            return int(number)\n    else:\n        if number % 1 <= -0.5:\n            return int(number) - 1\n        else:\n            return int(number)", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["10", "15", "-15", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/100_prompt2ac", "code_candidates": [{"code": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    >>> make_a_pile(4)\n    [4, 6, 8, 10]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    pile = []\n    current_stones = n\n    \n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    \n    return pile", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/101_prompt2ac", "code_candidates": [{"code": "def words_string(s: str) -> list:\n    if not s:\n        return []\n    return [word for word in s.split() if word]", "index": 0, "passed_case": [4], "case_status": ["['Hi,', 'my', 'name', 'is', 'John']", "['One,', 'two,', 'three,', 'four,', 'five,', 'six']", "['Hi,', 'my', 'name']", "['One,,', 'two,', 'three,', 'four,', 'five,', 'six,']", "[]", "['ahmed', ',', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/102_prompt2ac", "code_candidates": [{"code": "def choose_num(x, y):\n    # Ensure x is the smaller number and y is the larger number\n    start = min(x, y)\n    end = max(x, y)\n    \n    # Iterate from end to start to find the largest even number\n    for num in range(end, start - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    # If no even number is found, return -1\n    return -1", "index": 0, "passed_case": [0, 2, 4, 6, 7], "case_status": ["14", "12", "12354", "5234", "28", "26", "-1", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/103_prompt2ac", "code_candidates": [{"code": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    elif n == m:\n        return bin(n)\n    else:\n        average = sum(range(n, m + 1)) / (m - n + 1)\n        rounded = round(average)\n        return bin(rounded)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["0b11", "0b1010", "0b1111001010", "0b1111100100", "0b1011000010", "0b101101110", "0b110101101", "0b1001110010", "0b11010111", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/104_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef filter_digits(x: List[int]) -> List[int]:\n    def contains_odd_or_even(num: int) -> bool:\n        digits = set(str(num))\n        has_odd = any(digit in {'1', '3', '5', '7', '9'} for digit in digits)\n        has_even = any(digit in {'0', '2', '4', '6', '8'} for digit in digits)\n        return has_odd or has_even\n    \n    filtered_list = [num for num in x if not contains_odd_or_even(num)]\n    return sorted(filtered_list)", "index": 0, "passed_case": [1], "case_status": ["[]", "[]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/105_prompt2ac", "code_candidates": [{"code": "def by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers ascendingly that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    \"\"\"\n    # Filter numbers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered numbers in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/106_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef f(n: int) -> List[int]:\n    def factorial(x: int) -> int:\n        result = 1\n        for i in range(1, x + 1):\n            result *= i\n        return result\n\n    def sum_of_numbers(x: int) -> int:\n        return x * (x + 1) // 2\n\n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_of_numbers(i))\n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 2, 6, 24, 15]", "[1, 2, 6, 24, 15, 720, 28]", "[1]", "[1, 2, 6]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/107_prompt2ac", "code_candidates": [{"code": "def count_even_odd_palindromes(n: int) -> tuple:\n    if n < 1:\n        return (0, 0)\n    \n    even_count = 0\n    odd_count = 0\n    \n    for num in range(1, n + 1):\n        s = str(num)\n        if s == s[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/108_prompt2ac", "code_candidates": [{"code": "def count_nums(arr: list[int]) -> int:\n    def digit_sum(num: int) -> int:\n        return sum(int(digit) for digit in str(abs(num)))\n    \n    count = 0\n    for num in arr:\n        if num != 0 and digit_sum(num) > 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 5, 6, 7], "case_status": ["0", "2", "7", "6", "6", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/109_prompt2ac", "code_candidates": [{"code": "def move_one_ball(arr):\n    \"\"\"Determine if it is possible to get an array sorted in non-increasing or non-decreasing order by performing right shift operations.\n    If the given array is already sorted or can be sorted by any number of right shifts, return True. Otherwise, return False.\"\"\"\n    \n    if not arr:\n        return True\n    \n    # Check for non-decreasing order\n    sorted_arr = sorted(arr)\n    for i in range(len(arr)):\n        if arr[-i:] + arr[:-i] == sorted_arr:\n            return True\n    \n    # Check for non-increasing order\n    reverse_sorted_arr = sorted(arr, reverse=True)\n    for i in range(len(arr)):\n        if arr[-i:] + arr[:-i] == reverse_sorted_arr:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/110_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef can_make_all_even(lst1: List[int], lst2: List[int]) -> str:\n    # Check if lst1 is already all even\n    if all(x % 2 == 0 for x in lst1):\n        return 'YES'\n    \n    # Check if lst1 is already all odd\n    if all(x % 2 != 0 for x in lst1):\n        return 'NO'\n    \n    # Find the indices of odd numbers in lst1\n    odd_indices = [i for i, x in enumerate(lst1) if x % 2 != 0]\n    \n    # Check if there are corresponding even numbers in lst2 at the same indices\n    for idx in odd_indices:\n        if lst2[idx] % 2 != 0:\n            return 'NO'\n    \n    return 'YES'", "index": 0, "passed_case": [1, 2, 4, 5, 6], "case_status": ["NO", "NO", "YES", "NO", "NO", "NO", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/111_prompt2ac", "code_candidates": [{"code": "def histogram(test: str) -> dict:\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the least or most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1}\n    histogram('a b b a') == {'a': 2}\n    histogram('a b c a b') == {'a': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    if not test:\n        return {}\n    \n    # Split the string into individual letters\n    letters = test.split()\n    \n    # Count the frequency of each letter\n    frequency = {}\n    for letter in letters:\n        if letter in frequency:\n            frequency[letter] += 1\n        else:\n            frequency[letter] = 1\n    \n    if not frequency:\n        return {}\n    \n    # Find the maximum and minimum counts\n    max_count = max(frequency.values())\n    min_count = min(frequency.values())\n    \n    # Determine if we should return the most or least frequent letters\n    # For this problem, we'll assume we always return the most frequent letters\n    # If needed, we can modify the logic to handle both cases\n    result = {letter: count for letter, count in frequency.items() if count == max_count}\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/112_prompt2ac", "code_candidates": [{"code": "def reverse_delete(s: str, c: str) -> tuple:\n    \"\"\"\n    Deletes all characters in s that are present in c and checks if the result string is a palindrome.\n    \n    Parameters:\n    s (str): The original string.\n    c (str): The string containing characters to be deleted from s.\n    \n    Returns:\n    tuple: A tuple containing the result string and a boolean indicating if it is a palindrome.\n    \"\"\"\n    # Create a set of characters to be deleted for O(1) lookup\n    chars_to_delete = set(c)\n    \n    # Filter out characters in s that are in chars_to_delete\n    result_string = ''.join([char for char in s if char not in chars_to_delete])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return (result_string, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/113_prompt2ac", "code_candidates": [{"code": "def odd_count(lst: List[str]) -> List[str]:\n    result = []\n    for index, s in enumerate(lst):\n        odd_digits_count = sum(1 for char in s if int(char) % 2 != 0)\n        result.append(f'the number of odd elements {odd_digits_count} in the string {index + 1} of the {len(lst)} input.')\n    return result", "index": 0, "passed_case": [], "case_status": ["['the number of odd elements 4 in the string 1 of the 1 input.']", "['the number of odd elements 1 in the string 1 of the 2 input.', 'the number of odd elements 8 in the string 2 of the 2 input.']", "['the number of odd elements 2 in the string 1 of the 3 input.', 'the number of odd elements 3 in the string 2 of the 3 input.', 'the number of odd elements 2 in the string 3 of the 3 input.']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/114_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef minSubArraySum(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    \n    min_sum = current_sum = nums[0]\n    \n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/115_prompt2ac", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    Calculate the number of times buckets need to be lowered to empty the wells.\n\n    Args:\n    grid (List[List[int]]): A rectangular grid of wells where each row represents a well.\n    capacity (int): The capacity of each bucket.\n\n    Returns:\n    int: The number of times buckets need to be lowered.\n    \"\"\"\n    if not grid:\n        return 0\n\n    total_buckets = 0\n    for row in grid:\n        water_units = sum(row)\n        if water_units > 0:\n            total_buckets += math.ceil(water_units / capacity)\n\n    return total_buckets", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["6", "5", "0", "4", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/116_prompt2ac", "code_candidates": [{"code": "def sort_array(arr):\n    \"\"\"\n    Sort an array of non-negative integers based on the number of ones in their binary representation in descending order. For integers with the same number of ones, sort based on their decimal value.\n\n    Examples:\n    >>> sort_array([1, 5, 2, 3, 4]) == [5, 3, 4, 2, 1]\n    >>> sort_array([1, 0, 2, 3, 4]) == [3, 4, 2, 1, 0]\n    >>> sort_array([7, 8, 15, 16]) == [15, 7, 8, 16]\n    \"\"\"\n    # Define a key function that returns a tuple (number of ones, value)\n    def key_func(num):\n        return (-bin(num).count('1'), num)\n    \n    # Sort the array using the key function\n    return sorted(arr, key=key_func)", "index": 0, "passed_case": [3, 6, 7], "case_status": ["[3, 5, 1, 2, 4]", "[-6, -5, -3, -4, -2]", "[3, 1, 2, 4, 0]", "[]", "[77, 7, 3, 3, 5, 5, 5, 2, 2, 4, 4]", "[44, 3, 5, 6, 12, 32]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/117_prompt2ac", "code_candidates": [{"code": "def select_words(s, n):\n    consonants = set('bcdfghjklmnpqrstvwxyz')\n    result = []\n    \n    if not s:\n        return result\n    \n    words = s.split()\n    for word in words:\n        consonant_count = sum(1 for char in word.lower() if char in consonants)\n        if consonant_count >= n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [0, 3, 4, 5, 6], "case_status": ["['little']", "['Mary', 'little', 'lamb']", "['simple', 'white', 'space']", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/118_prompt2ac", "code_candidates": [{"code": "def get_closest_vowel(word: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    word_length = len(word)\n    \n    # Iterate from the second character to the second last character\n    for i in range(1, word_length - 1):\n        if word[i] in vowels:\n            # Check if the character before and after are consonants\n            if word[i - 1] not in vowels and word[i + 1] not in vowels:\n                return word[i]\n    \n    return \"\"", "index": 0, "passed_case": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["o", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/119_prompt2ac", "code_candidates": [{"code": "def can_form_balanced_parentheses(strings: list) -> str:\n    if len(strings) != 2:\n        raise ValueError(\"Input list must contain exactly two strings.\")\n    \n    str1, str2 = strings\n    \n    for char in str1 + str2:\n        if char not in ['(', ')']:\n            raise ValueError(\"Strings must contain only '(' or ')' characters.\")\n    \n    total_open = str1.count('(') + str2.count('(')\n    total_close = str1.count(')') + str2.count(')')\n    \n    if total_open != total_close:\n        return 'No'\n    \n    return 'Yes'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "Yes", "No", "No", "Yes", "Yes", "Yes"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/120_prompt2ac", "code_candidates": [{"code": "def maximum(arr, k):\n    # Handle edge cases\n    if not arr:\n        return []\n    if k >= len(arr):\n        return sorted(arr, reverse=True)\n    if k == 1:\n        return [max(arr)]\n    \n    # Find the k largest elements and sort them in descending order\n    return sorted(arr, reverse=True)[:k]", "index": 0, "passed_case": [1, 2, 7, 10], "case_status": ["[5, -3, -4]", "[4, 4]", "[2]", "[123, 20, 2]", "[20, 2, 1, 0]", "[15, 5, 3, 0, 0, -8, -13]", "[5, 3]", "[5]", "[4, -4]", "[10, -10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/121_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef sum_even_odd_elements(nums: List[int]) -> int:\n    total_sum = 0\n    for index, num in enumerate(nums):\n        if (num % 2 == 0 and index % 2 == 0) or (num % 2 != 0 and index % 2 != 0):\n            total_sum += num\n    return total_sum", "index": 0, "passed_case": [], "case_status": ["6", "388", "9", "10", "43", "24"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/122_prompt2ac", "code_candidates": [{"code": "def add_elements(arr, k):\n    # Ensure arr is non-empty\n    if not arr:\n        return 0\n    \n    # Determine the range of elements to consider\n    start_index = max(0, len(arr) - k)\n    relevant_elements = arr[start_index:]\n    \n    # Sum the elements with at most two digits\n    total_sum = 0\n    for num in relevant_elements:\n        if abs(num) < 100:\n            total_sum += num\n    \n    return total_sum", "index": 0, "passed_case": [4], "case_status": ["274", "11", "30", "30", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/123_prompt2ac", "code_candidates": [{"code": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note:\n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz(5) returns [5, 1] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are [5, 1].\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    odd_numbers = []\n    while n != 1:\n        if n % 2 == 1:\n            odd_numbers.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    odd_numbers.append(1)\n    return sorted(odd_numbers)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/124_prompt2ac", "code_candidates": [{"code": "import re\nfrom datetime import datetime\n\ndef valid_date(date: str) -> bool:\n    \"\"\"Validates a given date string and returns True if the date is valid otherwise False.\n    The date is valid if:\n    1. The date string is not empty.\n    2. The number of days is within the valid range for the given month.\n    3. The months are between 1 and 12.\n    4. The date is in the format: dd-mm-yyyy or mm-dd-yyyy.\n    \"\"\"\n    if not date:\n        return False\n\n    # Regular expression to match both date formats\n    date_pattern = re.compile(r'^(\\d{2})-(\\d{2})-(\\d{4})$')\n    match = date_pattern.match(date)\n\n    if not match:\n        return False\n\n    day, month, year = map(int, match.groups())\n\n    if month < 1 or month > 12:\n        return False\n\n    try:\n        # Try to parse the date to validate the day\n        datetime(year, month, day)\n        return True\n    except ValueError:\n        return False", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "False", "True", "True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/125_prompt2ac", "code_candidates": [{"code": "def split_words(txt: str) -> list[str] | int:\n    '''\n    Given a string of words, return a list of words split on characters, if no characters exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 10, ord('b') = 11, ... ord('z') = 125\n    Examples\n    split_words(\"Hello world!\") \u279e [\"Hello\"]\n    split_words(\"Hello,world!\") \u279e [\"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n    # Check for characters\n    if any(not c.isalnum() and c != ' ' for c in txt):\n        words = [word for word in txt.split() if any(not c.isalnum() for c in word)]\n        return words if words else []\n    \n    # Check for commas\n    if ',' in txt:\n        words = txt.split(',')\n        return [word for word in words if word]\n    \n    # Count lower-case letters with odd order in the alphabet\n    count = 0\n    for c in txt:\n        if c.islower():\n            # Calculate the order in the custom alphabet\n            order = ord(c) - ord('a') + 10\n            if order % 2 != 0:\n                count += 1\n    \n    return count", "index": 0, "passed_case": [3, 4, 5, 6, 7], "case_status": ["['world!']", "['Hello,world!']", "['world,!']", "['Hello,Hello,world', '!']", "3", "2", "1", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/126_prompt2ac", "code_candidates": [{"code": "def is_sorted(lst):\n    '''\n    Given a list of non-negative integers, return True if the list is sorted in non-decreasing order and contains no duplicates. Otherwise, return False.\n    '''\n    if not lst:\n        return True  # An empty list is considered sorted\n    \n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1] or lst[i] == lst[i + 1]:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/127_prompt2ac", "code_candidates": [{"code": "from typing import Tuple\nimport math\n\ndef is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef intersection(interval1: Tuple[int, int], interval2: Tuple[int, int]) -> str:\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection start and end\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # Check if there is an intersection\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = intersection_end - intersection_start + 1\n    \n    # Check if the length is prime\n    if is_prime(intersection_length):\n        return \"YES\"\n    else:\n        return \"NO\"", "index": 0, "passed_case": [0, 2, 3, 4, 5, 7], "case_status": ["NO", "YES", "YES", "YES", "NO", "NO", "YES", "NO"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/128_prompt2ac", "code_candidates": [{"code": "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    total = 0\n    for num in arr:\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        else:\n            sign = 0\n        total += abs(num) * sign\n    \n    return total", "index": 0, "passed_case": [3], "case_status": ["1", "1", "8", "None", "16", "0", "2", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/129_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef path(grid: List[List[int]], k: int) -> List[int]:\n    N = len(grid)\n    if N < 2:\n        raise ValueError(\"Grid must have at least 2 rows and 2 columns.\")\n    if k < 1:\n        raise ValueError(\"k must be a positive integer.\")\n\n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize the smallest path with a large value\n    smallest_path = None\n\n    def dfs(x, y, path_so_far, steps_left):\n        nonlocal smallest_path\n        if steps_left == 0:\n            if smallest_path is None or path_so_far < smallest_path:\n                smallest_path = path_so_far.copy()\n            return\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                path_so_far.append(grid[nx][ny])\n                dfs(nx, ny, path_so_far, steps_left - 1)\n                path_so_far.pop()\n\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]], k - 1)\n\n    return smallest_path\n\n# Example usage:\nif __name__ == \"__main__\":\n    grid1 = [ [1,2,3], [4,5,6], [7,8,9]]\n    k1 = 3\n    print(path(grid1, k1))  # Output: [9, 8, 7]\n\n    grid2 = [ [5,9,3], [4,1,6], [7,8,2]]\n    k2 = 1\n    print(path(grid2, k2))  # Output: [9]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[1, 2, 1]", "[1]", "[1, 2, 1, 2]", "[1, 10, 1, 10, 1, 10, 1]", "[1, 7, 1, 7, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]", "[1, 3, 1, 3, 1, 3, 1, 3]", "[1, 5, 1, 5, 1, 5, 1, 5]", "[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/130_prompt2ac", "code_candidates": [{"code": "def tri(n):\n    if n == 0:\n        return [1]\n    \n    # Initialize the first three numbers of the Tribonacci sequence\n    tribonacci_sequence = [1, 1, 2]\n    \n    # If n is less than 3, return the slice of the sequence up to n + 1\n    if n < 3:\n        return tribonacci_sequence[:n + 1]\n    \n    # Generate the Tribonacci sequence up to the nth number\n    for i in range(3, n + 1):\n        next_number = tribonacci_sequence[-1] + tribonacci_sequence[-2] + tribonacci_sequence[-3]\n        tribonacci_sequence.append(next_number)\n    \n    return tribonacci_sequence", "index": 0, "passed_case": [8], "case_status": ["[1, 1, 2, 4]", "[1, 1, 2, 4, 7]", "[1, 1, 2, 4, 7, 13]", "[1, 1, 2, 4, 7, 13, 24]", "[1, 1, 2, 4, 7, 13, 24, 44]", "[1, 1, 2, 4, 7, 13, 24, 44, 81]", "[1, 1, 2, 4, 7, 13, 24, 44, 81, 149]", "[1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415]", "[1]", "[1, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/131_prompt2ac", "code_candidates": [{"code": "def digits(n):\n    # Convert the number to a string to iterate over each digit\n    digits_str = str(n)\n    # Initialize the sum of odd digits\n    odd_sum = 0\n    \n    # Iterate over each digit\n    for digit_char in digits_str:\n        digit = int(digit_char)\n        # Check if the digit is odd\n        if digit % 2 != 0:\n            odd_sum += digit\n    \n    return odd_sum", "index": 0, "passed_case": [0, 1, 5], "case_status": ["5", "5", "6", "21", "25", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/132_prompt2ac", "code_candidates": [{"code": "def has_nested_brackets(s: str) -> bool:\n    stack = []\n    nested = False\n\n    for char in s:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            if stack[-1] == '[':\n                stack.pop()\n                if len(stack) > 0:\n                    nested = True\n            else:\n                return False\n\n    return nested and not stack", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13], "case_status": ["True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/133_prompt2ac", "code_candidates": [{"code": "import math\n\ndef sum_squares(lst):\n    total = 0\n    for num in lst:\n        # Round to the upper integer (ceiling)\n        rounded_num = math.ceil(num)\n        # Treat negative numbers as their absolute value\n        if rounded_num < 0:\n            rounded_num = abs(rounded_num)\n        # Square the number and add to the total\n        total += rounded_num ** 2\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/134_prompt2ac", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(s: str) -> bool:\n    if not s:\n        return False\n    \n    last_char = s[-1]\n    \n    if last_char.isalpha():\n        # Check if the last character is part of a word\n        if s.endswith(' '):\n            return False\n        # Split the string by spaces and check the last part\n        words = s.split()\n        if words:\n            last_word = words[-1]\n            return last_char != last_word[-1]\n        return False\n    elif last_char == ' ':\n        # Check the character before the space\n        if len(s) > 1:\n            prev_char = s[-2]\n            if prev_char.isalpha():\n                # Split the string by spaces and check the last part\n                words = s.split()\n                if words:\n                    last_word = words[-1]\n                    return prev_char != last_word[-1]\n        return False\n    else:\n        return False", "index": 0, "passed_case": [0, 2, 4, 5, 6, 7, 8, 9], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/135_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef find_smallest_index(arr: List[int]) -> int:\n    if not arr:\n        return -1\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i - 1]:\n            return i\n    \n    return -1", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["3", "-1", "2", "2", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/136_prompt2ac", "code_candidates": [{"code": "def largest_smallest_integers(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is the largest negative integer, and 'b' is the smallest positive integer in a list.\n    If there is no negative or positive integer, return them as None.\n\n    Examples:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    largest_smallest_integers([-3, -1, 2, 4]) == (-1, 2)\n    '''\n    largest_negative = None\n    smallest_positive = None\n\n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n\n    return (largest_negative, smallest_positive)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/137_prompt2ac", "code_candidates": [{"code": "def compare_one(a, b):\n    def normalize(value):\n        if isinstance(value, str):\n            return float(value.replace(',', '.'))\n        return float(value)\n\n    if isinstance(a, (int, float, str)) and isinstance(b, (int, float, str)):\n        a_normalized = normalize(a)\n        b_normalized = normalize(b)\n\n        if a_normalized < b_normalized:\n            return a\n        elif a_normalized > b_normalized:\n            return b\n        else:\n            return None\n    else:\n        raise ValueError(\"Both inputs must be integers, floats, or strings representing real numbers.\")", "index": 0, "passed_case": [7], "case_status": ["1", "1", "2", "5", "1", "5,1", "1", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/138_prompt2ac", "code_candidates": [{"code": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of 4 even numbers.\"\"\"\n    # Any even number can be written as the sum of 4 even numbers\n    # because 2 + 2 + 2 + 2 = 8, and any multiple of 4 can be expressed as such.\n    # If n is even, it can be written as the sum of 4 even numbers.\n    # If n is odd, it cannot be written as the sum of 4 even numbers.\n    return n % 2 == 0\n\n# Examples\n# is_equal_to_sum_even(4) == True\n# is_equal_to_sum_even(6) == True\n# is_equal_to_sum_even(8) == False", "index": 0, "passed_case": [2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "True", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/139_prompt2ac", "code_candidates": [{"code": "from math import factorial\n\ndef special_factorial(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/140_prompt2ac", "code_candidates": [{"code": "def fix_spaces(text: str) -> str:\n    if not text:\n        return text\n    \n    # Replace leading spaces with a single underscore\n    if text.startswith(' '):\n        text = '_' + text.lstrip()\n    \n    # Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a single hyphen\n    while '__' in text:\n        text = text.replace('__', '_')\n    \n    text = text.replace('_', '-')\n    \n    return text", "index": 0, "passed_case": [0, 3], "case_status": ["Example", "Mudasir-Hanif-", "Yellow-Yellow-Dirty-Fellow", "Exa-mple", "-Exa-1-2-2-mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/141_prompt2ac", "code_candidates": [{"code": "import re\n\ndef file_name_check(file_name: str) -> str:\n    \"\"\"\n    Check if a file name is valid based on the specified conditions.\n\n    Args:\n        file_name (str): The file name to be checked.\n\n    Returns:\n        str: 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    # Check if the file name starts with a letter\n    if not re.match(r'^[a-zA-Z]', file_name):\n        return 'No'\n\n    # Check for exactly three digits\n    if len(re.findall(r'\\d', file_name)) != 3:\n        return 'No'\n\n    # Check for exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n\n    # Split the file name into before and after the dot\n    before_dot, after_dot = file_name.split('.')\n\n    # Check if the substring before the dot is not empty\n    if not before_dot:\n        return 'No'\n\n    # Check if the substring after the dot is one of the allowed extensions\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n\n    return 'Yes'", "index": 0, "passed_case": [1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24, 25], "case_status": ["No", "No", "No", "No", "Yes", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "Yes", "No", "No", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/142_prompt2ac", "code_candidates": [{"code": "def sum_squares(lst):\n    \"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [] the output should be 0\n    For lst = [-1,-5,2,-1,-5] the output should be 4\n    \"\"\"\n    for i, num in enumerate(lst):\n        if i % 3 == 0:\n            lst[i] = num ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = num ** 3\n    \n    return sum(lst)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["6", "14", "0", "9", "-3", "0", "-126", "3030", "0", "-14196", "-1448"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/143_prompt2ac", "code_candidates": [{"code": "def words_in_sentence(sentence: str) -> str:\n    # List of specified lengths to match\n    specified_lengths = [3, 5, 7]\n    \n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Filter words based on specified lengths\n    filtered_words = [word for word in words if len(word) in specified_lengths]\n    \n    # Return the filtered words joined into a string\n    return ' '.join(filtered_words) if filtered_words else ''", "index": 0, "passed_case": [5], "case_status": ["", "for", "there place", "Hussein", "for", "", ""]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/144_prompt2ac", "code_candidates": [{"code": "from fractions import Fraction\n\ndef simplify(a: str, b: str) -> bool:\n    try:\n        # Parse the fractions\n        fraction_a = Fraction(a)\n        fraction_b = Fraction(b)\n        \n        # Calculate the product\n        product = fraction_a * fraction_b\n        \n        # Check if the product is a whole number\n        return product.denominator == 1\n    except (ValueError, ZeroDivisionError):\n        # Handle invalid input or division by zero\n        return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/145_prompt2ac", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Sorts the given list of integers in ascending order according to the sum of their digits.\n    If there are several items with similar sum of their digits, order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [1, 11, -1, -12, -11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/146_prompt2ac", "code_candidates": [{"code": "def specialFilter(nums):\n    def is_valid_digit(digit):\n        return digit % 2 == 0 or digit % 2 == 1\n\n    count = 0\n    for num in nums:\n        abs_num = abs(num)\n        str_num = str(abs_num)\n        \n        if len(str_num) == 1:\n            first_digit = last_digit = int(str_num[0])\n        else:\n            first_digit = int(str_num[0])\n            last_digit = int(str_num[-1])\n        \n        if (first_digit % 2 == 0 and last_digit % 2 == 0) or (first_digit % 2 == 1 and last_digit % 2 == 1):\n            if num < 10 or num > 10 or num == 10:\n                count += 1\n    \n    return count", "index": 0, "passed_case": [3, 6], "case_status": ["4", "3", "4", "4", "5", "1", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/147_prompt2ac", "code_candidates": [{"code": "def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n    For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i + i - 1 or a[i] = i * i - i + 1.\n    Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 0\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        There is no valid triple.\n    \"\"\"\n    if n < 3:\n        return 0\n\n    # Create the array a\n    a = []\n    for i in range(1, n + 1):\n        a.append(i * i + i - 1)\n\n    # Count the number of triples\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n\n    return count", "index": 0, "passed_case": [0, 1], "case_status": ["1", "4", "24", "51744"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/148_prompt2ac", "code_candidates": [{"code": "def bf(planet1, planet2):\n    '''\n    There are eight planets in our solar system: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune.\n    Write a function that takes two planet names as strings planet1 and planet2.\n    The function should return a tuple containing only one or all planets whose orbits are located between the orbit of planet1 and the orbit of planet2, sorted by the proximity to the sun.\n    The function should return an empty tuple if planet1 or planet2 are not correct planet names.\n    Examples\n    bf('Jupiter', 'Neptune') ==> ('Saturn', 'Uranus')\n    bf('Earth', 'Mercury') ==> ('Venus',)\n    bf('Mercury', 'Uranus') ==> ('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')\n    '''\n    \n    planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    \n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    if index1 > index2:\n        index1, index2 = index2, index1\n    \n    between_planets = planets[index1 + 1:index2]\n    \n    return tuple(between_planets)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["('Saturn', 'Uranus')", "('Venus',)", "('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')", "('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')", "()", "()", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/149_prompt2ac", "code_candidates": [{"code": "def sorted_list_sum(lst):\n    \"\"\"\n    Accepts a list of strings, deletes the strings that have odd lengths,\n    and returns the resulted list sorted in descending order by length of each word,\n    and if two words have the same length, sort the list alphabetically ascending.\n    \"\"\"\n    # Filter out strings with odd lengths\n    filtered_lst = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the list first by descending length, then alphabetically ascending\n    sorted_lst = sorted(filtered_lst, key=lambda x: (-len(x), x))\n    \n    return sorted_lst", "index": 0, "passed_case": [0, 2, 3, 4, 5], "case_status": ["['aa']", "['school', 'asdf', 'AI']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['aaaa', 'bbbb', 'cc', 'dd']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/150_prompt2ac", "code_candidates": [{"code": "def x_or_y(a, b, c):\n    if c:\n        return a\n    else:\n        return b", "index": 0, "passed_case": [9], "case_status": ["7", "15", "3", "1259", "7919", "3609", "91", "6", "2", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/151_prompt2ac", "code_candidates": [{"code": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    total = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            total += num ** 2\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "25", "0", "0", "0", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/152_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef compare(game: List[int], guess: List[int]) -> List[int]:\n    # Check for empty lists\n    if not game or not guess:\n        return []\n    \n    # Check for negative values\n    if any(val < 0 for val in game) or any(val < 0 for val in guess):\n        return [None] * len(game)\n    \n    result = []\n    for score, guess_val in zip(game, guess):\n        if guess_val == score:\n            result.append(1)\n        elif abs(guess_val - score) == 1:\n            result.append(2)\n        else:\n            result.append(abs(guess_val - score))\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[None, None, None, None, None, None]", "[1, 1, 1, 1, 1, 1]", "[None, None, None]", "[None, None, None, None]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/153_prompt2ac", "code_candidates": [{"code": "def Extension(class_name: str, extensions: List[Dict[str, int]]) -> str:\n    if not extensions:\n        return f\"{class_name}.None\"\n    \n    max_strength = None\n    strongest_extension = None\n    \n    for ext in extensions:\n        if 'CAP' not in ext or 'SM' not in ext:\n            continue\n        strength = ext['CAP'] - ext['SM']\n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = ext\n    \n    if strongest_extension:\n        return f\"{class_name}.{strongest_extension['name']}\"\n    else:\n        return f\"{class_name}.None\"", "index": 0, "passed_case": [], "case_status": ["Watashi.None", "Boku123.None", "__YESIMHERE.None", "K.None", "__HAHA.None", "YameRore.None", "finNNalLLly.None", "_.None", "Sp.None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/154_prompt2ac", "code_candidates": [{"code": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    Returns True if the second word or any of its rotations is a substring of the first word.\n    \"\"\"\n    if not b:\n        return True\n    if not a:\n        return False\n    \n    # Create all rotations of b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation of b is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/156_prompt2ac", "code_candidates": [{"code": "def int_to_mini_roman(number: int) -> str:\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000 inclusive.\")\n    \n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    \n    roman_num = \"\"\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syms[i]\n            number -= val[i]\n        i += 1\n    return roman_num", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/157_prompt2ac", "code_candidates": [{"code": "def right_angle_triangle(a, b, c):\n    # Create a list of the sides and sort them\n    sides = [a, b, c]\n    sides.sort()\n    \n    # Assign the shortest, middle, and longest sides\n    shortest, middle, longest = sides\n    \n    # Check if the triangle inequality theorem holds\n    if shortest + middle <= longest:\n        return False\n    \n    # Apply the Pythagorean theorem\n    return shortest**2 + middle**2 == longest**2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/158_prompt2ac", "code_candidates": [{"code": "def find_max(words):\n    \"\"\"\n    Finds the word with the maximum number of unique characters from a list of strings.\n    If multiple words have the same number of unique characters, returns the one that comes first in lexicographical order.\n\n    :param words: List of strings\n    :return: String with the maximum number of unique characters, or the lexicographically smallest one if there's a tie\n    \"\"\"\n    if not words:\n        return None\n\n    def unique_chars_count(word):\n        return len(set(word))\n\n    max_unique = -1\n    result = None\n\n    for word in words:\n        if not isinstance(word, str):\n            continue  # Skip non-string elements\n        current_unique = unique_chars_count(word)\n        if current_unique > max_unique or (current_unique == max_unique and (result is None or word < result)):\n            max_unique = current_unique\n            result = word\n\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "enam", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/159_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef calculate_carrot_status(carrots_needed: int, carrots_eaten: int) -> List[int]:\n    total_carrots_needed = carrots_needed * 3  # Assuming 3 meals a day\n    carrots_left = total_carrots_needed - carrots_eaten\n    if carrots_left < 0:\n        carrots_left = abs(carrots_left)  # Reflect excess carrots\n    else:\n        carrots_left = 0  # No excess, just reflect what's left\n    return [total_carrots_needed, carrots_left]", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/160_prompt2ac", "code_candidates": [{"code": "def do_algebra(list1, list2):\n    \"\"\"\n    Given two lists, use the two given lists to build the algebraic \n    expression and return a certain form of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 2 * 4 - 5\n    => result = 5\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n    # Ensure the length of operator list is equal to the length of operand list minus one\n    if len(list1) != len(list2) - 1:\n        raise ValueError(\"The length of operator list must be equal to the length of operand list minus one.\")\n    \n    # Initialize the result with the first operand\n    result = list2[0]\n    \n    # Iterate through the operators and operands to build the expression\n    for i in range(len(list1)):\n        operator = list1[i]\n        operand = list2[i + 1]\n        \n        if operator == '+':\n            result += operand\n        elif operator == '-':\n            result -= operand\n        elif operator == '*':\n            result *= operand\n        elif operator == '//':\n            if operand == 0:\n                raise ValueError(\"Cannot divide by zero.\")\n            result //= operand\n        elif operator == '**':\n            result **= operand\n        else:\n            raise ValueError(f\"Unsupported operator: {operator}\")\n    \n    return result", "index": 0, "passed_case": [0, 2], "case_status": ["37", "15", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/161_prompt2ac", "code_candidates": [{"code": "def solve(s: str) -> str:\n    \"\"\"\n    You are given a string s.\n    If s[i] is a letter, reverse its case from lower to upper or vice versa, otherwise keep it as it is.\n    If the string contains no letters, return the string 'transformed_string'.\n    The function should return the resulted string.\n    \"\"\"\n    transformed = []\n    has_letter = False\n\n    for char in s:\n        if char.isalpha():\n            has_letter = True\n            if char.islower():\n                transformed.append(char.upper())\n            else:\n                transformed.append(char.lower())\n        else:\n            transformed.append(char)\n\n    if not has_letter:\n        return 'transformed_string'\n\n    return ''.join(transformed)", "index": 0, "passed_case": [0, 2, 3, 4, 6, 7], "case_status": ["aSdF", "transformed_string", "AB", "#A@c", "#aSDFw^45", "transformed_string", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/162_prompt2ac", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its ideal hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '12345'\n    \"\"\"\n    if not text:\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/163_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef filter_digits(a: int, b: int, digit_type: str, order: str) -> List[int]:\n    # Validate input parameters\n    if not (isinstance(a, int) and isinstance(b, int) and a > 0 and b > 0):\n        raise ValueError(\"Both a and b must be positive integers.\")\n    if digit_type not in ['odd', 'even']:\n        raise ValueError(\"digit_type must be either 'odd' or 'even'.\")\n    if order not in ['ascending', 'descending']:\n        raise ValueError(\"order must be either 'ascending' or 'descending'.\")\n    \n    # Determine the filter function based on digit_type\n    if digit_type == 'odd':\n        filter_func = lambda x: x % 2 != 0\n    else:\n        filter_func = lambda x: x % 2 == 0\n    \n    # Collect digits of the specified type\n    digits = [d for d in range(a, b + 1) if filter_func(d)]\n    \n    # Sort the digits based on the order\n    if order == 'ascending':\n        digits.sort()\n    else:\n        digits.sort(reverse=True)\n    \n    return digits", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/0_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef has_close_elements(numbers: List[float], x: float, tolerance: float) -> bool:\n    for number in numbers:\n        if abs(number - x) <= tolerance:\n            return True\n    return False", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/1_prompt2ap", "code_candidates": [{"code": "def extract_balanced_parentheses(s: str) -> List[str]:\n    from typing import List\n\n    result = []\n    stack = []\n    current = \"\"\n\n    for char in s:\n        if char == '(':\n            stack.append(char)\n            current += char\n        elif char == ')':\n            if stack:\n                stack.pop()\n                current += char\n                if not stack:\n                    result.append(current)\n                    current = \"\"\n            else:\n                current = \"\"\n        else:\n            if stack:\n                current += char\n\n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/2_prompt2ap", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, the function should return the integer part. \n    If the input number is exactly an integer, it should return the number itself.\"\"\"\n    \n    if number % 1 == 0:\n        return number\n    return int(number)", "index": 0, "passed_case": [], "case_status": ["3", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/3_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef below_zero(operations: List[int], initial_balance: int) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    a given initial balance (e.g. positive or zero). Your task is to detect if at any point the balance of account falls below zero.\n\n    The function should return True if the balance falls below zero at any point, otherwise False.\n    If the list of operations is empty, the function should return False since no operations are performed.\n    \"\"\"\n    current_balance = initial_balance\n    \n    for operation in operations:\n        current_balance += operation\n        if current_balance < 0:\n            return True\n    \n    return False", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/4_prompt2ap", "code_candidates": [{"code": "from typing import List, Union\nimport statistics\n\ndef calculate_mad(numbers: List[Union[int, float]], central_tendency: str = 'mean') -> float:\n    if not numbers:\n        return 0.0\n    \n    if central_tendency == 'mean':\n        measure = sum(numbers) / len(numbers)\n    elif central_tendency == 'median':\n        measure = statistics.median(numbers)\n    else:\n        raise ValueError(\"Invalid central tendency specified. Use 'mean' or 'median'.\")\n    \n    absolute_deviations = [abs(num - measure) for num in numbers]\n    mad = sum(absolute_deviations) / len(absolute_deviations)\n    \n    return mad", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/6_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef parse_nested_parentheses(s: str) -> List[int]:\n    if not s:\n        return []\n    \n    result = []\n    stack = []\n    count = 0\n    for char in s:\n        if char == '(':\n            stack.append(char)\n            count += 1\n        elif char == ')':\n            if not stack:\n                raise ValueError(\"Mismatched parentheses: too many closing parentheses.\")\n            stack.pop()\n            if not stack:\n                result.append(count)\n                count = 0\n        elif char not in '()':\n            if stack:\n                continue\n            else:\n                if count > 0:\n                    result.append(count)\n                    count = 0\n    if stack:\n        raise ValueError(\"Mismatched parentheses: too many opening parentheses.\")\n    if count > 0:\n        result.append(count)\n    \n    return result", "index": 0, "passed_case": [1], "case_status": ["[3, 3, 1, 5]", "[1, 2, 3, 4]", "[7]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/7_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef filter_strings(input_list: List[str], substring: str) -> List[str]:\n    if not input_list:\n        return []\n    if not substring:\n        return input_list\n    return [s for s in input_list if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/8_prompt2ap", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef process_even_integers(lst: List[int]) -> Tuple[int, int]:\n    if not lst:\n        return (0, 1)\n    \n    if len(lst) == 1:\n        return (lst[0], lst[0] if lst[0] % 2 == 0 else 1)\n    \n    even_numbers = [x for x in lst if x % 2 == 0]\n    \n    if not even_numbers:\n        return (0, 1)\n    \n    sum_even = sum(even_numbers)\n    product_even = 1\n    for num in even_numbers:\n        product_even *= num\n    \n    return (sum_even, product_even)", "index": 0, "passed_case": [0, 2, 4], "case_status": ["(0, 1)", "(0, 1)", "(100, 0)", "(0, 1)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/9_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef max_with_previous(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n    \n    result = [nums[0]]\n    for i in range(1, len(nums)):\n        result.append(max(nums[i], nums[i-1]))\n    \n    return result", "index": 0, "passed_case": [0, 1, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 3, 2]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/10_prompt2ap", "code_candidates": [{"code": "def candidate(string: str) -> str:\n    \"\"\" Find either the longest or shortest palindrome in the given string. If there are ties, specify which one to return.\n    \"\"\"\n    if not string:\n        return \"\"\n    \n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n    \n    palindromes = []\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            substring = string[i:j]\n            if is_palindrome(substring):\n                palindromes.append(substring)\n    \n    if not palindromes:\n        return \"\"\n    \n    # Sort palindromes by length, with the longest first\n    palindromes.sort(key=lambda x: len(x), reverse=True)\n    \n    # If there are ties for the longest, return the first one\n    longest = palindromes[0]\n    \n    # Find the shortest palindrome\n    shortest = min(palindromes, key=len)\n    \n    # If there are ties for the shortest, return the first one\n    return longest if len(longest) != len(shortest) else shortest", "index": 0, "passed_case": [0, 1, 3], "case_status": ["", "x", "x", "xyx", "rr"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/13_prompt2ap", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of a and b.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/14_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return all prefixes of the input string, including the string itself and an empty string if applicable.\n\n    Examples:\n    - all_prefixes('abc') -> ['a', 'ab', 'abc']\n    - all_prefixes('') -> ['']\n    \"\"\"\n    return [string[:i] for i in range(1, len(string) + 1)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/15_prompt2ap", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing sequential numbers starting from 1 up to n, delimited by dots. If n is 0, return an empty string. If n is negative, raise a ValueError.\"\"\"\n    if n < 0:\n        raise ValueError(\"n cannot be negative\")\n    if n == 0:\n        return \"\"\n    return \".\".join(str(i) for i in range(1, n + 1))", "index": 0, "passed_case": [], "case_status": ["", "1.2.3", "1.2.3.4.5.6.7.8.9.10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/16_prompt2ap", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many characters (regardless of case) does it consist of\n    \"\"\"\n    if not string:\n        return 0\n    \n    # Convert the string to lowercase to ignore case\n    string = string.lower()\n    \n    # Use a set to store distinct characters\n    distinct_chars = set(string)\n    \n    return len(distinct_chars)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/18_prompt2ap", "code_candidates": [{"code": "def how_many_times(a: str, b: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string.\n    \"\"\"\n    if not a or not b:\n        return 0\n    count = 0\n    start = 0\n    while True:\n        start = a.find(b, start)\n        if start == -1:\n            break\n        count += 1\n        start += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/19_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef sort_numbers(numbers: List[int]) -> List[int]:\n    \"\"\" Sorts a list of integers in ascending order.\n    \"\"\"\n    if numbers is None:\n        return []\n    return sorted(numbers)", "index": 0, "passed_case": [], "case_status": ["[]", "['e', 'e', 'h', 'r', 't']", "[' ', ' ', 'e', 'e', 'e', 'e', 'f', 'h', 'i', 'i', 'n', 'n', 'r', 't', 'v']", "[' ', ' ', ' ', ' ', ' ', 'e', 'e', 'e', 'e', 'e', 'e', 'f', 'f', 'g', 'h', 'i', 'i', 'i', 'n', 'n', 'n', 'o', 'o', 'r', 'r', 's', 't', 'u', 'v', 'v', 'z']", "[' ', ' ', ' ', ' ', ' ', ' ', 'e', 'e', 'e', 'e', 'e', 'f', 'f', 'h', 'i', 'i', 'n', 'o', 'o', 'o', 'o', 'r', 'r', 'r', 's', 't', 't', 'u', 'v', 'w', 'x', 'z']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/20_prompt2ap", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef find_closest_pair(numbers: List[float]) -> Tuple[float, float]:\n    if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n    \n    numbers_sorted = sorted(numbers)\n    min_distance = float('inf')\n    closest_pair = (numbers_sorted[0], numbers_sorted[1])\n    \n    for i in range(1, len(numbers_sorted)):\n        distance = abs(numbers_sorted[i] - numbers_sorted[i-1])\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (numbers_sorted[i-1], numbers_sorted[i])\n    \n    return closest_pair", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/23_prompt2ap", "code_candidates": [{"code": "def longest_palindrome_substring_length(s: str) -> int:\n    if not s:\n        return 0\n\n    n = len(s)\n    max_length = 1\n    dp = [[False] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = True\n\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            dp[i][i + 1] = True\n            max_length = 2\n\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j] and dp[i + 1][j - 1]:\n                dp[i][j] = True\n                max_length = length\n\n    return max_length", "index": 0, "passed_case": [0, 1], "case_status": ["0", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/24_prompt2ap", "code_candidates": [{"code": "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, excluding n itself.\"\"\"\n    if n == 0:\n        return 0\n    if n < 0:\n        n = -n\n    for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/25_prompt2ap", "code_candidates": [{"code": "def factorize(n: int) -> list:\n    if n == 0:\n        return []\n    \n    n = abs(n)\n    factors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            factors.append(i)\n    \n    return factors", "index": 0, "passed_case": [], "case_status": ["[1, 2]", "[1, 2, 4]", "[1, 2, 4, 8]", "[1, 3, 19, 57]", "[1, 3, 9, 19, 57, 171, 361, 1083, 3249]", "[1, 3, 9, 19, 27, 57, 171, 361, 513, 1083, 3249, 6859, 9747, 20577, 61731, 185193]", "[1, 3, 19, 57, 361, 1083, 6859, 20577]", "[1, 2, 3, 6, 9, 18]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/26_prompt2ap", "code_candidates": [{"code": "from typing import List\nfrom collections import Counter\n\ndef remove_duplicates(numbers: List[int], K: int) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur K time(s).\"\"\"\n    if not numbers:\n        return []\n    \n    count = Counter(numbers)\n    return [num for num in numbers if count[num] != K]", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/27_prompt2ap", "code_candidates": [{"code": "def flip_case(s: str) -> str:\n    \"\"\"\n    Flip the case of all alphabetic characters in the string, leaving non-alphabetic characters unchanged.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with flipped case.\n    \"\"\"\n    return ''.join(char.upper() if char.islower() else char.lower() if char.isupper() else char for char in s)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/41_prompt2ap", "code_candidates": [{"code": "from typing import List, Tuple\nimport random\n\ndef simulate_car_collisions(n: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Simulate car collisions on an infinitely long straight road.\n\n    Args:\n        n (int): Number of cars moving in each direction.\n\n    Returns:\n        List[Tuple[int, int]]: List of collision pairs (positions).\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Number of cars cannot be negative.\")\n    if n == 0:\n        return []\n    \n    # Generate positions for cars moving in opposite directions\n    left_moving_cars = sorted([random.uniform(-1e6, 1e6) for _ in range(n)])\n    right_moving_cars = sorted([random.uniform(-1e6, 1e6) for _ in range(n)])\n    \n    collisions = []\n    left_index = 0\n    right_index = 0\n    \n    # Detect collisions\n    while left_index < n and right_index < n:\n        if left_moving_cars[left_index] < right_moving_cars[right_index]:\n            collisions.append((left_moving_cars[left_index], right_moving_cars[right_index]))\n            left_index += 1\n        else:\n            right_index += 1\n    \n    return collisions", "index": 0, "passed_case": [], "case_status": ["[(-755007.0285091281, -397022.41424341337), (-530341.6522494901, -397022.41424341337)]", "[(-934168.3715641081, -874233.897023811), (-1158.3962351102382, 735207.3154292179), (95522.75258545647, 735207.3154292179)]", "[(-968197.4050058376, -938684.0132682106), (-525067.7031370845, -419208.9466020672), (-243380.93961607222, 464158.7023835301), (39304.6523294549, 464158.7023835301)]", "[(-965942.3234817688, -933214.3222975053), (-536493.9437855599, -8980.52960652439), (53584.38015061617, 208139.22322227363), (121061.76165050385, 208139.22322227363), (205010.3342166883, 208139.22322227363), (373501.1820092364, 714800.494988983), (569059.4371904449, 714800.494988983)]", "[(-901695.0392666088, -751233.6289220453), (-871364.2041085055, -751233.6289220453), (-674886.2074645879, -423300.8020225046), (-567069.4625738766, -423300.8020225046), (-378754.90420915314, -159086.13580558263), (-273603.57887355785, -159086.13580558263), (-32519.94120461133, 838931.078599496), (3667.6646529736463, 838931.078599496), (13059.367926332168, 838931.078599496), (543452.159888458, 838931.078599496)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/49_prompt2ap", "code_candidates": [{"code": "def modp(x: int, y: int) -> int:\n    \"\"\"Return 2 raised to the power of x modulo y.\"\"\"\n    return pow(2, x, y)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/50_prompt2ap", "code_candidates": [{"code": "import base64\n\ndef candidate(input_string: str) -> str:\n    try:\n        # Attempt to decode the input string\n        decoded_bytes = base64.b64decode(input_string)\n        decoded_string = decoded_bytes.decode('utf-8')\n        return decoded_string\n    except (base64.binascii.Error, UnicodeDecodeError):\n        # If decoding fails, encode the input string\n        encoded_bytes = base64.b64encode(input_string.encode('utf-8'))\n        encoded_string = encoded_bytes.decode('utf-8')\n        return encoded_string", "index": 0, "passed_case": [], "case_status": ["aWZjbm1tamNpYWN3aHhzZ2ZobG0=", "eWZ3bGJ6YndzbXR4bmVmZGVr", "cG5qbGRwaWhyaXFxeW5lZw==", "d2lyaHdvenlxeGxiaGdhbWQ=", "aG1pcm50enFrcXFsYW4=", "emh5emt3Y21rdHJuemJ3bWFwZGQ=", "bWdlcHJuaGx4Yg==", "bHp1cnp0am5qbWN3d25j", "c3hycW1qdnVoZGdpanprZWFzeQ==", "cnJ5dHZud2ZhY2k=", "d2RuZHpwaW9za3RmY2NudmRrdmk=", "b3p2eWxqcWRrd2R2ZnlwdWZpcWU=", "bWdteGhoY3VoZHdkamo=", "dXdrbnZ5c2x3ZGNibGJvcmF6cXQ=", "dGltbWhwZnh3bXhtZmhiemdt", "Z3Bodm1uYXVsd2o=", "eHVtZXVlc2xpaWFzcXNzdGNnYQ==", "emlncmNwZWltbGx3dGpza250bWg=", "ZXdpZ3p3ZmhkbWtzdXVscmc=", "cmZybmVldG9zYmNl", "YWJ1amxvbGd4Y3dnY3BnZ3h1", "dmtndmhraHloYW1yaXhteHln", "aHNheHh2cG5sYWJwbW5yamF6bw==", "cGRoZnR5eGlod2x2bmpxaG0=", "b2t0d2JveWV6dmZhd29h", "am5paWN3am5veWw=", "bGF6bnZ1bmdoenNuZ2Zw", "em5rY3R3YnN3Zmlo", "d2dxeHdqc2pnb3Fl", "cWxhbWFpcWR3cw==", "Y2pta2Vla3Nma2NwZXNlYWNlbQ==", "a2ViaXJndW1sdHFvZW0=", "ZmFscnBuaGRucXp2cg==", "d3BmaW5reG5naXlzcWNlcHN5dmk=", "eGxuZ2JzZnZld2FjY2NhbA==", "c2hhcHlwYWljb3ZvYXNw", "Ym93amxzYXJhY2t5eG9ydw==", "b29sc2V4eXpwdA==", "dGFsdnVlZWNrYWhvdmF6eXA=", "ZG1hb21lbGpmZ20=", "eWRodHN6eGxiYnJ1cm1qemI=", "ZGRpZHNta2Vidg==", "Z3dtaXRqZXRhdnd5cGR0eWM=", "c3d0a2N1dG5kbXpuZGR2dXpt", "dGhib21ucHB3aGpqbXI=", "Ymxoc3Nwd3RzZ2xz", "ZHhiZmR4cnVmcW9kcnN3Yw==", "ZXltdW1uc3VmcnBhYWVyY2t0", "eXdmcnh4YWZoenNq", "a2ducnBsdHBwZHJuZHNuaHU=", "Y3dncW16aGR6Zw==", "bWxmeWptanVhaQ==", "bHRibmRxa3l5Y2JpZGtvaXhmbw==", "YXJyYmxoeGJ6bWliZG9heWVpZQ==", "ZWdxd3NhcWh2enBmc3Vpc3F6dA==", "c2tjdnpueWV3ZHV0", "Y3hucG1obnRtZHR4eWFycA==", "dXBrdWxxZW5wbg==", "Ym53ZnZsaG1jc3V3ZG1idXpidQ==", "ZWZob21yYm1vYXhxdXd2cXM=", "cHFidG5vbm1pY2xwaWN3ZGJr", "bGN1bmN4ZHZ5b2lsbw==", "cWtvZmJ3am5nZ3dvYg==", "emR1aWZ4b3V1dHBr", "bnVpaHJ1aHh6YQ==", "ampleG9obWl3ZA==", "eXlleW1kdnJ0dG94c294eQ==", "eWNpZGx6bG5haA==", "bWt3aGtmc3RieXVv", "bW9ib2J0aGFtbg==", "eGFlbHNpd216am5qaGdrZW95Y3g=", "dGl0Ym9icm52d3V0aHk=", "c2NweW5maG1heA==", "ZmRhbnhnZGRrdXZ6dG5reHN6dQ==", "dXFzcHBhaWtwc2I=", "b2FyZHdndGhwbnBpZHJ2ZmE=", "dHNnbHZxeWR1enRkZ2xud2pv", "YnVpZnp5ZW1ia293ZndzaG0=", "dGl6anVib3ZibnM=", "dW10d2pybHl2Y2pobmRlc3A=", "bmZvY294eGF1anR3dXFwd2R3", "dHBsYm14cm1kc2dwY3ViZQ==", "cmFlemp1Z2p2eHBpdGl2dA==", "Y2pzempodWVucA==", "YnJ6aHBhd3JwemJkdXdneWhteg==", "b21jaHNpZHpiaXRrYm9mZ3BlZ28=", "cXNqbXZzeGFla2traHly", "YW11eGptdHpudG5hZmV0b2F3aw==", "dHF4b3pzYm50b2w=", "dWltcnhxeG9ib2Zhcm5meA==", "ZGNneWN1b2RlbXllcW16bHluYWQ=", "YWp6aXp6Z29ldGd4cWNqaG9wY3M=", "bGpld3F2dm5rbnVl", "Y3BlaXRoamRtYWNhcmU=", "cWhlcmZud2l0cWFjYW54cnpx", "YW11Znl3cHltemg=", "dGJvenNpamdnb3VpaW13anJ0cWE=", "c3hjY2pzeml1eXNuZ2JxbHR0", "cWlhcXd6cWdybmxpdA==", "YWx6enlmZ2VwbWo="]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/56_prompt2ap", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"<\" and \">\".\n\n    >>> correct_bracketing(\"<\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        elif bracket == \">\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/58_prompt2ap", "code_candidates": [{"code": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return common elements between l1 and l2.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1) & set(l2))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/59_prompt2ap", "code_candidates": [{"code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\"\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    largest_factor = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            if is_prime(i):\n                largest_factor = i\n            other_factor = n // i\n            if is_prime(other_factor):\n                return other_factor\n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/61_prompt2ap", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"(\" and \")\".\n\n    >>> correct_bracketing(\"(\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            balance += 1\n        elif bracket == \")\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/63_prompt2ap", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/65_prompt2ap", "code_candidates": [{"code": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits left or right by shift\n    and return the result as a string.\n    \"\"\"\n    x_str = str(x)\n    length = len(x_str)\n    \n    # Normalize the shift to be within the range of the number's length\n    shift = shift % length\n    \n    if shift == 0:\n        return x_str\n    \n    # Perform circular shift\n    if shift > 0:\n        # Right shift\n        shifted_str = x_str[-shift:] + x_str[:-shift]\n    else:\n        # Left shift\n        shift = -shift\n        shifted_str = x_str[shift:] + x_str[:shift]\n    \n    return shifted_str", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["001", "12", "97", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/69_prompt2ap", "code_candidates": [{"code": "from collections import Counter\n\ndef search(lst):\n    \"\"\"\n    You are given a non-empty list of positive integers. Return the smallest or greatest integer that is greater than zero and has the highest frequency in the list. \n    If multiple integers have the same highest frequency, return the smallest one among them.\n    \"\"\"\n    # Count the frequency of each integer in the list\n    frequency = Counter(lst)\n    \n    # Find the maximum frequency\n    max_freq = max(frequency.values())\n    \n    # Find all integers with the maximum frequency\n    candidates = [num for num, freq in frequency.items() if freq == max_freq]\n    \n    # Return the smallest integer among the candidates\n    return min(candidates)", "index": 0, "passed_case": [1, 3, 4, 6, 10, 11, 12, 14, 18, 22], "case_status": ["5", "4", "3", "8", "2", "7", "2", "8", "6", "8", "1", "5", "1", "2", "2", "6", "1", "2", "2", "5", "10", "7", "1", "7", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/70_prompt2ap", "code_candidates": [{"code": "def strange_sort_list(lst):\n    if not lst:\n        return []\n    \n    first_element = lst[0]\n    last_element = lst[-1]\n    middle_elements = lst[1:-1] if len(lst) > 2 else []\n    \n    return [first_element, last_element] + middle_elements\n\n# Examples\n# strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n# strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n# strange_sort_list([]) == []", "index": 0, "passed_case": [0, 4, 5], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 7, 8]", "[1, 5, 2, 3, 4]", "[5, 1, 6, 7, 8, 9]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 3, 4, 5, 6, 7]", "[0, -5, 2, 2, 2, 5, 5, -5]", "[111111, 111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/71_prompt2ap", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return None if the sides do not form a valid triangle\n        return None", "index": 0, "passed_case": [0, 2, 3, 5, 7], "case_status": ["6.0", "None", "8.18", "1.73", "None", "16.25", "None", "0.43", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/78_prompt2ap", "code_candidates": [{"code": "def hex_key(num: str) -> int:\n    \"\"\"\n    Counts the number of prime digits in a hexadecimal number string.\n    \n    Parameters:\n    num (str): The hexadecimal number as a string.\n    \n    Returns:\n    int: The count of prime digits in the hexadecimal number.\n    \"\"\"\n    # Define the prime digits in hexadecimal\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count the occurrences of prime digits in the input string\n    count = 0\n    for char in num.upper():\n        if char in prime_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["1", "2", "4", "2", "6", "12", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/79_prompt2ap", "code_candidates": [{"code": "def decimal_to_binary(decimal: int) -> str:\n    \"\"\"Convert a decimal number to a binary string. The string should consist of '0' and '1' characters, and optionally include '2' if specified. Additionally, include 'db' characters at a specified position if required.\"\"\"\n    if not isinstance(decimal, int) or decimal < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    binary_str = \"\"\n    while decimal > 0:\n        binary_str = str(decimal % 2) + binary_str\n        decimal //= 2\n    \n    # Handle the case where the input is 0\n    if not binary_str:\n        binary_str = \"0\"\n    \n    # Optionally include '2' if specified (not clear in the requirement, so we skip this part)\n    # Optionally include 'db' at a specified position (not clear in the requirement, so we skip this part)\n    \n    return binary_str", "index": 0, "passed_case": [], "case_status": ["0", "100000", "1100111", "1111"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/81_prompt2ap", "code_candidates": [{"code": "def numerical_letter_grade(grades: List[float], grading_table: Dict[str, Tuple[float, float]]) -> List[str]:\n    \"\"\"\n    Converts numerical grades to letter grades based on a provided grading table.\n\n    Args:\n        grades (List[float]): A list of numerical grades to be converted.\n        grading_table (Dict[str, Tuple[float, float]]): A dictionary mapping letter grades to their corresponding numerical ranges.\n\n    Returns:\n        List[str]: A list of letter grades corresponding to the input numerical grades.\n    \"\"\"\n    letter_grades = []\n    for grade in grades:\n        if grade is None:\n            letter_grades.append(None)\n            continue\n        for letter, (lower, upper) in grading_table.items():\n            if lower <= grade <= upper:\n                letter_grades.append(letter)\n                break\n        else:\n            letter_grades.append(None)  # Grade not found in the grading table\n    return letter_grades", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/88_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef sort_array_by_sum_of_indices(arr: List[int]) -> List[int]:\n    if not arr:\n        return []\n    \n    if len(arr) == 1:\n        return arr\n    \n    first_index_value = arr[0]\n    last_index_value = arr[-1]\n    sum_indices = first_index_value + last_index_value\n    \n    # Determine if the sum is odd or even\n    if sum_indices % 2 == 0:\n        # Sum is even, sort in ascending order\n        return sorted(arr)\n    else:\n        # Sum is odd, sort in ascending order\n        return sorted(arr)", "index": 0, "passed_case": [0, 1, 2, 4, 5], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[0, 1, 2, 3, 4, 5, 6]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[11, 14, 21, 23]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/92_prompt2ap", "code_candidates": [{"code": "def any_int(x, y, z):\n    return x > 10 or y > 10 or z > 10", "index": 0, "passed_case": [1, 2, 3, 5, 9], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/95_prompt2ap", "code_candidates": [{"code": "def check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if some or all keys are strings in lower \n    case or some or all keys are strings in upper case.\n    \"\"\"\n    if not isinstance(dict, dict):\n        return False\n\n    for key in dict:\n        if isinstance(key, str):\n            if not (key.islower() or key.isupper()):\n                return False\n        else:\n            return False\n\n    return True", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/96_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef is_prime(num: int) -> bool:\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_up_to(n: int) -> List[int]:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    primes = []\n    current_num = 2\n    while len(primes) < n:\n        if is_prime(current_num):\n            primes.append(current_num)\n        current_num += 1\n    return primes", "index": 0, "passed_case": [4], "case_status": ["[2, 3, 5, 7, 11]", "[2, 3, 5, 7, 11, 13]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79]", "[2]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/97_prompt2ap", "code_candidates": [{"code": "def multiply_integers(a: int, b: int) -> int:\n    return a * b", "index": 0, "passed_case": [6, 7], "case_status": ["60976", "532", "3739020", "-210", "5092", "459", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/99_prompt2ap", "code_candidates": [{"code": "import math\n\ndef closest_integer(value: str) -> int:\n    try:\n        number = float(value)\n        lower = math.floor(number)\n        upper = math.ceil(number)\n        if abs(number - lower) < abs(number - upper):\n            return int(lower)\n        else:\n            return int(upper)\n    except ValueError:\n        raise ValueError(\"The input value must be a string representing a number.\")", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["10", "15", "-15", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/100_prompt2ap", "code_candidates": [{"code": "def create_stone_pile(n: int) -> List[int]:\n    if n <= 0:\n        return []\n    \n    pile = []\n    current_stones = n\n    for _ in range(n):\n        pile.append(current_stones)\n        if current_stones % 2 == 0:\n            current_stones += 2\n        else:\n            current_stones += 2\n    \n    return pile", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/101_prompt2ap", "code_candidates": [{"code": "import re\n\ndef words_string(s: str) -> list:\n    if not s:\n        return []\n    # Use regex to split by commas, spaces, and any non-alphanumeric characters\n    words = re.split(r'[,\\s\\W]+', s)\n    # Filter out any empty strings resulting from consecutive delimiters\n    words = [word for word in words if word]\n    return words", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/102_prompt2ap", "code_candidates": [{"code": "def choose_num(x, y):\n    \"\"\"\n    This function takes two positive numbers x and y and returns the biggest number \n    that is either odd or even, prioritizing the biggest number regardless of parity.\n    \"\"\"\n    # Ensure x and y are positive\n    if x <= 0 or y <= 0:\n        raise ValueError(\"Both x and y must be positive numbers.\")\n    \n    # Determine the bigger number\n    bigger = max(x, y)\n    smaller = min(x, y)\n    \n    # Prioritize the bigger number regardless of parity\n    if bigger % 2 == 0 or bigger % 2 == 1:\n        return bigger\n    \n    # If the bigger number is not odd or even, return the smaller number\n    return smaller", "index": 0, "passed_case": [2, 7], "case_status": ["15", "13", "12354", "5234", "29", "27", "7", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/103_prompt2ap", "code_candidates": [{"code": "def compute_max(n: int, m: int) -> int:\n    if n > m:\n        return n\n    else:\n        return m", "index": 0, "passed_case": [], "case_status": ["5", "13", "977", "997", "851", "546", "496", "902", "233", "7", "5", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/105_prompt2ap", "code_candidates": [{"code": "def by_length(arr):\n    \"\"\"\n    Given an array of integers, sort the integers ascendingly that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from a predefined mapping.\n    \n    The predefined mapping is as follows:\n    1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'\n    \n    Integers outside the range 1 to 9 should be excluded from the sorted array.\n    If the input array is empty, return an empty array.\n    \"\"\"\n    # Predefined mapping\n    digit_name_mapping = {\n        1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five',\n        6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'\n    }\n    \n    # Filter integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array ascendingly\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Replace each digit by its corresponding name\n    result = [digit_name_mapping[num] for num in reversed_arr]\n    \n    return result", "index": 0, "passed_case": [1], "case_status": ["['eight', 'five', 'four', 'three', 'two', 'two', 'one', 'one']", "[]", "['one']", "['three', 'two', 'one']", "['nine', 'eight', 'four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/106_prompt2ap", "code_candidates": [{"code": "from typing import List\nfrom math import factorial\n\ndef f(n: int) -> List[int]:\n    result = []\n    for i in range(n):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(1)\n    return result", "index": 0, "passed_case": [2], "case_status": ["[1, 1, 2, 1, 24]", "[1, 1, 2, 1, 24, 1, 720]", "[1]", "[1, 1, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/112_prompt2ap", "code_candidates": [{"code": "def reverse_delete(s: str, c: str) -> bool:\n    # Delete all characters in s that are present in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the result string is a palindrome\n    return result == result[::-1]", "index": 0, "passed_case": [], "case_status": ["False", "False", "True", "False", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/114_prompt2ap", "code_candidates": [{"code": "def minSubArraySum(nums):\n    \"\"\"\n    Find the minimum sum of any contiguous subarray within the given list of integers.\n    \n    Args:\n    nums (List[int]): A list of integers.\n    \n    Returns:\n    int: The minimum sum of any contiguous subarray.\n    \"\"\"\n    if not nums:\n        return 0\n    \n    current_min = float('inf')\n    min_sum = float('inf')\n    \n    for num in nums:\n        current_min = min(num, current_min + num)\n        min_sum = min(min_sum, current_min)\n    \n    return min_sum if min_sum != float('inf') else 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/115_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef max_fill(grid: List[List[int]], capacity: int) -> int:\n    if not grid or capacity == 0:\n        return 0\n    \n    total_units = 0\n    for row in grid:\n        for unit in row:\n            total_units += min(unit, capacity)\n    \n    return total_units", "index": 0, "passed_case": [0, 2], "case_status": ["6", "9", "0", "8", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/117_prompt2ap", "code_candidates": [{"code": "from typing import List, Callable\n\ndef select_words(words: List[str], criterion: Callable[[str], bool]) -> List[str]:\n    \"\"\"\n    Selects words from a list based on a provided criterion function.\n\n    Args:\n        words (List[str]): A list of words to filter.\n        criterion (Callable[[str], bool]): A function that takes a word and returns True if the word meets the criterion, False otherwise.\n\n    Returns:\n        List[str]: A list of words that meet the specified criterion.\n    \"\"\"\n    return [word for word in words if criterion(word)]", "index": 0, "passed_case": [5], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "[]", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/118_prompt2ap", "code_candidates": [{"code": "def get_closest_vowel(word: str) -> str:\n    vowels = set(\"aeiouAEIOU\")\n    for char in word:\n        if char in vowels:\n            return char\n    return \"\"", "index": 0, "passed_case": [1, 5, 6], "case_status": ["o", "u", "e", "e", "a", "a", "o", "a", "a", "u", "a", "A", "A"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/119_prompt2ap", "code_candidates": [{"code": "def can_form_valid_parentheses(strings: List[str]) -> bool:\n    def is_valid_parentheses(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            else:\n                raise ValueError(\"Invalid character in the string\")\n            if balance < 0:\n                return False\n        return balance == 0\n\n    def count_parentheses(s: str) -> int:\n        open_count = s.count('(')\n        close_count = s.count(')')\n        return open_count, close_count\n\n    if len(strings) != 2:\n        raise ValueError(\"The input list must contain exactly two strings\")\n\n    try:\n        open_count1, close_count1 = count_parentheses(strings[0])\n        open_count2, close_count2 = count_parentheses(strings[1])\n    except ValueError:\n        raise ValueError(\"Invalid character in the string\")\n\n    total_open = open_count1 + open_count2\n    total_close = close_count1 + close_count2\n\n    if total_open != total_close:\n        return False\n\n    # Check if we can form a valid string by concatenating in some order\n    return is_valid_parentheses(strings[0] + strings[1]) or is_valid_parentheses(strings[1] + strings[0])", "index": 0, "passed_case": [], "case_status": ["True", "False", "False", "True", "True", "False", "True", "False", "False", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/120_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef k_largest_elements(arr: List[int], k: int) -> List[int]:\n    if not arr or k <= 0:\n        return []\n    if k >= len(arr):\n        return sorted(arr, reverse=True)\n    return sorted(arr, reverse=True)[:k]", "index": 0, "passed_case": [1, 2, 7, 10], "case_status": ["[5, -3, -4]", "[4, 4]", "[2]", "[123, 20, 2]", "[20, 2, 1, 0]", "[15, 5, 3, 0, 0, -8, -13]", "[5, 3]", "[5]", "[4, -4]", "[10, -10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/121_prompt2ap", "code_candidates": [{"code": "def solution(lst: List[int]) -> int:\n    \"\"\"Given a non-empty list of integers, return the sum of all even elements.\"\"\"\n    return sum(x for x in lst if x % 2 == 0)", "index": 0, "passed_case": [], "case_status": ["0", "54", "0", "14", "62", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/122_prompt2ap", "code_candidates": [{"code": "def add_elements(arr, k):\n    # Initialize sum to 0\n    total_sum = 0\n    \n    # Iterate through the array\n    for num in arr:\n        # Check if the number has at most two digits\n        if -99 <= num <= 99:\n            total_sum += num\n    \n    # Return the sum of elements with at most two digits\n    return total_sum", "index": 0, "passed_case": [4], "case_status": ["444", "14", "160", "59", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/125_prompt2ap", "code_candidates": [{"code": "def split_words(txt: str) -> list:\n    if not isinstance(txt, str):\n        return []\n    \n    words = txt.split()\n    if len(words) == 1:\n        words = txt.split(',')\n        if len(words) == 1:\n            return []\n    \n    return words", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['Hello', 'world!']", "['Hello', 'world!']", "['Hello', 'world,!']", "['Hello,Hello,world', '!']", "[]", "[]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/126_prompt2ap", "code_candidates": [{"code": "def is_sorted(lst):\n    if not lst:\n        return True\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/129_prompt2ap", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef path(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    \"\"\"\n    if not grid or not grid[0]:\n        return []\n    \n    N = len(grid)\n    if N != len(grid[0]):\n        return []\n    \n    if k <= 0:\n        return []\n    \n    # Create a mapping from value to coordinates\n    value_to_coords = {}\n    for i in range(N):\n        for j in range(N):\n            value_to_coords[grid[i][j]] = (i, j)\n    \n    # Start from the smallest value\n    path = []\n    current_value = 1\n    path.append(current_value)\n    \n    for _ in range(k - 1):\n        current_coords = value_to_coords[current_value]\n        neighbors = []\n        \n        # Check all four possible neighbors\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = current_coords[0] + dx, current_coords[1] + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                neighbors.append(grid[nx][ny])\n        \n        # Choose the smallest neighbor\n        next_value = min(neighbors)\n        path.append(next_value)\n        current_value = next_value\n    \n    return path", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[1, 2, 1]", "[1]", "[1, 2, 1, 2]", "[1, 10, 1, 10, 1, 10, 1]", "[1, 7, 1, 7, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]", "[1, 3, 1, 3, 1, 3, 1, 3]", "[1, 5, 1, 5, 1, 5, 1, 5]", "[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/130_prompt2ap", "code_candidates": [{"code": "def tri(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"n must be a positive integer.\")\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    \n    a, b, c = 1, 1, 2\n    for _ in range(4, n + 1):\n        a, b, c = b, c, a + b + c\n    \n    return c", "index": 0, "passed_case": [], "case_status": ["2", "4", "7", "13", "24", "44", "81", "66012", "execution error: 1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/131_prompt2ap", "code_candidates": [{"code": "def digits(n: int) -> int:\n    if n == 0:\n        return 0\n    total = 0\n    while n > 0:\n        total += n % 10\n        n = n // 10\n    return total", "index": 0, "passed_case": [0], "case_status": ["5", "9", "10", "35", "35", "20"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/134_prompt2ap", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(txt: str) -> bool:\n    '''\n    Returns True if the last non-space character of a given string is a letter, and False otherwise.\n    '''\n    if not txt:\n        return False\n    \n    # Iterate backwards to find the last non-space character\n    for char in reversed(txt):\n        if char != ' ':\n            return char.isalpha()\n    \n    return False", "index": 0, "passed_case": [1, 3, 5, 6], "case_status": ["True", "True", "True", "True", "True", "False", "False", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/135_prompt2ap", "code_candidates": [{"code": "def can_arrange(arr, value):\n    if not arr:\n        return -1\n    \n    max_index = -1\n    for i, num in enumerate(arr):\n        if num < value:\n            max_index = i\n    \n    return max_index", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/136_prompt2ap", "code_candidates": [{"code": "def largest_smallest_integers(lst):\n    if not lst:\n        return (None, None)\n    \n    negative_integers = [x for x in lst if isinstance(x, int) and x < 0]\n    \n    if not negative_integers:\n        return (None, None)\n    \n    largest_negative = max(negative_integers)\n    smallest_negative = min(negative_integers)\n    \n    return (largest_negative, smallest_negative)", "index": 0, "passed_case": [5, 6], "case_status": ["(None, None)", "(None, None)", "(-2, -2)", "(-7, -7)", "(-9, -9)", "(None, None)", "(None, None)", "(-1, -6)", "(-1, -6)", "(-3, -6)", "(-3, -100)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/140_prompt2ap", "code_candidates": [{"code": "def replace_spaces_with_underscores(text: str) -> str:\n    if not text:\n        return text\n    return '_'.join(text.split())", "index": 0, "passed_case": [0], "case_status": ["Example", "Mudasir_Hanif", "Yellow_Yellow_Dirty_Fellow", "Exa_mple", "Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/147_prompt2ap", "code_candidates": [{"code": "def get_max_triples(n):\n    # Initialize an empty list to store the array\n    result = []\n    \n    # Iterate over the range from 0 to n-1\n    for i in range(n):\n        if i % 2 == 0:\n            # For even indices, use i*i + i - 1\n            result.append(i * i + i - 1)\n        else:\n            # For odd indices, use i*i - i + 1\n            result.append(i * i - i + 1)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[-1, 1, 5, 7, 19]", "[-1, 1, 5, 7, 19, 21]", "[-1, 1, 5, 7, 19, 21, 41, 43, 71, 73]", "[-1, 1, 5, 7, 19, 21, 41, 43, 71, 73, 109, 111, 155, 157, 209, 211, 271, 273, 341, 343, 419, 421, 505, 507, 599, 601, 701, 703, 811, 813, 929, 931, 1055, 1057, 1189, 1191, 1331, 1333, 1481, 1483, 1639, 1641, 1805, 1807, 1979, 1981, 2161, 2163, 2351, 2353, 2549, 2551, 2755, 2757, 2969, 2971, 3191, 3193, 3421, 3423, 3659, 3661, 3905, 3907, 4159, 4161, 4421, 4423, 4691, 4693, 4969, 4971, 5255, 5257, 5549, 5551, 5851, 5853, 6161, 6163, 6479, 6481, 6805, 6807, 7139, 7141, 7481, 7483, 7831, 7833, 8189, 8191, 8555, 8557, 8929, 8931, 9311, 9313, 9701, 9703]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/151_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef sum_of_even_squares(numbers: List[int]) -> int:\n    return sum(num ** 2 for num in numbers if num % 2 == 0)", "index": 0, "passed_case": [0, 2], "case_status": ["0", "16", "0", "1400", "68", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/160_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef do_algebra(list1: List[int], list2: List[int]) -> List[int]:\n    if not list1 or not list2:\n        return []\n    if len(list1) != len(list2):\n        raise ValueError(\"The input lists must be of the same length.\")\n    \n    return [x + y for x, y in zip(list1, list2)]", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/163_prompt2ap", "code_candidates": [{"code": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the odd or even digits between them.\n    Specify whether to return odd digits, even digits, or both, and define the range of digits to consider between the two numbers.\n    Handle edge cases such as single-digit numbers or equal numbers.\n    \"\"\"\n    # Ensure a is less than or equal to b\n    if a > b:\n        a, b = b, a\n\n    # Initialize lists to store odd and even digits\n    odd_digits = []\n    even_digits = []\n\n    # Iterate through the range of numbers\n    for num in range(a, b + 1):\n        # Convert the number to a string to iterate through its digits\n        for digit_char in str(num):\n            digit = int(digit_char)\n            if digit % 2 == 0:\n                even_digits.append(digit)\n            else:\n                odd_digits.append(digit)\n\n    # Return both odd and even digits\n    return odd_digits, even_digits\n\n# Example usage:\n# odd, even = generate_integers(10, 20)\n# print(\"Odd digits:\", odd)\n# print(\"Even digits:\", even)", "index": 0, "passed_case": [], "case_status": ["([3, 5, 7, 9, 1], [2, 4, 6, 8, 0])", "([3, 5, 7, 9, 1], [2, 4, 6, 8, 0])", "([3, 5, 7, 9, 1, 1, 1, 1, 1, 3, 1, 1, 5, 1, 1, 7, 1, 1, 9, 1, 3, 5, 7, 9, 3, 3, 1, 3, 3, 3, 3, 3, 5, 3, 3, 7, 3, 3, 9, 1, 3, 5, 7, 9, 5, 5, 1, 5, 5, 3, 5, 5, 5, 5, 5, 7, 5, 5, 9, 1, 3, 5, 7, 9, 7, 7, 1, 7, 7, 3, 7, 7, 5, 7, 7, 7, 7, 7, 9, 1, 3, 5, 7, 9, 9, 9, 1, 9, 9, 3, 9, 9, 5, 9, 9, 7, 9, 9, 9, 1, 1, 1, 1, 1, 3, 1, 1, 5, 1, 1, 7, 1, 1, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 5, 1, 1, 1, 1, 7, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 3, 1, 1, 5, 1, 1, 7, 1, 1, 9, 1, 3, 1, 3, 1, 1, 3], [2, 4, 6, 8, 0, 2, 4, 6, 8, 2, 0, 2, 2, 2, 2, 2, 4, 2, 2, 6, 2, 2, 8, 2, 0, 2, 4, 6, 8, 4, 0, 4, 4, 2, 4, 4, 4, 4, 4, 6, 4, 4, 8, 4, 0, 2, 4, 6, 8, 6, 0, 6, 6, 2, 6, 6, 4, 6, 6, 6, 6, 6, 8, 6, 0, 2, 4, 6, 8, 8, 0, 8, 8, 2, 8, 8, 4, 8, 8, 6, 8, 8, 8, 8, 0, 2, 4, 6, 8, 0, 0, 0, 0, 2, 0, 0, 4, 0, 0, 6, 0, 0, 8, 0, 0, 2, 4, 6, 8, 2, 0, 2, 2, 2, 2, 2, 4, 2, 2, 6, 2, 2, 8, 2, 0, 2])", "([1, 7, 1, 1, 9, 1, 3, 5, 7, 9, 3, 3, 1, 3, 3, 3, 3, 3, 5, 3, 3, 7, 3, 3, 9, 1, 3, 5, 7, 9, 5, 5, 1, 5, 5, 3, 5, 5, 5, 5, 5, 7, 5, 5, 9, 1, 3, 5, 7, 9, 7, 7, 1, 7, 7, 3, 7, 7, 5, 7, 7, 7, 7, 7, 9, 1, 3, 5, 7, 9], [8, 2, 0, 2, 2, 2, 2, 2, 4, 2, 2, 6, 2, 2, 8, 2, 0, 2, 4, 6, 8, 4, 0, 4, 4, 2, 4, 4, 4, 4, 4, 6, 4, 4, 8, 4, 0, 2, 4, 6, 8, 6, 0, 6, 6, 2, 6, 6, 4, 6, 6, 6, 6, 6, 8, 6, 0, 2, 4, 6, 8, 8, 0, 8, 8, 2, 8, 8, 4, 8, 8, 6, 8, 8, 8, 8])"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/4_prompt2cp", "code_candidates": [{"code": "from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation. \n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.5\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(numbers)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/30_prompt2cp", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"\n    Returns a list of all positive numbers from the input list.\n\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [x for x in l if x > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/41_prompt2cp", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    \"\"\"Return True if the integer `n` is a prime number, False otherwise.\"\"\"\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [], "case_status": ["True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/50_prompt2cp", "code_candidates": [{"code": "def candidate(s: str) -> str:\n    decoded_chars = []\n    for char in s:\n        if 'a' <= char <= 'z':\n            decoded_char = chr(((ord(char) - ord('a') - 3) % 26) + ord('a'))\n            decoded_chars.append(decoded_char)\n        elif 'A' <= char <= 'Z':\n            decoded_char = chr(((ord(char) - ord('A') - 3) % 26) + ord('A'))\n            decoded_chars.append(decoded_char)\n        else:\n            decoded_chars.append(char)\n    return ''.join(decoded_chars)", "index": 0, "passed_case": [], "case_status": ["fczkjjgzfxzteupdceij", "vctiywytpjqukbcabh", "mkgiamfeofnnvkbd", "tfoetlwvnuiyedxja", "ejfokqwnhnnixk", "wevwhtzjhqokwytjxmaa", "jdbmokeiuy", "iwrowqgkgjzttkz", "puonjgsreadfgwhbxpv", "oovqsktcxzf", "takawmflphqczzksahsf", "lwsvignahtascvmrcfnb", "jdjueezreatagg", "rthksvpitazyiyloxwnq", "qfjjemcutjujceywdj", "dmesjkxritg", "urjbrbpiffxpnppqzdx", "wfdozmbfjiitqgphkqje", "btfdwtceajhprriod", "ocokbbqlpyzb", "xyrgiliduztdzmddur", "shdsehevexjofujuvd", "epxuusmkixymjkogxwl", "maecqvufetiskgnej", "lhqtylvbwscxtlx", "gkffztgklvi", "ixwksrkdewpkdcm", "wkhzqtyptcfe", "tdnutgpgdlnb", "nixjxfnatp", "zgjhbbhpchzmbpbxzbj", "hbyfodrjiqnlbj", "cxiomkeaknwso", "tmcfkhukdfvpnzbmpvsf", "uikdypcsbtxzzzxi", "pexmvmxfzlslxpm", "yltgipxoxzhvulot", "llipbuvwmq", "qxisrbbzhxelsxwvm", "ajxljbigcdj", "vaeqpwuiyyorojgwy", "aafapjhbys", "dtjfqgbqxstvmaqvz", "ptqhzrqkajwkaasrwj", "qeyljkmmteggjo", "yieppmtqpdip", "auycauorcnlaoptz", "bvjrjkprcomxxbozhq", "vtcouuxcewpg", "hdkomiqmmaokapker", "ztdnjweawd", "jicvgjgrxf", "iqykanhvvzyfahlfucl", "xooyieuywjfyalxvbfb", "bdntpxneswmcprfpnwq", "phzswkvbtarq", "zukmjekqjaquvxom", "rmhrinbkmk", "yktcsiejzprtajyrwyr", "bceljoyjlxunrtsnp", "mnyqklkjfzimfztayh", "izrkzuasvlfil", "nhlcytgkddtly", "warfculrrqmh", "krfeoreuwx", "ggbulejfta", "vvbvjasoqqlupluv", "vzfaiwikxe", "jhtehcpqyvrl", "jlylyqexjk", "uxbipftjwgkgedhblvzu", "qfqylyokstrqev", "pzmvkcejxu", "caxkudaahrswqkhupwr", "rnpmmxfhmpy", "lxoatdqemkmfaoscx", "qpdisnvarwqadiktgl", "yrfcwvbjyhltctpej", "qfwgrylsykp", "rjqtgoivszgekabpm", "kclzluuxrgqtrnmtat", "qmiyjuojapdmzryb", "oxbwgrdgsumfqfsq", "zgpwgerbkm", "yowemxtomwyartdvejw", "ljzepfawyfqhylcdmbdl", "npgjspuxbhhhevo", "xjrugjqwkqkxcbqlxth", "qnulwpykqli", "rfjounulylcxokcu", "azdvzrlabjvbnjwivkxa", "xgwfwwdlbqdunzgelmzp", "igbtnsskhkrb", "zmbfqegajxzxob", "nebocktfqnxzxkuown", "xjrcvtmvjwe", "qylwpfgddlrffjtgoqnx", "puzzgpwfrvpkdyniqq", "nfxntwndokifq", "xiwwvcdbmjg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/54_prompt2cp", "code_candidates": [{"code": "def same_chars(s0: str, s1: str) -> bool:\n    \"\"\"\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    # Create dictionaries to count character frequencies\n    def char_count(s: str) -> dict:\n        count = {}\n        for char in s:\n            count[char] = count.get(char, 0) + 1\n        return count\n\n    # Get character counts for both strings\n    count_s0 = char_count(s0)\n    count_s1 = char_count(s1)\n\n    # Check if both dictionaries are equal\n    return count_s0 == count_s1", "index": 0, "passed_case": [3, 4, 5, 6], "case_status": ["False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/55_prompt2cp", "code_candidates": [{"code": "def fib(n: int) -> int:\n    \"\"\"\n    Return the nth Fibonacci number.\n\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/56_prompt2cp", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"<\" and \">\".\n\n    >>> correct_bracketing(\"<\")\n    True\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        elif bracket == \">\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/57_prompt2cp", "code_candidates": [{"code": "def monotonic(l: list) -> bool:\n    if not l:\n        return True\n\n    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))\n    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))\n\n    return increasing or decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/58_prompt2cp", "code_candidates": [{"code": "def common(l1: list, l2: list) -> list:\n    \"\"\"Return common elements between l1 and l2.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [653, 5, 1]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [3, 2]\n    \"\"\"\n    return list(set(l1) & set(l2))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/61_prompt2cp", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\" brackets is a string of \"(\" and \")\".\n\n    >>> correct_bracketing(\"(\")\n    True\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            balance += 1\n        elif bracket == \")\":\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/63_prompt2cp", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    if n == 0 or n == 1:\n        return 0\n    if n == 2:\n        return 1\n    \n    a, b, c = 0, 0, 1\n    for _ in range(3, n + 1):\n        a, b, c = b, c, a + b + c\n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/70_prompt2cp", "code_candidates": [{"code": "from typing import List\n\ndef strange_order(lst: List[int]) -> List[int]:\n    if not lst:\n        return []\n    reversed_lst = lst[::-1]\n    return sorted(reversed_lst)", "index": 0, "passed_case": [4, 5, 8], "case_status": ["[1, 2, 3, 4]", "[5, 6, 7, 8, 9]", "[1, 2, 3, 4, 5]", "[1, 5, 6, 7, 8, 9]", "[5, 5, 5, 5]", "[]", "[1, 2, 3, 4, 5, 6, 7, 8]", "[-5, -5, 0, 2, 2, 2, 5, 5]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/71_prompt2cp", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return None if the sides do not form a valid triangle\n        return None", "index": 0, "passed_case": [0, 2, 3, 5, 7], "case_status": ["6.0", "None", "8.18", "1.73", "None", "16.25", "None", "0.43", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/72_prompt2cp", "code_candidates": [{"code": "from typing import List\n\ndef will_it_fly(q: List[int], w: int) -> bool:\n    # Edge case: if q is empty, it should return True\n    if not q:\n        return True\n    \n    # Check if all elements in q are integers\n    if not all(isinstance(x, int) for x in q):\n        raise ValueError(\"All elements in q must be integers\")\n    \n    # Check if the sum of elements in q is less than or equal to w\n    if sum(q) > w:\n        return False\n    \n    # Calculate the balance\n    n = len(q)\n    first_half = q[:n//2]\n    second_half = q[n//2 + n%2:]\n    \n    sum_first_half = sum(first_half)\n    sum_second_half = sum(second_half)\n    \n    # Check if the absolute difference is less than or equal to 1\n    if abs(sum_first_half - sum_second_half) > 1:\n        return False\n    \n    return True", "index": 0, "passed_case": [0, 2, 3, 4, 5], "case_status": ["True", "True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/75_prompt2cp", "code_candidates": [{"code": "def is_multiply_prime(a: int) -> bool:\n    \"\"\"\n    Returns true if the given number is the multiplication of numbers and false otherwise.\n    Knowing that (a) is less than 100.\n    Example:\n    is_multiply_prime(30) == False\n    \"\"\"\n    if a >= 100:\n        return False\n\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    for i in range(2, a):\n        if a % i == 0:\n            quotient = a // i\n            if not is_prime(quotient):\n                return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7, 8], "case_status": ["False", "True", "True", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/77_prompt2cp", "code_candidates": [{"code": "def iscube(a: int) -> bool:\n    '''\n    Returns True if the integer a is a cube of some integer, and False otherwise.\n    '''\n    if a < 0:\n        a = -a\n        cube_root = round(a ** (1/3))\n        return cube_root ** 3 == a\n    else:\n        cube_root = round(a ** (1/3))\n        return cube_root ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/78_prompt2cp", "code_candidates": [{"code": "def count_prime_digits(hex_number: str) -> int:\n    prime_digits = {'2', '3', '5', '7'}\n    count = 0\n    for char in hex_number:\n        if char in prime_digits:\n            count += 1\n    return count", "index": 0, "passed_case": [1, 3, 6], "case_status": ["0", "2", "2", "2", "4", "8", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/80_prompt2cp", "code_candidates": [{"code": "def is_happy(s: str) -> bool:\n    # Handle edge cases\n    if not s or len(s) < 2:\n        return False\n    \n    # Iterate through the string to check for adjacent identical characters\n    for i in range(len(s) - 1):\n        if s[i] == s[i + 1]:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 7], "case_status": ["False", "True", "False", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/82_prompt2cp", "code_candidates": [{"code": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef prime_length(string):\n    length = len(string)\n    return is_prime(length)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/84_prompt2cp", "code_candidates": [{"code": "def solve(N: int) -> int:\n    \"\"\"Given a positive integer N, return the total sum of its digits.\n    \n    Example\n        For N = 1000, the sum of digits will be 1, the output should be 1.\n        For N = 150, the sum of digits will be 6, the output should be 6.\n    \"\"\"\n    return sum(int(digit) for digit in str(N))", "index": 0, "passed_case": [0], "case_status": ["1", "6", "12", "9", "18"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/85_prompt2cp", "code_candidates": [{"code": "def add(lst: list) -> int:\n    # Filter the list to include only even elements\n    even_elements = [x for x in lst if x % 2 == 0]\n    \n    # Sum the even elements\n    return sum(even_elements) if even_elements else 0", "index": 0, "passed_case": [], "case_status": ["92", "134", "10", "22"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/94_prompt2cp", "code_candidates": [{"code": "from collections import Counter\n\ndef skjkasdkd(lst):\n    if not lst:\n        raise ValueError(\"The list is empty\")\n    \n    count = Counter(lst)\n    max_freq = max(count.values())\n    most_frequent = [num for num, freq in count.items() if freq == max_freq]\n    \n    return min(most_frequent)", "index": 0, "passed_case": [], "case_status": ["3", "1", "1", "0", "0", "1", "8191", "7", "97"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/134_prompt2cp", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(s: str) -> bool:\n    if not s:\n        return False\n    last_char = s[-1]\n    return last_char.isalpha()", "index": 0, "passed_case": [1, 3, 4, 5, 6, 7, 9], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/141_prompt2cp", "code_candidates": [{"code": "def file_name_check(file_name: str) -> str:\n    \"\"\"\n    Check if the file name is valid.\n    A valid file name starts with a Latin alphabet letter and ends with a valid extension.\n    \n    :param file_name: The file name to check.\n    :return: 'Yes' if the file name is valid, 'No' otherwise.\n    \"\"\"\n    if not file_name:\n        return 'No'\n    \n    # Check if the file name starts with a Latin alphabet letter\n    if not file_name[0].isalpha():\n        return 'No'\n    \n    # Check if the file name ends with a valid extension\n    valid_extensions = ['.dll', '.exe', '.sys', '.drv', '.ocx', '.vxd']\n    if not any(file_name.endswith(ext) for ext in valid_extensions):\n        return 'No'\n    \n    return 'Yes'", "index": 0, "passed_case": [1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25], "case_status": ["No", "No", "No", "Yes", "Yes", "Yes", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "Yes", "No", "Yes", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/142_prompt2cp", "code_candidates": [{"code": "from typing import List\n\ndef sum_of_squares(numbers: List[int]) -> int:\n    \"\"\"\n    Sum the squares of all elements in the list.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of the squares of all elements in the list.\n    \"\"\"\n    return sum(x ** 2 for x in numbers)", "index": 0, "passed_case": [2, 3, 5], "case_status": ["14", "98", "0", "9", "9", "0", "56", "12942", "2", "10064", "2602"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/143_prompt2cp", "code_candidates": [{"code": "def words_in_sentence(sentence: str) -> str:\n    \"\"\"\n    Returns the last word in the given sentence.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"test\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"swimming\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Return the last word\n    return words[-1] if words else \"\"", "index": 0, "passed_case": [6], "case_status": ["test", "swimming", "here", "Hussein", "it", "here", "is"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/145_prompt2cp", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [1, 11, -1, -12, -11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(num):\n        return sum(int(digit) for digit in str(abs(num)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/146_prompt2cp", "code_candidates": [{"code": "def specialFilter(nums):\n    \"\"\"\n    Takes an array of numbers as input and returns the largest number\n    that is divisible by 3 or 0 if no such number exists.\n    \"\"\"\n    # Filter numbers divisible by 3\n    divisible_by_3 = [num for num in nums if num % 3 == 0]\n    \n    # Return the maximum number divisible by 3 or 0 if none exist\n    return max(divisible_by_3, default=0)", "index": 0, "passed_case": [0, 5, 6], "case_status": ["0", "15", "45", "93", "75", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/150_prompt2cp", "code_candidates": [{"code": "def x_or_y(n: int, x: int, y: int) -> int:\n    return x if n % 2 == 0 else y", "index": 0, "passed_case": [1, 5, 6, 8, 9], "case_status": ["12", "5", "5212", "52", "12", "583", "129", "34", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/151_prompt2cp", "code_candidates": [{"code": "from typing import List\n\ndef sum_of_squares(numbers: List[int]) -> int:\n    if not numbers:\n        return 0\n    return sum(num**2 for num in numbers if num > -3)", "index": 0, "passed_case": [0, 3], "case_status": ["0", "41", "0.14", "0", "69", "34.04", "166651"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/154_prompt2cp", "code_candidates": [{"code": "def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"\n    Check if string `b` can be found in any cyclic permutation of string `a`.\n    \n    Args:\n        a (str): The main string.\n        b (str): The pattern to search for in cyclic permutations of `a`.\n    \n    Returns:\n        bool: True if `b` is found in any cyclic permutation of `a`, False otherwise.\n    \"\"\"\n    if not a or not b:\n        return False\n    \n    # Concatenate `a` with itself to handle cyclic permutations\n    cyclic_a = a + a\n    \n    # Check if `b` is a substring of the cyclic version of `a`\n    return b in cyclic_a\n\n# Test cases\nprint(cycpattern_check(\"abcd\", \"abd\"))  # True\nprint(cycpattern_check(\"hello\", \"ell\"))  # False\nprint(cycpattern_check(\"whassup\", \"psus\"))  # True\nprint(cycpattern_check(\"abab\", \"baa\"))  # False\nprint(cycpattern_check(\"efef\", \"eeff\"))  # True\nprint(cycpattern_check(\"himenss\", \"simen\"))  # False", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["False", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/155_prompt2cp", "code_candidates": [{"code": "def even_odd_count(num: int) -> tuple:\n    \"\"\"\n    Counts the number of even and odd digits in a given integer.\n\n    Args:\n        num (int): The integer to analyze.\n\n    Returns:\n        tuple: A tuple containing the count of even digits and odd digits.\n    \"\"\"\n    # Handle negative numbers by taking the absolute value\n    num = abs(num)\n    \n    # Initialize counters for even and odd digits\n    even_count = 0\n    odd_count = 0\n    \n    # Iterate through each digit in the number\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 0\n        num //= 10\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [5], "case_status": ["(0, 0)", "(1, 0)", "(2, 0)", "(3, 0)", "(3, 0)", "(1, 0)", "(2, 0)", "(0, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/156_prompt2cp", "code_candidates": [{"code": "def int_to_mini_roman(number: int) -> str:\n    if not (1 <= number <= 1000):\n        raise ValueError(\"Number must be between 1 and 1000 inclusive.\")\n    \n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = \"\"\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/161_prompt2cp", "code_candidates": [{"code": "def solve(s: str) -> str:\n    \"\"\"\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"1234\"\n    solve(\"ab\") = \"ab\"\n    solve(\"#a@C\") = \"#a@C\"\n    \"\"\"\n    return s", "index": 0, "passed_case": [], "case_status": ["AsDf", "1234", "ab", "#a@C", "#AsdfW^45", "#6@2", "#$a^D", "#ccc"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/162_prompt2cp", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text: str) -> str:\n    \"\"\"\n    Converts a given string to its MD5 hash.\n\n    Args:\n        text (str): The input string to be hashed.\n\n    Returns:\n        str: The MD5 hash of the input string.\n\n    Example:\n        >>> string_to_md5('Hello world')\n        '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if text is None:\n        raise ValueError(\"Input text cannot be None\")\n    \n    # Encode the string to bytes and compute the MD5 hash\n    md5_hash = hashlib.md5(text.encode()).hexdigest()\n    return md5_hash", "index": 0, "passed_case": [0, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "d41d8cd98f00b204e9800998ecf8427e", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
