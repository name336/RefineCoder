{"name": "HumanEval/0", "code_candidates": [{"code": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/1", "code_candidates": [{"code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    # Remove all spaces\n    paren_string = paren_string.replace(' ', '')\n    \n    result = []\n    current_group = \"\"\n    balance = 0\n    \n    for char in paren_string:\n        current_group += char\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        \n        # When balance reaches 0, we have a complete group\n        if balance == 0:\n            result.append(current_group)\n            current_group = \"\"\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/2", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n    return number - int(number)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0.5", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/3", "code_candidates": [{"code": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/4", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if len(numbers) <= 1:\n        return 0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/5", "code_candidates": [{"code": "from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if len(numbers) <= 1:\n        return numbers[:]\n    \n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimeter)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[5, 8, 6, 8, 3, 8, 2]", "[2, 2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/6", "code_candidates": [{"code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        result.append(max_depth)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/7", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/8", "code_candidates": [{"code": "from typing import List, Tuple\nfrom functools import reduce\nimport operator\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    total_product = reduce(operator.mul, numbers, 1)\n    \n    return (total_sum, total_product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/9", "code_candidates": [{"code": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/10", "code_candidates": [{"code": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return string\n    \n    # Find the longest palindromic postfix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # Append the reverse of the prefix before the palindromic suffix\n            return string + string[:i][::-1]\n    \n    # If no palindromic postfix found (shouldn't happen), append reverse of entire string except last char\n    return string + string[:-1][::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "x", "xyzyx", "xyx", "jerryrrej"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/11", "code_candidates": [{"code": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/12", "code_candidates": [{"code": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n    \n    return max(strings, key=len)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/13", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return abs(a)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/14", "code_candidates": [{"code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [string[:i] for i in range(1, len(string) + 1)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/15", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "0 1 2 3", "0 1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/16", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/17", "code_candidates": [{"code": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    note_map = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    notes = music_string.split()\n    return [note_map[note] for note in notes]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[]", "[4, 4, 4, 4]", "[1, 1, 1, 1]", "[2, 2, 1, 1, 4, 4, 4, 4]", "[2, 1, 2, 1, 4, 2, 4, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/18", "code_candidates": [{"code": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if not substring or not string:\n        return 0\n    \n    count = 0\n    start = 0\n    \n    while True:\n        pos = string.find(substring, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/19", "code_candidates": [{"code": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    word_to_num = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    num_to_word = {v: k for k, v in word_to_num.items()}\n    \n    # Split the input string and convert to numbers\n    number_list = [word_to_num[word] for word in numbers.split()]\n    \n    # Sort the numbers\n    number_list.sort()\n    \n    # Convert back to words\n    sorted_words = [num_to_word[num] for num in number_list]\n    \n    # Join and return\n    return ' '.join(sorted_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "three", "three five nine", "zero four five seven eight nine", "zero one two three four five six"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/20", "code_candidates": [{"code": "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return closest_pair", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/21", "code_candidates": [{"code": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return numbers\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    range_val = max_val - min_val\n    return [(x - min_val) / range_val for x in numbers]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/22", "code_candidates": [{"code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int) and not isinstance(value, bool)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/23", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/24", "code_candidates": [{"code": "def largest_proper_divisor(n: int) -> int:\n    if n <= 1:\n        return None\n    \n    # For prime numbers, the largest proper divisor is 1\n    # For composite numbers, we find the largest divisor > 1\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    \n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/25", "code_candidates": [{"code": "def prime_factorization(n):\n    if n == 0:\n        raise ValueError('Prime factorization is undefined for 0')\n    if n == 1:\n        return []\n    \n    factors = []\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n    \n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/26", "code_candidates": [{"code": "from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    counts = {}\n    for num in numbers:\n        counts[num] = counts.get(num, 0) + 1\n    \n    result = []\n    for num in numbers:\n        if counts[num] == 1:\n            result.append(num)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[1, 2, 3, 4]", "[1, 4, 5]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/27", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    return string.swapcase()", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/28", "code_candidates": [{"code": "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ''.join(strings)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "xyz", "xyzwk"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/29", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/30", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [num for num in l if num > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/31", "code_candidates": [{"code": "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Check odd divisors up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/32", "code_candidates": [{"code": "import numpy as np\nfrom scipy.optimize import fsolve\n\ndef find_zero(xs):\n    \"\"\"\n    Finds one zero point of a polynomial defined by coefficients xs.\n    \n    Args:\n        xs: List of coefficients where xs[i] is the coefficient of x^i\n        \n    Returns:\n        A float representing one zero of the polynomial\n        \n    Raises:\n        ValueError: If the input list has an odd number of elements or \n                   if the leading coefficient is zero\n    \"\"\"\n    if len(xs) % 2 != 0:\n        raise ValueError(\"Polynomial must have an even number of coefficients\")\n    \n    if len(xs) == 0:\n        raise ValueError(\"Polynomial must have at least one coefficient\")\n        \n    leading_coefficient = xs[-1]\n    if leading_coefficient == 0:\n        raise ValueError(\"Leading coefficient must be non-zero\")\n    \n    # Create polynomial function\n    def poly(x):\n        result = 0\n        for i, coeff in enumerate(xs):\n            result += coeff * (x ** i)\n        return result\n    \n    # Use fsolve to find a root starting from x=0\n    root = fsolve(poly, 0)[0]\n    \n    return root", "index": 0, "passed_case": [], "case_status": ["Timeout", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/33", "code_candidates": [{"code": "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    # Create a copy of the original list\n    result = l.copy()\n    \n    # Extract values at indices divisible by 3\n    third_elements = [l[i] for i in range(0, len(l), 3)]\n    \n    # Sort these elements\n    third_elements.sort()\n    \n    # Put the sorted elements back at indices divisible by 3\n    third_index = 0\n    for i in range(0, len(result), 3):\n        result[i] = third_elements[third_index]\n        third_index += 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[2, 6, 3, 4, 8, 9, 5]", "[2, 8, 3, 4, 6, 9, 5]", "[2, 6, 9, 4, 8, 3, 5]", "[2, 6, 3, 4, 8, 9, 5, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/34", "code_candidates": [{"code": "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/35", "code_candidates": [{"code": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        return None\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/36", "code_candidates": [{"code": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "2", "3", "3", "6", "192", "639", "8026"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/37", "code_candidates": [{"code": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    # Extract values at even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even values\n    even_values.sort()\n    \n    # Create result list\n    result = l.copy()\n    \n    # Place sorted even values back at even indices\n    even_index = 0\n    for i in range(0, len(result), 2):\n        result[i] = even_values[even_index]\n        even_index += 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[1, 2, 3]", "[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]", "[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/38", "code_candidates": [{"code": "def decode_cyclic(s: str) -> str:\n    \"\"\"\n    Decodes a string that was encoded using encode_cyclic.\n    \n    Args:\n        s: The encoded string\n        \n    Returns:\n        The decoded string\n    \"\"\"\n    if len(s) < 3:\n        return s\n    \n    # Process groups of 3 characters\n    result = []\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        \n        # If group has less than 3 characters, keep as is\n        if len(group) < 3:\n            result.append(group)\n        else:\n            # Reverse the cyclic shift: move last char to front\n            decoded_group = group[2] + group[0] + group[1]\n            result.append(decoded_group)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/39", "code_candidates": [{"code": "def prime_fib(n: int):\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    a, b = 0, 1\n    count = 0\n    \n    while True:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "433494437"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/40", "code_candidates": [{"code": "def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n    if len(l) < 3:\n        return False\n    \n    # Sort the list to enable two-pointer technique\n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    \n    # Iterate through each element as the first element of potential triple\n    for i in range(n - 2):\n        # Use two pointers to find if there are two other elements that sum to -sorted_list[i]\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = sorted_list[i] + sorted_list[left] + sorted_list[right]\n            \n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/41", "code_candidates": [{"code": "def car_race_collision(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/42", "code_candidates": [{"code": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [x + 1 for x in l]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/43", "code_candidates": [{"code": "def pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/44", "code_candidates": [{"code": "def change_base(x: int, base: int) -> str:\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    if x == 0:\n        return '0'\n    \n    result = ''\n    while x > 0:\n        result = str(x % base) + result\n        x //= base\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/45", "code_candidates": [{"code": "def triangle_area(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n    return 0.5 * a * h", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/46", "code_candidates": [{"code": "def fib4(n: int):\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    \n    # Initialize the first four values\n    a, b, c, d = 0, 0, 2, 0\n    \n    # Iteratively compute fib4 values\n    for i in range(4, n + 1):\n        next_val = a + b + c + d\n        a, b, c, d = b, c, d, next_val\n    \n    return d", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["4", "28", "104", "386"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/47", "code_candidates": [{"code": "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if not l:\n        return None\n    \n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    \n    if n % 2 == 1:\n        return sorted_list[n // 2]\n    else:\n        mid1 = sorted_list[n // 2 - 1]\n        mid2 = sorted_list[n // 2]\n        return (mid1 + mid2) / 2.0", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "8.0", "5", "5.5", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/48", "code_candidates": [{"code": "def is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/49", "code_candidates": [{"code": "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return pow(2, n, p)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/50", "code_candidates": [{"code": "def decode_shift(s: str) -> str:\n    result = []\n    for char in s:\n        if char.isalpha():\n            # Convert to lowercase for shifting\n            lower_char = char.lower()\n            # Shift back by 5 positions\n            shifted = chr((ord(lower_char) - ord('a') - 5) % 26 + ord('a'))\n            # Convert back to uppercase if original was uppercase\n            if char.isupper():\n                result.append(shifted.upper())\n            else:\n                result.append(shifted)\n        else:\n            # Preserve non-alphabetic characters\n            result.append(char)\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/51", "code_candidates": [{"code": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/52", "code_candidates": [{"code": "def below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(x < t for x in l)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/53", "code_candidates": [{"code": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/54", "code_candidates": [{"code": "def same_chars(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return set(s0) == set(s1)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/55", "code_candidates": [{"code": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/56", "code_candidates": [{"code": "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == '<':\n            balance += 1\n        elif bracket == '>':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/57", "code_candidates": [{"code": "def monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if len(l) <= 1:\n        return True\n    \n    # Check if monotonically increasing\n    increasing = all(l[i] <= l[i+1] for i in range(len(l)-1))\n    \n    # Check if monotonically decreasing\n    decreasing = all(l[i] >= l[i+1] for i in range(len(l)-1))\n    \n    return increasing or decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/58", "code_candidates": [{"code": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/59", "code_candidates": [{"code": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    largest = 1\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            largest = divisor\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        largest = n\n    \n    return largest", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/60", "code_candidates": [{"code": "def sum_to_n(n: int):\n    \"\"\"sum_to_n is a function that sums numbers from 1 to n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/61", "code_candidates": [{"code": "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == '(':\n            balance += 1\n        elif bracket == ')':\n            balance -= 1\n            if balance < 0:\n                return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/62", "code_candidates": [{"code": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    if len(xs) <= 1:\n        return []\n    \n    return [i * xs[i] for i in range(1, len(xs))]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/63", "code_candidates": [{"code": "def fibfib(n: int):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Use dynamic programming with space optimization\n    a, b, c = 0, 0, 1  # fibfib(0), fibfib(1), fibfib(2)\n    \n    for i in range(3, n + 1):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/64", "code_candidates": [{"code": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    if not s:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/65", "code_candidates": [{"code": "def circular_shift(x: int, shift: int) -> str:\n    # Convert to string to work with digits\n    x_str = str(x)\n    num_digits = len(x_str)\n    \n    # Handle negative shift\n    if shift < 0:\n        return \"\"\n    \n    # If shift equals number of digits, return original\n    if shift == num_digits:\n        return x_str\n    \n    # If shift is greater than number of digits, return reversed\n    if shift > num_digits:\n        return x_str[::-1]\n    \n    # Perform circular right shift\n    # Split the string and rearrange\n    shift = shift % num_digits  # Handle cases where shift > num_digits but not reversed\n    return x_str[-shift:] + x_str[:-shift]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["001", "12", "79", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/66", "code_candidates": [{"code": "def digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"\n    total = 0\n    for char in s:\n        if char.isupper():\n            total += ord(char)\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "131", "67", "69", "131", "153", "151", "327"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/67", "code_candidates": [{"code": "import re\n\ndef fruit_distribution(s, n):\n    # Extract numbers from the string using regular expressions\n    numbers = re.findall(r'\\d+', s)\n    \n    # Convert extracted strings to integers\n    apples = int(numbers[0])\n    oranges = int(numbers[1])\n    \n    # Calculate mangoes by subtracting apples and oranges from total\n    mangoes = n - apples - oranges\n    \n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/68", "code_candidates": [{"code": "def pluck(arr):\n    if not arr:\n        return []\n    \n    smallest_even = None\n    smallest_even_index = -1\n    \n    for i, node in enumerate(arr):\n        if node % 2 == 0:  # Check if the node is even\n            if smallest_even is None or node < smallest_even:\n                smallest_even = node\n                smallest_even_index = i\n    \n    if smallest_even is None:\n        return []\n    \n    return [smallest_even, smallest_even_index]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2, 1]", "[2, 1]", "[]", "[0, 1]", "[0, 3]", "[4, 1]", "[6, 1]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/69", "code_candidates": [{"code": "def search(lst):\n    from collections import Counter\n    \n    # Count frequency of each number\n    freq = Counter(lst)\n    \n    # Find maximum valid number\n    result = -1\n    for num, count in freq.items():\n        if num > 0 and count >= num and num > result:\n            result = num\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "case_status": ["1", "4", "-1", "8", "2", "1", "2", "1", "-1", "1", "1", "5", "1", "4", "2", "1", "4", "4", "2", "-1", "-1", "2", "1", "1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/70", "code_candidates": [{"code": "def strange_sort_list(lst):\n    if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    take_min = True\n    \n    while sorted_lst:\n        if take_min:\n            result.append(sorted_lst.pop(0))\n        else:\n            result.append(sorted_lst.pop(-1))\n        take_min = not take_min\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/71", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n    # Check if all sides are positive\n    if a <= 0 or b <= 0 or c <= 0:\n        return -1\n    \n    # Check triangle inequality theorem\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return -1\n    \n    # Calculate area using Heron's formula\n    s = (a + b + c) / 2  # semi-perimeter\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return round(area, 2)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["6.0", "-1", "8.18", "1.73", "-1", "16.25", "-1", "0.43", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/72", "code_candidates": [{"code": "def will_it_fly(q, w):\n    # Check if the list is palindromic (balanced)\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of elements\n    total_weight = sum(q)\n    \n    # Return True if both conditions are met\n    return is_balanced and total_weight <= w", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/73", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n    \n    changes = 0\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/74", "code_candidates": [{"code": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 <= total_chars2:\n        return lst1\n    else:\n        return lst2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[]", "['hi', 'hi']", "['hi', 'admin']", "['4']", "['hI', 'Hi']", "['hI', 'hi', 'hi']", "['hi', 'admin']", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/75", "code_candidates": [{"code": "def is_multiply_prime(a):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    if a < 2:\n        return False\n    \n    prime_factors = []\n    temp = a\n    \n    # Find all prime factors\n    for i in range(2, int(a**0.5) + 1):\n        while temp % i == 0:\n            if is_prime(i):\n                prime_factors.append(i)\n            temp //= i\n    \n    # If temp > 1, then it's a prime factor\n    if temp > 1:\n        prime_factors.append(temp)\n    \n    # Check if there are exactly 3 prime factors and their product equals a\n    if len(prime_factors) == 3:\n        product = prime_factors[0] * prime_factors[1] * prime_factors[2]\n        return product == a\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["False", "True", "True", "False", "True", "True", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/76", "code_candidates": [{"code": "def is_simple_power(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"\n    if n == 0:\n        return x == 0\n    if n == 1:\n        return x == 1\n    if n == -1:\n        return x == 1 or x == -1\n    if x == 1:\n        return True\n    \n    if x < 0 and n > 0:\n        return False\n    \n    if x < 0 and n < 0:\n        # For negative base and negative number, check if it's a valid power\n        # This is complex, so we'll use a simpler approach\n        return False\n    \n    if x > 0 and n < 0:\n        # Check if x is a power of 1/n (which is n^(-1))\n        # This means we need to check if 1/x is a power of n\n        return False\n    \n    # For positive numbers\n    if x <= 0:\n        return False\n    \n    # Check if x is a power of n\n    current = 1\n    while current < x:\n        current *= n\n    return current == x", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/77", "code_candidates": [{"code": "def iscube(a):\n    if a == 0:\n        return True\n    \n    # Handle negative numbers\n    is_negative = a < 0\n    if is_negative:\n        a = -a\n    \n    # Find the cube root and check if it's an integer\n    cube_root = round(a ** (1/3))\n    \n    # Verify by cubing the rounded root\n    if cube_root ** 3 == a:\n        return True\n    \n    # Check nearby values in case of floating point precision issues\n    if (cube_root - 1) ** 3 == a or (cube_root + 1) ** 3 == a:\n        return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/78", "code_candidates": [{"code": "def hex_key(num):\n    # Define hexadecimal digits that represent prime numbers\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count prime hexadecimal digits in the input string\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/79", "code_candidates": [{"code": "def decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n    binary_string = bin(decimal)[2:]  # Convert to binary and remove '0b' prefix\n    return f\"db{binary_string}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/80", "code_candidates": [{"code": "def is_happy(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"\n    if len(s) < 3:\n        return False\n    \n    for i in range(len(s) - 2):\n        three_chars = s[i:i+3]\n        if len(set(three_chars)) != 3:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "False", "True", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/81", "code_candidates": [{"code": "def numerical_letter_grade(grades):\n    \"\"\"Convert a list of GPAs to letter grades.\"\"\"\n    letter_grades = []\n    \n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    \n    return letter_grades", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['A+', 'B', 'C-', 'C', 'A-']", "['D+']", "['D-']", "['E']", "['D', 'D-', 'C-', 'B', 'B+']", "['E', 'D-']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/82", "code_candidates": [{"code": "def prime_length(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n    length = len(string)\n    \n    if length < 2:\n        return False\n    \n    if length == 2:\n        return True\n    \n    if length % 2 == 0:\n        return False\n    \n    for i in range(3, int(length**0.5) + 1, 2):\n        if length % i == 0:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/83", "code_candidates": [{"code": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    if n == 1:\n        return 1\n    \n    # Numbers that start with 1: 10^(n-1)\n    start_with_1 = 10 ** (n - 1)\n    \n    # Numbers that end with 1: 9 * 10^(n-2) (first digit 1-9, middle digits 0-9)\n    end_with_1 = 9 * (10 ** (n - 2))\n    \n    # Numbers that both start and end with 1: 10^(n-2)\n    start_and_end_with_1 = 10 ** (n - 2)\n    \n    # Apply inclusion-exclusion principle\n    return start_with_1 + end_with_1 - start_and_end_with_1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "18", "180", "1800", "18000"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/84", "code_candidates": [{"code": "def solve(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 \u2264 N \u2264 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    # Calculate sum of digits\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert sum to binary and remove '0b' prefix\n    return bin(digit_sum)[2:]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "110", "1100", "1001", "10010"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/85", "code_candidates": [{"code": "def add(lst):\n    \"\"\"Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n    Examples:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start at index 1 (odd indices) and step by 2\n        if lst[i] % 2 == 0:  # Check if the element is even\n            total += lst[i]\n    return total", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["88", "122", "0", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/86", "code_candidates": [{"code": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'Hi'\n    anti_shuffle('hello') returns 'ehllo'\n    anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    \n    for word in words:\n        # Sort characters in the word by ASCII value\n        sorted_chars = sorted(word)\n        # Join the sorted characters back into a string\n        ordered_word = ''.join(sorted_chars)\n        ordered_words.append(ordered_word)\n    \n    # Join the ordered words back with spaces\n    return ' '.join(ordered_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello !!!Wdlor", "", ".Hi My aemn is Meirst .Rboot How aer ?ouy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/87", "code_candidates": [{"code": "def get_row(lst, x):\n    coordinates = []\n    \n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    \n    # Sort by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/88", "code_candidates": [{"code": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    if not array:\n        return []\n    \n    # Create a copy to avoid modifying the original array\n    result = array.copy()\n    \n    # Calculate sum of first and last elements\n    sum_first_last = array[0] + array[-1]\n    \n    # Sort in ascending order if sum is odd, descending if even\n    if sum_first_last % 2 == 1:\n        result.sort()  # ascending order\n    else:\n        result.sort(reverse=True)  # descending order\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/89", "code_candidates": [{"code": "def shift_letters(text: str) -> str:\n    result = []\n    \n    for char in text:\n        if char.isalpha():\n            if char.islower():\n                # Shift lowercase letters\n                shifted = chr((ord(char) - ord('a') + 4) % 26 + ord('a'))\n            else:\n                # Shift uppercase letters\n                shifted = chr((ord(char) - ord('A') + 4) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-alphabetic characters remain unchanged\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["lm", "ewhjklnop", "kj", "ix"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/90", "code_candidates": [{"code": "def next_smallest(lst):\n    if not lst:\n        return None\n    \n    # Remove duplicates and sort\n    unique_sorted = sorted(set(lst))\n    \n    # Check if we have at least 2 unique elements\n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "2", "None", "None", "1", "None", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/91", "code_candidates": [{"code": "def is_bored(S):\n    if not S:\n        return 0\n    \n    # Split the string into sentences using '.', '?', or '!' as delimiters\n    import re\n    sentences = re.split(r'[.?!]+', S)\n    \n    count = 0\n    for sentence in sentences:\n        # Strip whitespace and check if sentence is not empty\n        sentence = sentence.strip()\n        if sentence and sentence.startswith(\"I\"):\n            # Check if the sentence starts with \"I\" followed by a space or end of string\n            # This prevents matching \"I\" within other words like \"Important\"\n            if len(sentence) == 1 or sentence[1].isspace():\n                count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["0", "0", "1", "0", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/92", "code_candidates": [{"code": "def any_int(x, y, z):\n    # Check if all numbers are integers\n    if not all(isinstance(num, int) for num in [x, y, z]):\n        return False\n    \n    # Check if one number equals the sum of the other two\n    return (x == y + z) or (y == x + z) or (z == x + y)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["True", "False", "False", "False", "True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/93", "code_candidates": [{"code": "def encode(message):\n    vowels = 'aeiouAEIOU'\n    vowel_shift = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',\n                   'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'}\n    \n    result = []\n    for char in message:\n        if char.isalpha():\n            # Swap case\n            swapped = char.lower() if char.isupper() else char.upper()\n            # Replace vowels\n            if swapped in vowels:\n                encoded = vowel_shift[swapped]\n            else:\n                encoded = swapped\n            result.append(encoded)\n        else:\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["tgst", "mWDCSKR", "ygs", "tHKS KS C MGSSCGG", "k dQnT kNqW wHcT Tq wRkTg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/94", "code_candidates": [{"code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    def digit_sum(n):\n        return sum(int(digit) for digit in str(n))\n    \n    primes = [num for num in lst if is_prime(num)]\n    \n    if not primes:\n        return 0\n    \n    largest_prime = max(primes)\n    return digit_sum(largest_prime)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["10", "25", "13", "11", "3", "7", "19", "19", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/95", "code_candidates": [{"code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    if not all(isinstance(key, str) for key in dict.keys()):\n        return False\n    \n    keys = list(dict.keys())\n    return all(key.islower() for key in keys) or all(key.isupper() for key in keys)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "False", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/96", "code_candidates": [{"code": "def count_up_to(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n    if n <= 2:\n        return []\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    \n    return primes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/97", "code_candidates": [{"code": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    multiply(148, 412) should return 16.\n    multiply(19, 28) should return 72.\n    multiply(2020, 1851) should return 0.\n    multiply(14,-15) should return 20.\n    \"\"\"\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/98", "code_candidates": [{"code": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 1\n    count_upper('abcdefg') returns 0\n    count_upper('dBBE') returns 0\n    \"\"\"\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    for i in range(0, len(s), 2):  # iterate through even indices\n        if s[i] in uppercase_vowels:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/99", "code_candidates": [{"code": "def round_to_nearest_integer(number_str):\n    \"\"\"\n    Takes a string representing a number and returns the closest integer.\n    For equidistant cases (ending in .5), round away from zero.\n    Handles invalid inputs by raising a ValueError.\n    \n    Args:\n        number_str (str): String representation of a number\n        \n    Returns:\n        int: Closest integer to the given number\n        \n    Raises:\n        ValueError: If input is None, empty, or not a valid number\n    \"\"\"\n    if number_str is None:\n        raise ValueError(\"Input cannot be None\")\n    \n    if not isinstance(number_str, str):\n        raise ValueError(\"Input must be a string\")\n    \n    if number_str == \"\":\n        raise ValueError(\"Input cannot be empty\")\n    \n    try:\n        # Convert string to float\n        num = float(number_str)\n    except ValueError:\n        raise ValueError(\"Input is not a valid number\")\n    \n    # Handle special cases\n    if num != num:  # NaN check\n        raise ValueError(\"Input is not a valid number\")\n    \n    if num == float('inf') or num == float('-inf'):\n        raise ValueError(\"Input cannot be infinity\")\n    \n    # Round away from zero for equidistant cases\n    if num >= 0:\n        # For positive numbers, use math.floor for the integer part\n        # and check if the fractional part is >= 0.5\n        if num - int(num) >= 0.5:\n            return int(num) + 1\n        else:\n            return int(num)\n    else:\n        # For negative numbers, use math.ceil for the integer part\n        # and check if the fractional part is <= -0.5 (which means >= 0.5 in absolute value)\n        if num - int(num) <= -0.5:\n            return int(num) - 1\n        else:\n            return int(num)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["10", "15", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/100", "code_candidates": [{"code": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    result = []\n    current = n\n    \n    for _ in range(n):\n        result.append(current)\n        if n % 2 == 1:  # n is odd\n            current += 2  # next odd number\n        else:  # n is even\n            current += 2  # next even number\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/101", "code_candidates": [{"code": "def words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    import re\n    # Split by comma or space, filter out empty strings\n    words = re.split(r'[,\\s]+', s.strip())\n    return [word for word in words if word]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/102", "code_candidates": [{"code": "def choose_num(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"\n    if x > y:\n        return -1\n    \n    # Start from y and go backwards to find the largest even number\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    return -1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["14", "-1", "12354", "-1", "28", "-1", "-1", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/103", "code_candidates": [{"code": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    # Calculate the sum of integers from n to m\n    total = sum(range(n, m + 1))\n    # Calculate the count of integers\n    count = m - n + 1\n    # Calculate the average and round to nearest integer\n    avg = round(total / count)\n    # Convert to binary and return\n    return bin(avg)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["0b11", "0b1010", "0b1111001010", "0b1111100100", "0b1011000010", "0b101101110", "0b110101101", "0b1001110010", "0b11010111", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/104", "code_candidates": [{"code": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    def has_only_odd_digits(num):\n        return all(int(digit) % 2 == 1 for digit in str(num))\n    \n    result = [num for num in x if has_only_odd_digits(num)]\n    return sorted(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 15, 33]", "[]", "[111, 151]", "[31, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/105", "code_candidates": [{"code": "def by_length(arr):\n    # Map numbers to their word representations\n    num_to_word = {\n        1: \"One\",\n        2: \"Two\", \n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Filter numbers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array\n    filtered_arr.sort()\n    \n    # Reverse the sorted array\n    filtered_arr.reverse()\n    \n    # Replace each number with its word representation\n    result = [num_to_word[num] for num in filtered_arr]\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/106", "code_candidates": [{"code": "def f(n):\n    \"\"\" Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n    def factorial(x):\n        if x <= 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    def sum_to_x(x):\n        return x * (x + 1) // 2\n    \n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            result.append(factorial(i))\n        else:\n            result.append(sum_to_x(i))\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 2, 6, 24, 15]", "[1, 2, 6, 24, 15, 720, 28]", "[1]", "[1, 2, 6]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/107", "code_candidates": [{"code": "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        s = str(num)\n        return s == s[::-1]\n    \n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/108", "code_candidates": [{"code": "def count_nums(arr):\n    def sum_of_signed_digits(num):\n        if num == 0:\n            return 0\n        \n        # Convert to string to easily access digits\n        str_num = str(abs(num))\n        digits = [int(d) for d in str_num]\n        \n        # If the number is negative, make the first digit negative\n        if num < 0:\n            digits[0] = -digits[0]\n            \n        return sum(digits)\n    \n    count = 0\n    for num in arr:\n        if sum_of_signed_digits(num) > 0:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "0", "6", "5", "4", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/109", "code_candidates": [{"code": "def move_one_ball(arr):\n    if not arr:\n        return True\n    \n    # Create a sorted version of the array\n    sorted_arr = sorted(arr)\n    \n    # Try all possible right shifts\n    n = len(arr)\n    for i in range(n):\n        # Perform i right shifts\n        shifted = arr[-i:] + arr[:-i] if i > 0 else arr[:]\n        if shifted == sorted_arr:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/110", "code_candidates": [{"code": "def exchange(lst1, lst2):\n    # Count odd numbers in lst1\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # Count even numbers in lst2\n    even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If we have enough even numbers in lst2 to replace all odd numbers in lst1\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["YES", "NO", "YES", "YES", "NO", "NO", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/111", "code_candidates": [{"code": "def histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    if not test:\n        return {}\n    \n    # Count occurrences of each letter\n    counts = {}\n    for letter in test.split():\n        counts[letter] = counts.get(letter, 0) + 1\n    \n    # Find the maximum count\n    max_count = max(counts.values())\n    \n    # Return all letters with maximum count\n    return {letter: count for letter, count in counts.items() if count == max_count}", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/112", "code_candidates": [{"code": "def reverse_delete(s, c):\n    # Delete all characters in s that are equal to any character in c\n    result = ''.join(char for char in s if char not in c)\n    \n    # Check if the result string is palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/113", "code_candidates": [{"code": "def count_odd_digits(strings):\n    \"\"\"\n    Given a list of strings containing only digits, return a list where each element \n    is a formatted string that counts odd digits in the corresponding input string.\n    \n    Args:\n        strings: List[str] - list of strings containing only digits\n        \n    Returns:\n        List[str] - list of formatted strings with odd digit counts\n    \"\"\"\n    if not strings:\n        return []\n    \n    result = []\n    odd_digits = {'1', '3', '5', '7', '9'}\n    \n    for s in strings:\n        count = sum(1 for char in s if char in odd_digits)\n        template = 'the number of odd elements i in the string i of the input.'\n        formatted = template.replace('i', str(count))\n        result.append(formatted)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["['the number of odd elements 4 4n the str4ng 4 of the 4nput.']", "['the number of odd elements 1 1n the str1ng 1 of the 1nput.', 'the number of odd elements 8 8n the str8ng 8 of the 8nput.']", "['the number of odd elements 2 2n the str2ng 2 of the 2nput.', 'the number of odd elements 3 3n the str3ng 3 of the 3nput.', 'the number of odd elements 2 2n the str2ng 2 of the 2nput.']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/114", "code_candidates": [{"code": "def minSubArraySum(nums):\n    if not nums:\n        return 0\n    \n    min_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = min(nums[i], current_sum + nums[i])\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/115", "code_candidates": [{"code": "def max_fill(grid, capacity):\n    import math\n    \n    # Count total water units in the grid\n    total_water = sum(sum(row) for row in grid)\n    \n    # If no water, no need to lower buckets\n    if total_water == 0:\n        return 0\n    \n    # Calculate number of trips needed\n    return math.ceil(total_water / capacity)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["6", "5", "0", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/116", "code_candidates": [{"code": "def sort_by_binary_ones(arr):\n    if arr is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not arr:\n        return []\n    \n    def count_ones(n):\n        return bin(n).count('1')\n    \n    def sort_key(x):\n        # For negative numbers, we ignore the sign for counting ones\n        ones_count = count_ones(abs(x))\n        return (ones_count, x)\n    \n    return sorted(arr, key=sort_key)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[1, 2, 4, 3, 5]", "[-4, -2, -6, -5, -3]", "[0, 1, 2, 4, 3]", "[]", "[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "[32, 3, 5, 6, 12, 44]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/117", "code_candidates": [{"code": "def select_words(s, n):\n    if not s:\n        return []\n    \n    vowels = set('aeiouAEIOU')\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['little']", "['Mary', 'lamb']", "[]", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/118", "code_candidates": [{"code": "def find_closest_vowel_between_consonants(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n    \n    vowels = set('aeiouAEIOU')\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Search from right to left, excluding first and last characters\n    for i in range(len(word) - 2, 0, -1):\n        # Check if current character is a vowel\n        if word[i] in vowels:\n            # Check if it's between two consonants\n            if word[i-1] in consonants and word[i+1] in consonants:\n                return word[i]\n    \n    return \"\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["u", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/119", "code_candidates": [{"code": "def match_parens(lst):\n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    # Try both possible concatenations\n    s1 = lst[0] + lst[1]\n    s2 = lst[1] + lst[0]\n    \n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    else:\n        return 'No'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "Yes", "No", "No", "No", "Yes", "Yes"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/120", "code_candidates": [{"code": "def maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the maximum k numbers in arr.\n    \"\"\"\n    if k == 0:\n        return []\n    \n    # Sort the array in descending order and take the first k elements\n    sorted_arr = sorted(arr, reverse=True)\n    result = sorted_arr[:k]\n    \n    # Return the result sorted in ascending order\n    return sorted(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[4, 4]", "[2]", "[2, 20, 123]", "[0, 1, 2, 20]", "[-13, -8, 0, 0, 3, 5, 15]", "[3, 5]", "[5]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/121", "code_candidates": [{"code": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n    total = 0\n    for i in range(0, len(lst), 2):  # iterate through even indices\n        if lst[i] % 2 == 1:  # check if element is odd\n            total += lst[i]\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["9", "0", "5", "0", "23", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/122", "code_candidates": [{"code": "def add_elements(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n    total = 0\n    for i in range(min(k, len(arr))):\n        if 0 <= arr[i] <= 99:\n            total += arr[i]\n    return total", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["1", "0", "125", "24", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/123", "code_candidates": [{"code": "def get_odd_collatz(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    odd_numbers = set()\n    current = n\n    \n    while current != 1:\n        if current % 2 == 1:  # if current number is odd\n            odd_numbers.add(current)\n            current = 3 * current + 1\n        else:  # if current number is even\n            current = current // 2\n    \n    # Add 1 since the sequence always ends with 1\n    odd_numbers.add(1)\n    \n    # Return sorted list\n    return sorted(list(odd_numbers))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/124", "code_candidates": [{"code": "def valid_date(date):\n    # Check if date string is not empty\n    if not date:\n        return False\n    \n    # Check if format is correct (mm-dd-yyyy)\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date string\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    \n    month_str, day_str, year_str = parts\n    \n    # Check if all parts are numeric and have correct lengths\n    if not (month_str.isdigit() and day_str.isdigit() and year_str.isdigit()):\n        return False\n    \n    if len(month_str) != 2 or len(day_str) != 2 or len(year_str) != 4:\n        return False\n    \n    month = int(month_str)\n    day = int(day_str)\n    year = int(year_str)\n    \n    # Check if month is valid\n    if month < 1 or month > 12:\n        return False\n    \n    # Check if day is valid based on month\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        max_days = 31\n    elif month in [4, 6, 9, 11]:\n        max_days = 30\n    elif month == 2:\n        max_days = 29\n    \n    if day < 1 or day > max_days:\n        return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "False", "False", "True", "True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/125", "code_candidates": [{"code": "def split_words(txt):\n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower():\n                if (ord(char) - ord('a')) % 2 == 1:\n                    count += 1\n        return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["['Hello', 'world!']", "['Hello', 'world!']", "['Hello', 'world,!']", "['Hello,Hello,world', '!']", "3", "2", "1", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/126", "code_candidates": [{"code": "def is_sorted_and_bounded(nums):\n    \"\"\"\n    Check if a list of integers is sorted in ascending order \n    and no number appears more than twice.\n    \n    Args:\n        nums: List of integers (non-negative)\n        \n    Returns:\n        bool: True if sorted and no number appears more than twice, False otherwise\n    \"\"\"\n    if not nums:\n        return True\n    \n    # Check if sorted in ascending order\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            return False\n    \n    # Check if any number appears more than twice\n    count = 1\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            count += 1\n            if count > 2:\n                return False\n        else:\n            count = 1\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/127", "code_candidates": [{"code": "def intersection(interval1, interval2):\n    \"\"\"Determine whether the length of intersection of two intervals is a prime number.\"\"\"\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # Check if there's an intersection\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate the length of intersection (inclusive)\n    length = intersection_end - intersection_start + 1\n    \n    # Check if length is prime\n    if length < 2:\n        return \"NO\"\n    \n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    \n    return \"YES\"", "index": 0, "passed_case": [0, 2, 3, 4, 5, 7], "case_status": ["NO", "YES", "YES", "YES", "NO", "NO", "YES", "NO"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/128", "code_candidates": [{"code": "def prod_signs(arr):\n    if not arr:\n        return None\n    \n    magnitude_sum = sum(abs(x) for x in arr)\n    \n    sign_product = 1\n    for x in arr:\n        if x > 0:\n            sign_product *= 1\n        elif x < 0:\n            sign_product *= -1\n        else:  # x == 0\n            sign_product *= 0\n            break\n    \n    return magnitude_sum * sign_product", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["-9", "0", "-10", "None", "20", "4", "-4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/129", "code_candidates": [{"code": "def minPath(grid, k):\n    if not grid or not grid[0] or k <= 0:\n        return []\n    \n    n = len(grid)\n    if k == 1:\n        # Find the minimum value in the grid\n        min_val = float('inf')\n        for i in range(n):\n            for j in range(n):\n                min_val = min(min_val, grid[i][j])\n        return [min_val]\n    \n    # Directions for moving to neighbors (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Try starting from each cell\n    min_path = None\n    \n    def dfs(i, j, path, remaining):\n        nonlocal min_path\n        \n        if remaining == 0:\n            if min_path is None or path < min_path:\n                min_path = path[:]\n            return\n        \n        # Early termination if current path is already lexicographically larger\n        if min_path is not None and path > min_path[:len(path)]:\n            return\n            \n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < n and 0 <= nj < n:\n                path.append(grid[ni][nj])\n                dfs(ni, nj, path, remaining - 1)\n                path.pop()\n    \n    # Try all starting positions\n    for i in range(n):\n        for j in range(n):\n            dfs(i, j, [grid[i][j]], k - 1)\n    \n    return min_path", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[1, 2, 1]", "[1]", "[1, 2, 1, 2]", "[1, 10, 1, 10, 1, 10, 1]", "[1, 7, 1, 7, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]", "[1, 3, 1, 3, 1, 3, 1, 3]", "[1, 5, 1, 5, 1, 5, 1, 5]", "[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/130", "code_candidates": [{"code": "def tri(n: int) -> int:\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 8\n    \n    # Initialize the base cases\n    tri_prev3 = 1  # tri(0)\n    tri_prev2 = 3  # tri(1)\n    tri_prev1 = 2  # tri(2)\n    tri_current = 8  # tri(3)\n    \n    # Compute iteratively from 4 to n\n    for i in range(4, n + 1):\n        if i % 2 == 0:  # even\n            tri_current = tri_prev1 + tri_prev2 + tri_prev3\n        else:  # odd\n            tri_current = tri_prev1 + tri_prev2 + tri_prev3 + 1\n        \n        # Shift the window\n        tri_prev3 = tri_prev2\n        tri_prev2 = tri_prev1\n        tri_prev1 = tri_current\n    \n    return tri_current", "index": 0, "passed_case": [], "case_status": ["8", "6", "12", "20", "39", "71", "131", "106954", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/131", "code_candidates": [{"code": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    product = 1\n    has_odd = False\n    \n    for digit in str(n):\n        d = int(digit)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    \n    return product if has_odd else 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["5", "5", "5", "315", "2625", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/132", "code_candidates": [{"code": "def is_nested(string):\n    \"\"\"\n    Check if there is a valid subsequence of brackets where at least one bracket is nested.\n    \n    Args:\n        string: A string containing only square brackets\n        \n    Returns:\n        bool: True if there is a nested subsequence, False otherwise\n    \"\"\"\n    if not string or len(string) < 4:\n        return False\n    \n    # Count opening and closing brackets\n    open_count = 0\n    close_count = 0\n    \n    # Track if we have a valid nested structure\n    max_depth = 0\n    current_depth = 0\n    \n    # Track if we've seen a valid nested pattern\n    nested_found = False\n    \n    for char in string:\n        if char == '[':\n            open_count += 1\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ']':\n            close_count += 1\n            current_depth -= 1\n            \n            # Check if we have a valid nested structure\n            if current_depth < 0:\n                # Invalid sequence\n                return False\n            \n            # If we have a valid closing and depth > 1, we have nesting\n            if current_depth > 0 and max_depth > 1:\n                nested_found = True\n    \n    # Check if we have a valid sequence with nesting\n    return nested_found and open_count == close_count and max_depth > 1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13], "case_status": ["True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/133", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef sum_of_squares_of_ceiling(numbers: List[float]) -> int:\n    \"\"\"\n    Compute the sum of squares of the ceiling of each number in the list.\n    \n    Args:\n        numbers: A list of numbers\n        \n    Returns:\n        The sum of squares of the ceiling values\n    \"\"\"\n    return sum(math.ceil(num) ** 2 for num in numbers)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/134", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return False\n    \n    # Remove trailing whitespace\n    txt = txt.rstrip()\n    \n    if not txt:\n        return False\n    \n    # Get the last character\n    last_char = txt[-1]\n    \n    # Check if last character is alphabetical\n    if not last_char.isalpha():\n        return False\n    \n    # Check if it's not part of a word (i.e., preceded by a space or is the only character)\n    if len(txt) == 1:\n        return True\n    \n    # If the character before last is a space, then last char is standalone\n    return txt[-2] == ' '", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 8], "case_status": ["False", "True", "False", "True", "False", "False", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/135", "code_candidates": [{"code": "def can_arrange(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    if len(arr) <= 1:\n        return -1\n    \n    largest_index = -1\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            largest_index = i\n    \n    return largest_index", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "-1", "2", "4", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/136", "code_candidates": [{"code": "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n    \n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n    \n    return (largest_negative, smallest_positive)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/137", "code_candidates": [{"code": "def compare_one(a, b):\n    def convert_to_float(val):\n        if isinstance(val, (int, float)):\n            return float(val)\n        elif isinstance(val, str):\n            # Replace comma with dot for decimal separator\n            normalized = val.replace(',', '.')\n            return float(normalized)\n        else:\n            raise TypeError(\"Unsupported type\")\n    \n    def convert_back(val, original):\n        if isinstance(original, str):\n            return original\n        return val\n    \n    float_a = convert_to_float(a)\n    float_b = convert_to_float(b)\n    \n    if float_a > float_b:\n        return a\n    elif float_b > float_a:\n        return b\n    else:\n        return None", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["2", "2.5", "3", "6", "2,3", "6", "2", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/138", "code_candidates": [{"code": "def is_equal_to_sum_even(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"\n    # The smallest sum of 4 positive even numbers is 2+2+2+2 = 8\n    # Any number less than 8 cannot be expressed as sum of 4 positive even numbers\n    if n < 8:\n        return False\n    \n    # Any even number >= 8 can be expressed as sum of 4 positive even numbers\n    # For example: n = 2 + 2 + 2 + (n-6) where (n-6) is even and >= 2\n    return n % 2 == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/139", "code_candidates": [{"code": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n    \n    # Calculate factorial for each number from 1 to n\n    factorials = []\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        factorials.append(factorial)\n    \n    # Multiply all factorials together\n    result = 1\n    for f in factorials:\n        result *= f\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/140", "code_candidates": [{"code": "import re\n\ndef fix_spaces(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n    # First, replace 3 or more consecutive spaces with a single dash\n    text = re.sub(r' {3,}', '-', text)\n    # Then, replace remaining single spaces with underscores\n    text = text.replace(' ', '_')\n    return text", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["Example", "Mudasir_Hanif_", "Yellow_Yellow__Dirty__Fellow", "Exa-mple", "-Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/141", "code_candidates": [{"code": "def file_name_check(file_name):\n    # Check if there's exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split into name and extension\n    name_part, ext_part = file_name.split('.')\n    \n    # Check if name part is not empty and starts with a letter\n    if not name_part or not name_part[0].isalpha():\n        return 'No'\n    \n    # Check if extension is valid\n    valid_extensions = ['txt', 'exe', 'dll']\n    if ext_part not in valid_extensions:\n        return 'No'\n    \n    # Count digits in the entire file name\n    digit_count = sum(1 for char in file_name if char.isdigit())\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "No", "No", "No", "No", "Yes", "No", "No", "No", "No", "No", "Yes", "Yes", "Yes", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/142", "code_candidates": [{"code": "from typing import List\n\ndef process_list_by_index(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Process list elements by index:\n    - Square elements at indices that are multiples of 3\n    - Cube elements at indices that are multiples of 4 but NOT multiples of 3\n    - Leave others unchanged\n    - For indices that are multiples of both 3 and 4 (i.e., multiples of 12), \n      apply the operation for multiples of 4 (cubing)\n    \"\"\"\n    result = numbers.copy()\n    \n    for i in range(len(result)):\n        if i % 12 == 0:  # Multiple of both 3 and 4 (i.e., multiple of 12)\n            result[i] = result[i] ** 3  # Cube it\n        elif i % 4 == 0:  # Multiple of 4 but not 3\n            result[i] = result[i] ** 3  # Cube it\n        elif i % 3 == 0:  # Multiple of 3 but not 4\n            result[i] = result[i] ** 2  # Square it\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[1, 2, 3]", "[1, 4, 9]", "[]", "[1, 1, 1, 1, 1, 1, 1, 1, 1]", "[-1, -1, -1, 1, -1, -1, 1, -1, -1]", "[0]", "[-1, -5, 2, 1, -125]", "[-175616, -99, 1, 0, -8]", "[-1, 0, 0, 0, 0, 0, 0, 0, -1]", "[-4096, -9, -2, 1296, 46656, 26, 400, 25, -64000, 400, -4, 12, -17576, 35, 37]", "[-1, -3, 17, 1, -3375, 13, 1, 14, -2744, 144, -5, 14, -2744, 6, 13, 121, 4096, 16, 16, 10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/143", "code_candidates": [{"code": "def words_in_sentence(sentence):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return \" \".join(prime_length_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["is", "go for", "there is no place", "Hi am Hussein", "go for it", "", "is"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/144", "code_candidates": [{"code": "def simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n    # Parse the fractions\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    # Multiply the fractions: (x_num/x_den) * (n_num/n_den) = (x_num*n_num)/(x_den*n_den)\n    result_num = x_num * n_num\n    result_den = x_den * n_den\n    \n    # Check if the result is a whole number (denominator divides numerator evenly)\n    return result_num % result_den == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/145", "code_candidates": [{"code": "def order_by_points(nums):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Create list of tuples (digit_sum, original_index, value)\n    indexed_nums = [(digit_sum(num), i, num) for i, num in enumerate(nums)]\n    \n    # Sort by digit sum first, then by original index\n    indexed_nums.sort(key=lambda x: (x[0], x[1]))\n    \n    # Extract the sorted values\n    return [num for _, _, num in indexed_nums]", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/146", "code_candidates": [{"code": "def specialFilter(nums):\n    count = 0\n    odd_digits = {'1', '3', '5', '7', '9'}\n    \n    for num in nums:\n        if num > 10:\n            num_str = str(num)\n            if num_str[0] in odd_digits and num_str[-1] in odd_digits:\n                count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "1", "2", "4", "3", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/147", "code_candidates": [{"code": "def get_max_triples(n):\n    # Create the array a where a[i] = i * i - i + 1\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    # Count triples where sum is divisible by 3\n    count = 0\n    \n    # Check all combinations where i < j < k\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "4", "36", "53361"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/148", "code_candidates": [{"code": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["('Saturn', 'Uranus')", "('Venus',)", "('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')", "('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')", "()", "()", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/149", "code_candidates": [{"code": "def filter_and_sort_strings(strings):\n    \"\"\"\n    Filters out strings with odd lengths and returns remaining strings sorted by length\n    followed by alphabetical order for same-length strings.\n    \n    Args:\n        strings: List of strings\n        \n    Returns:\n        List of strings with even lengths, sorted by length and then alphabetically\n    \"\"\"\n    # Filter out strings with odd lengths (keep only even-length strings)\n    even_length_strings = [s for s in strings if len(s) % 2 == 0]\n    \n    # Sort by length first, then alphabetically\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['aa']", "['AI', 'asdf', 'school']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['cc', 'dd', 'aaaa', 'bbbb']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/150", "code_candidates": [{"code": "def x_or_y(n, x, y):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for x_or_y(7, 34, 12) == 34\n    for x_or_y(15, 8, 5) == 5\n    \n    \"\"\"\n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    return x if is_prime(n) else y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["34", "5", "33", "3", "-1", "583", "129", "1234", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/151", "code_candidates": [{"code": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    if not lst:\n        return 0\n    \n    total = 0\n    for num in lst:\n        if isinstance(num, int) and num >= 0 and num % 2 == 1:\n            total += num ** 2\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "25", "0", "0", "0", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/152", "code_candidates": [{"code": "def compare(game, guess):\n    \"\"\"Compare game scores with guesses and return absolute differences.\"\"\"\n    return [abs(score - guess_val) for score, guess_val in zip(game, guess)]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/153", "code_candidates": [{"code": "def Strongest_Extension(class_name, extensions):\n    def calculate_strength(extension):\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        return cap - sm\n    \n    strongest_ext = extensions[0]\n    strongest_strength = calculate_strength(extensions[0])\n    \n    for ext in extensions[1:]:\n        strength = calculate_strength(ext)\n        if strength > strongest_strength:\n            strongest_strength = strength\n            strongest_ext = ext\n    \n    return f\"{class_name}.{strongest_ext}\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["Watashi.eIGHt8OKe", "Boku123.YEs.WeCaNe", "__YESIMHERE.NuLl__", "K.TAR", "__HAHA.123", "YameRore.okIWILL123", "finNNalLLly.WoW", "_.Bb", "Sp.671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/154", "code_candidates": [{"code": "def cycpattern_check(a, b):\n    if not b:\n        return True\n    if not a:\n        return False\n    \n    # Generate all rotations of b\n    rotations = []\n    for i in range(len(b)):\n        rotations.append(b[i:] + b[:i])\n    \n    # Check if any rotation is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/155", "code_candidates": [{"code": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    # Convert to string and remove negative sign if present\n    num_str = str(abs(num))\n    \n    even_count = 0\n    odd_count = 0\n    \n    for digit_char in num_str:\n        digit = int(digit_char)\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(1, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/156", "code_candidates": [{"code": "def int_to_mini_roman(number):\n    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    syms = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    \n    roman = ''\n    for i in range(len(val)):\n        count = number // val[i]\n        if count:\n            roman += syms[i] * count\n            number -= val[i] * count\n    return roman", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/157", "code_candidates": [{"code": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # Sort the sides to identify the largest side (potential hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check if it's a valid triangle (triangle inequality)\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    \n    # Apply Pythagorean theorem: a\u00b2 + b\u00b2 = c\u00b2\n    # Using a small tolerance for floating point comparison\n    return abs(sides[0]**2 + sides[1]**2 - sides[2]**2) < 1e-10", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/158", "code_candidates": [{"code": "def find_max(words):\n    if not words:\n        return \"\"\n    \n    max_unique = -1\n    result = \"\"\n    \n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "enam", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/159", "code_candidates": [{"code": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    # Calculate how many carrots we can actually eat\n    actual_eaten = min(need, remaining)\n    \n    # Calculate total eaten after meals\n    total_eaten = number + actual_eaten\n    \n    # Calculate remaining carrots after meals\n    carrots_left = remaining - actual_eaten\n    \n    return [total_eaten, carrots_left]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["[11, 4]", "[12, 1]", "[11, 0]", "[7, 0]", "[9, 2]", "[5, 0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/160", "code_candidates": [{"code": "def do_algebra(operator, operand):\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n    # Start with the first operand\n    result = operand[0]\n    \n    # Apply each operator with the corresponding operand\n    for i, op in enumerate(operator):\n        if op == '+':\n            result += operand[i + 1]\n        elif op == '-':\n            result -= operand[i + 1]\n        elif op == '*':\n            result *= operand[i + 1]\n        elif op == '//':\n            result //= operand[i + 1]\n        elif op == '**':\n            result **= operand[i + 1]\n    \n    return result", "index": 0, "passed_case": [0, 2], "case_status": ["37", "15", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/161", "code_candidates": [{"code": "def solve(s):\n    # Check if string contains any letters\n    has_letters = any(c.isalpha() for c in s)\n    \n    if not has_letters:\n        # If no letters, reverse the string\n        return s[::-1]\n    else:\n        # If has letters, reverse case of each letter\n        result = []\n        for c in s:\n            if c.isalpha():\n                # Reverse case: lower to upper, upper to lower\n                if c.islower():\n                    result.append(c.upper())\n                else:\n                    result.append(c.lower())\n            else:\n                # Keep non-letters as they are\n                result.append(c)\n        return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["aSdF", "4321", "AB", "#A@c", "#aSDFw^45", "2@6#", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/162", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if text == \"\":\n        return None\n    return hashlib.md5(text.encode()).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/163", "code_candidates": [{"code": "def generate_integers(a, b):\n    \"\"\"\n    Given two positive integers a and b, return the even digits between a\n    and b, in ascending order.\n\n    For example:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n    # Ensure a is the smaller number and b is the larger number\n    start, end = min(a, b), max(a, b)\n    \n    # Find all even numbers in the range\n    result = []\n    for num in range(start, end + 1):\n        if num % 2 == 0:\n            result.append(num)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132]", "[18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt"}
{"name": "HumanEval/0_prompt1a", "code_candidates": [{"code": "def has_close_numbers(numbers: list, threshold: float) -> bool:\n    # Handle edge cases: empty list or single element\n    if len(numbers) <= 1:\n        return False\n    \n    # If threshold is zero, check for any equal numbers\n    if threshold == 0:\n        return len(numbers) != len(set(numbers))\n    \n    # Check all pairs of numbers\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/1_prompt1a", "code_candidates": [{"code": "def separate_parenthesized_groups(s: str) -> list:\n    \"\"\"\n    Separate parenthesized groups that are balanced and not nested within each other.\n    Spaces in input should be removed from output groups.\n    Return list of separated balanced parenthesized strings.\n    \n    Args:\n        s: Input string containing parenthesized groups\n        \n    Returns:\n        List of separated balanced parenthesized strings with spaces removed\n    \"\"\"\n    result = []\n    current_group = \"\"\n    balance = 0\n    \n    for char in s:\n        if char == ' ':\n            continue\n            \n        if char == '(':\n            if balance == 0:\n                current_group = \"\"\n            current_group += char\n            balance += 1\n        elif char == ')':\n            current_group += char\n            balance -= 1\n            if balance == 0:\n                result.append(current_group)\n        else:\n            current_group += char\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/2_prompt1a", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\"\n    Return the decimal part of a positive floating point number.\n    \n    Args:\n        number: A positive floating point number\n        \n    Returns:\n        The decimal part of the number (number - int(number))\n    \"\"\"\n    return number - int(number)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0.5", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/3_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/4_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/5_prompt1a", "code_candidates": [{"code": "from typing import List, Union\n\ndef insert_between(x: Union[int, float], lst: List[Union[int, float]]) -> List[Union[int, float]]:\n    if len(lst) <= 1:\n        return lst[:]\n    \n    result = []\n    for i, element in enumerate(lst):\n        result.append(element)\n        if i < len(lst) - 1:\n            result.append(x)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/6_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by certain characters.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        result.append(max_depth)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/7_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_substring(strings: List[str], x: str) -> List[str]:\n    \"\"\" Process an input list of strings given string x\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [s for s in strings if x in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/8_prompt1a", "code_candidates": [{"code": "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of a certain given subset of the integers in a list.\n    Empty sum or product should be equal to either 0 or 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    total_product = 1\n    for num in numbers:\n        total_product *= num\n    \n    return (total_sum, total_product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/9_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\"\n    Generate a list of rolling maximum values from a given list of integers.\n    \n    Args:\n        numbers: A list of integers\n        \n    Returns:\n        A list where each element is the maximum value seen so far in the sequence\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/10_prompt1a", "code_candidates": [{"code": "def candidate(string: str) -> str:\n    if not string:\n        return \"\"\n    \n    # Find the longest postfix that is a palindrome\n    for i in range(len(string)):\n        suffix = string[i:]\n        if suffix == suffix[::-1]:\n            # Append the reverse of the prefix before this palindromic suffix\n            prefix = string[:i]\n            return string + prefix[::-1]\n    \n    # If no palindromic postfix found (shouldn't happen), append reverse of entire string except last char\n    return string + string[:-1][::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "x", "xyzyx", "xyx", "jerryrrej"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/11_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform bitwise XOR operation on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/12_prompt1a", "code_candidates": [{"code": "def longest_string(strings: list[str]) -> str | None:\n    if not strings:\n        return None\n    \n    longest = strings[0]\n    for string in strings:\n        if len(string) > len(longest):\n            longest = string\n    \n    return longest", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/13_prompt1a", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b \"\"\"\n    a, b = abs(a), abs(b)\n    while b:\n        a, b = b, a % b\n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/14_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [string[:i] for i in range(1, len(string) + 1)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/15_prompt1a", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto a certain number inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "0 1 2 3", "0 1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/16_prompt1a", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"\n    return len(set(string.lower()))", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/17_prompt1a", "code_candidates": [{"code": "def parse_music(notation: str) -> list[int]:\n    \"\"\"\n    Parse ASCII music notation string and return beat durations.\n    \n    'o' = whole note (4 beats)\n    'o|' = half note (2 beats)  \n    '.|' = quarter note (1 beat)\n    \n    Args:\n        notation: String containing music notation\n        \n    Returns:\n        List of integers representing beat durations\n    \"\"\"\n    if not notation:\n        return []\n    \n    result = []\n    i = 0\n    \n    while i < len(notation):\n        if notation[i] == 'o':\n            if i + 1 < len(notation) and notation[i + 1] == '|':\n                result.append(2)  # half note\n                i += 2\n            else:\n                result.append(4)  # whole note\n                i += 1\n        elif notation[i] == '.':\n            if i + 1 < len(notation) and notation[i + 1] == '|':\n                result.append(1)  # quarter note\n                i += 2\n            else:\n                i += 1  # ignore invalid notation\n        else:\n            i += 1  # ignore invalid notation\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[]", "[4, 4, 4, 4]", "[1, 1, 1, 1]", "[2, 2, 1, 1, 4, 4, 4, 4]", "[2, 1, 2, 1, 4, 2, 4, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/18_prompt1a", "code_candidates": [{"code": "def how_many_times(a: str, b: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    if not b or not a:\n        return 0\n    \n    count = 0\n    start = 0\n    \n    while True:\n        pos = a.find(b, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/19_prompt1a", "code_candidates": [{"code": "def sort_number_words(words: list) -> list:\n    \"\"\"\n    Sort number words in ascending alphabetical order.\n    \n    Args:\n        words: A list of number words\n        \n    Returns:\n        A list of number words sorted in ascending alphabetical order\n    \"\"\"\n    number_words = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9,\n        'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13,\n        'fourteen': 14, 'fifteen': 15, 'sixteen': 16, 'seventeen': 17,\n        'eighteen': 18, 'nineteen': 19, 'twenty': 20\n    }\n    \n    return sorted(words, key=lambda word: number_words.get(word, float('inf')))", "index": 0, "passed_case": [], "case_status": ["[]", "['t', 'h', 'r', 'e', 'e']", "['t', 'h', 'r', 'e', 'e', ' ', 'f', 'i', 'v', 'e', ' ', 'n', 'i', 'n', 'e']", "['f', 'i', 'v', 'e', ' ', 'z', 'e', 'r', 'o', ' ', 'f', 'o', 'u', 'r', ' ', 's', 'e', 'v', 'e', 'n', ' ', 'n', 'i', 'n', 'e', ' ', 'e', 'i', 'g', 'h', 't']", "['s', 'i', 'x', ' ', 'f', 'i', 'v', 'e', ' ', 'f', 'o', 'u', 'r', ' ', 't', 'h', 'r', 'e', 'e', ' ', 't', 'w', 'o', ' ', 'o', 'n', 'e', ' ', 'z', 'e', 'r', 'o']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/20_prompt1a", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\"\n    From a supplied list of numbers (of length at least two) select and return \n    the two elements that are closest in value to each other, and return them \n    in order (smaller number, larger number).\n    \n    Args:\n        numbers: List of numbers with at least two elements\n        \n    Returns:\n        Tuple containing the two closest numbers in ascending order\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    min_diff = float('inf')\n    closest_pair = None\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                # Store in ascending order\n                if numbers[i] <= numbers[j]:\n                    closest_pair = (numbers[i], numbers[j])\n                else:\n                    closest_pair = (numbers[j], numbers[i])\n    \n    return closest_pair", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/21_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef linear_transform(numbers: List[float]) -> List[float]:\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"List must contain at least 2 elements\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/22_prompt1a", "code_candidates": [{"code": "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for certain types\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return [value for value in values if isinstance(value, int)]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/23_prompt1a", "code_candidates": [{"code": "def strlen(s: str) -> int:\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return len(s)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/24_prompt1a", "code_candidates": [{"code": "def largest_proper_divisor(n: int) -> int:\n    if n <= 1:\n        return 1\n    \n    # For prime numbers, return 1\n    # Check if n is prime by testing divisibility up to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # Found a divisor, so n is not prime\n            # The largest proper divisor is n // i\n            return n // i\n    \n    # If no divisor found, n is prime, return 1\n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/25_prompt1a", "code_candidates": [{"code": "def prime_factors(n: int) -> list[int]:\n    if n <= 1:\n        return []\n    \n    factors = []\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n    \n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/26_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef remove_k_occurrences(nums: List[int], k: int) -> List[int]:\n    # Count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Filter out numbers that occur exactly k times\n    result = []\n    for num in nums:\n        if count[num] != k:\n            result.append(num)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/27_prompt1a", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase or uppercase characters to either uppercase or lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    return string.swapcase()", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/28_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef concatenate_strings(strings: List[str]) -> str:\n    return ''.join(strings)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "xyz", "xyzwk"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/29_prompt1a", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that satisfy certain condition with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [s for s in strings if s.startswith(prefix)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/30_prompt1a", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list. Zero is considered positive.\n    \n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [num for num in l if num >= 0]", "index": 0, "passed_case": [0, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 0, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/31_prompt1a", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    # Check odd divisors up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/32_prompt1a", "code_candidates": [{"code": "import math\nfrom typing import List, Optional\n\nclass NoRealRootsError(Exception):\n    pass\n\ndef candidate(xs: List[float]) -> Optional[float]:\n    \"\"\"\n    Finds a zero point of a polynomial defined by coefficients xs.\n    \n    Args:\n        xs: List of coefficients [a0, a1, a2, ..., an] representing \n            polynomial a0 + a1*x + a2*x^2 + ... + an*x^n\n    \n    Returns:\n        A real zero point of the polynomial, or None for constant zero polynomial,\n        or raises NoRealRootsError if no real zeros exist\n    \n    Raises:\n        NoRealRootsError: If polynomial has no real zeros\n    \"\"\"\n    # Handle edge cases\n    if not xs:\n        raise NoRealRootsError(\"Empty coefficient list\")\n    \n    # Remove leading zeros\n    while len(xs) > 1 and xs[-1] == 0:\n        xs = xs[:-1]\n    \n    # Constant polynomial\n    if len(xs) == 1:\n        if xs[0] == 0:\n            return None  # Zero polynomial has all real numbers as roots\n        else:\n            raise NoRealRootsError(\"Constant non-zero polynomial has no roots\")\n    \n    # Linear polynomial (degree 1)\n    if len(xs) == 2:\n        # ax + b = 0 => x = -b/a\n        a, b = xs[1], xs[0]\n        if a == 0:\n            raise NoRealRootsError(\"Invalid linear polynomial\")\n        return -b / a\n    \n    # Higher degree polynomials - use Newton-Raphson method\n    def polynomial(x: float) -> float:\n        \"\"\"Evaluate polynomial at x\"\"\"\n        result = 0.0\n        for i, coeff in enumerate(xs):\n            result += coeff * (x ** i)\n        return result\n    \n    def derivative(x: float) -> float:\n        \"\"\"Evaluate derivative of polynomial at x\"\"\"\n        result = 0.0\n        for i in range(1, len(xs)):\n            result += i * xs[i] * (x ** (i - 1))\n        return result\n    \n    # Try different starting points\n    start_points = [0.0, 1.0, -1.0, 0.5, -0.5, 2.0, -2.0]\n    \n    for start in start_points:\n        x = start\n        # Newton-Raphson iteration\n        for _ in range(100):  # Maximum iterations\n            fx = polynomial(x)\n            if abs(fx) < 1e-12:  # Found root\n                return x\n            \n            dfx = derivative(x)\n            if abs(dfx) < 1e-15:  # Avoid division by zero\n                continue\n                \n            x_new = x - fx / dfx\n            if abs(x_new - x) < 1e-12:  # Converged\n                return x_new\n            x = x_new\n    \n    # If Newton-Raphson fails, try bisection method on a wider range\n    # Check if we can find an interval where the function changes sign\n    for a in range(-100, 101):\n        b = a + 1\n        fa = polynomial(float(a))\n        fb = polynomial(float(b))\n        \n        if fa * fb <= 0:  # Sign change detected\n            # Bisection method\n            for _ in range(100):\n                c = (a + b) / 2.0\n                fc = polynomial(c)\n                \n                if abs(fc) < 1e-12:\n                    return c\n                \n                if fa * fc <= 0:\n                    b = c\n                    fb = fc\n                else:\n                    a = c\n                    fa = fc\n            \n            return c\n    \n    raise NoRealRootsError(\"No real roots found\")", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/33_prompt1a", "code_candidates": [{"code": "def sort_indices_divisible_by_three(nums):\n    \"\"\"\n    Sort elements at indices divisible by three in ascending order,\n    while keeping other elements unchanged.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        List of integers with elements at indices divisible by three sorted\n    \"\"\"\n    if not nums:\n        return nums\n    \n    # Extract elements at indices divisible by three\n    divisible_by_three = []\n    for i in range(0, len(nums), 3):\n        divisible_by_three.append(nums[i])\n    \n    # Sort these elements\n    divisible_by_three.sort()\n    \n    # Create result list\n    result = nums.copy()\n    div_index = 0\n    \n    # Place sorted elements back at indices divisible by three\n    for i in range(0, len(result), 3):\n        result[i] = divisible_by_three[div_index]\n        div_index += 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[2, 6, 3, 4, 8, 9, 5]", "[2, 8, 3, 4, 6, 9, 5]", "[2, 6, 9, 4, 8, 3, 5]", "[2, 6, 3, 4, 8, 9, 5, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/34_prompt1a", "code_candidates": [{"code": "def unique(l: list):\n    \"\"\"Return unique elements from the list sorted in ascending order\"\"\"\n    return sorted(list(set(l)))", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/35_prompt1a", "code_candidates": [{"code": "def max_element(l: list):\n    \"\"\"Return a certain element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/36_prompt1a", "code_candidates": [{"code": "def count_sevens(n: int) -> int:\n    if n <= 0:\n        return 0\n    \n    count = 0\n    limit = n * n\n    \n    for i in range(1, limit):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    \n    return count", "index": 0, "passed_case": [], "case_status": ["113", "289", "295", "639", "2560", "1704904", "Timeout", "Timeout"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/37_prompt1a", "code_candidates": [{"code": "def sort_even_indices(lst):\n    \"\"\"\n    Sort values at even indices in ascending order while keeping odd indices unchanged.\n    \n    Args:\n        lst: List of integers\n        \n    Returns:\n        List with even index values sorted in ascending order\n    \"\"\"\n    if not lst:\n        return lst\n    \n    # Extract values at even indices\n    even_values = [lst[i] for i in range(0, len(lst), 2)]\n    \n    # Sort the even values\n    even_values.sort()\n    \n    # Create result list\n    result = lst.copy()\n    even_index = 0\n    \n    # Replace values at even indices with sorted values\n    for i in range(0, len(result), 2):\n        result[i] = even_values[even_index]\n        even_index += 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[1, 2, 3]", "[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]", "[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/38_prompt1a", "code_candidates": [{"code": "def candidate(s):\n    if s is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if s == \"\":\n        return \"\"\n    \n    # For cyclic encoding, we need to reverse the process\n    # The encode_cyclic function groups characters in sets of 3\n    # and rotates the characters in each group (e.g., \"abc\" -> \"bca\")\n    \n    result = []\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            # Reverse the cyclic rotation: \"bca\" -> \"abc\"\n            # This means we shift characters to the right by 1 position\n            # So \"bca\" becomes \"abc\" (b->a, c->b, a->c)\n            result.append(group[2] + group[0] + group[1])\n        else:\n            # Groups with less than 3 characters are not rotated\n            result.append(group)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/39_prompt1a", "code_candidates": [{"code": "def prime_fibonacci(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    a, b = 0, 1\n    count = 0\n    \n    while True:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "433494437"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/40_prompt1a", "code_candidates": [{"code": "def three_sum_zero(nums):\n    \"\"\"\n    Returns True if there exist three distinct elements in the list that sum to zero, False otherwise.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        bool: True if three distinct elements sum to zero, False otherwise\n    \"\"\"\n    if len(nums) < 3:\n        return False\n    \n    nums.sort()\n    n = len(nums)\n    \n    for i in range(n - 2):\n        # Skip duplicate values for the first element\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n            \n        # Use two pointers to find the other two elements\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/41_prompt1a", "code_candidates": [{"code": "def count_collisions(n: int) -> int:\n    \"\"\"\n    Calculate the number of collisions between cars moving in opposite directions.\n    \n    Args:\n        n: Number of cars moving left-to-right and right-to-left\n        \n    Returns:\n        Total number of collisions\n    \"\"\"\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/42_prompt1a", "code_candidates": [{"code": "def incr_list(l: list, increment: int = 1):\n    return [x + increment for x in l]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/43_prompt1a", "code_candidates": [{"code": "def pairs_sum_to_zero(l):\n    \"\"\"\n    candidate takes a list of integers as an input.\n    it returns True if there are elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n    if len(l) < 2:\n        return False\n    \n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/44_prompt1a", "code_candidates": [{"code": "def change_base(x: int, y: int) -> str:\n    \"\"\"Change numerical base of input number x to base y.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    if x == 0:\n        return '0'\n    \n    result = ''\n    while x > 0:\n        result = str(x % y) + result\n        x //= y\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/45_prompt1a", "code_candidates": [{"code": "def triangle_area(base, height):\n    \"\"\"Given length of a side (base) and height of a triangle, return the area. Area = 0.5 * base * height. >>> triangle_area(5, 3) 7.5\"\"\"\n    return 0.5 * base * height", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/46_prompt1a", "code_candidates": [{"code": "def fib4(n: int) -> int:\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        # Use iterative approach to avoid recursion overhead\n        a, b, c, d = 0, 0, 2, 0  # fib4(0), fib4(1), fib4(2), fib4(3)\n        for i in range(4, n + 1):\n            next_val = d - c + b - a\n            a, b, c, d = b, c, d, next_val\n        return d", "index": 0, "passed_case": [], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/47_prompt1a", "code_candidates": [{"code": "from typing import List, Union\n\ndef process_list(numbers: List[Union[int, float]]) -> Union[int, float, None]:\n    if not numbers:\n        return None\n    \n    if len(numbers) == 1:\n        return numbers[0]\n    \n    if len(numbers) % 2 == 1:\n        # Odd number of elements - return maximum\n        return max(numbers)\n    else:\n        # Even number of elements - return median\n        sorted_numbers = sorted(numbers)\n        n = len(sorted_numbers)\n        mid1 = sorted_numbers[n // 2 - 1]\n        mid2 = sorted_numbers[n // 2]\n        return (mid1 + mid2) / 2", "index": 0, "passed_case": [1, 2, 3], "case_status": ["5", "8.0", "5", "5.5", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/48_prompt1a", "code_candidates": [{"code": "def is_palindrome(text: str):\n    # Convert to lowercase and keep only alphabetic characters\n    cleaned = ''.join(char.lower() for char in text if char.isalpha())\n    \n    # Check if the cleaned string equals its reverse\n    return cleaned == cleaned[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/49_prompt1a", "code_candidates": [{"code": "def power_mod(x: int, y: int) -> int:\n    if y == 0:\n        raise ValueError(\"Modulus cannot be zero\")\n    \n    if y == 1:\n        return 0\n    \n    if x == 0:\n        return 1\n    \n    # For negative exponents, we need to compute modular inverse\n    if x < 0:\n        # Compute modular inverse of base\n        try:\n            # Using Python's built-in pow with three arguments for modular inverse\n            # pow(a, -1, m) computes a^-1 mod m\n            base_inv = pow(y, -1, y)\n            return pow(base_inv, -x, y)\n        except ValueError:\n            # If modular inverse doesn't exist, fall back to regular computation\n            return pow(y, x, y)\n    \n    # For positive exponents, use efficient modular exponentiation\n    return pow(y, x, y)", "index": 0, "passed_case": [2], "case_status": ["0", "0", "1", "0", "0", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/50_prompt1a", "code_candidates": [{"code": "def encode_shift_2(s: str) -> str:\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                # Handle lowercase letters\n                shifted = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                # Handle uppercase letters\n                shifted = chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Non-letter characters remain unchanged\n            result.append(char)\n    return ''.join(result)", "index": 0, "passed_case": [], "case_status": ["khepoolekceyjzuihjno", "ahyndbdyuovzpghfgm", "rplnfrkjtkssapgi", "yktjyqbaszndjicof", "joktpvbsmssncp", "bjabmyeomvtpbdyocrff", "oigrtpjnzd", "nbwtbvlploeyype", "uztsolxwjfiklbmgcua", "ttavxpyhcek", "yfpfbrkqumvheepxfmxk", "qbxanlsfmyfxharwhksg", "oiozjjewjfyfll", "wympxaunyfedndqtcbsv", "vkoojrhzyozohjdbio", "irjxopcwnyl", "zwogwgunkkcusuuveic", "bkitergkonnyvlumpvoj", "gykibyhjfomuwwnti", "thtpggvqudeg", "cdwlnqnizeyieriizw", "xmixjmjajcotkzozai", "juczzxrpncdroptlcbq", "rfjhvazkjynxplsjo", "qmvydqagbxhcyqc", "lpkkeylpqan", "ncbpxwpijbupihr", "bpmevyduyhkj", "yiszyluliqsg", "sncocksfyu", "elomggmuhmergugcego", "mgdktiwonvsqgo", "hcntrpjfpsbxt", "yrhkpmzpikausegruaxk", "znpiduhxgyceeecn", "ujcrarckeqxqcur", "dqylnuctcemazqty", "qqnugzabrv", "vcnxwggemcjqxcbar", "focqognlhio", "afjvubznddtwtolbd", "ffkfuomgdx", "iyokvlgvcxyarfvae", "uyvmewvpfobpffxwbo", "vjdqoprryjllot", "dnjuuryvuinu", "fzdhfztwhsqftuye", "gaowopuwhtrccgtemv", "ayhtzzchjbul", "miptrnvrrftpfupjw", "eyisobjfbi", "onhalolwck", "nvdpfsmaaedkfmqkzhq", "cttdnjzdbokdfqcagkg", "gisyucsjxbrhuwkusbv", "umexbpagyfwv", "ezprojpvofvzactr", "wrmwnsgprp", "dpyhxnjoeuwyfodwbdw", "ghjqotdoqczswyxsu", "rsdvpqpokenrkeyfdm", "newpezfxaqknq", "smqhdylpiiyqd", "bfwkhzqwwvrm", "pwkjtwjzbc", "llgzqjokyf", "aagaofxtvvqzuqza", "aekfnbnpcj", "omyjmhuvdawq", "oqdqdvjcop", "zcgnukyoblpljimgqaez", "vkvdqdtpxywvja", "ueraphjocz", "hfcpziffmwxbvpmzubw", "wsurrckmrud", "qctfyivjrprkftxhc", "vuinxsafwbvfinpylq", "dwkhbagodmqyhyujo", "vkblwdqxdpu", "wovyltnaxeljpfgur", "phqeqzzcwlvywsryfy", "vrndoztofuirewdg", "tcgblwilxzrkvkxv", "elubljwgpr", "dtbjrcytrbdfwyiajob", "qoejukfbdkvmdqhirgiq", "suloxuzcgmmmjat", "cowzlovbpvpchgvqcym", "vszqbudpvqn", "wkotzszqdqhctphz", "feiaewqfgoagsobnapcf", "clbkbbiqgvizseljqreu", "nlgysxxpmpwg", "ergkvjlfocectg", "sjgthpykvscecpztbs", "cowhayraobj", "vdqbukliiqwkkoyltvsc", "uzeelubkwaupidsnvv", "skcsybsitpnkv", "cnbbahigrol"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/51_prompt1a", "code_candidates": [{"code": "def remove_vowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in s if char not in vowels)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/52_prompt1a", "code_candidates": [{"code": "def all_below_threshold(lst, threshold):\n    \"\"\"\n    Determine if all elements in a list are strictly less than a given threshold value.\n    \n    Args:\n        lst: List of numbers\n        threshold: Number to compare against\n        \n    Returns:\n        bool: True if all elements are strictly less than threshold, False otherwise\n    \"\"\"\n    # Handle empty list case\n    if not lst:\n        return True\n    \n    # Check if all elements are below threshold\n    for element in lst:\n        if element >= threshold:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/53_prompt1a", "code_candidates": [{"code": "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y. The function performs addition operation on the two input integers and returns their sum.\"\"\"\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/54_prompt1a", "code_candidates": [{"code": "def are_anagrams(str1: str, str2: str) -> bool:\n    \"\"\"\n    Check if two strings are anagrams of each other.\n    \n    Args:\n        str1: First string to compare\n        str2: Second string to compare\n        \n    Returns:\n        True if the strings are anagrams, False otherwise\n    \"\"\"\n    # If lengths are different, they can't be anagrams\n    if len(str1) != len(str2):\n        return False\n    \n    # Count character frequencies in both strings\n    char_count = {}\n    \n    # Count characters in first string\n    for char in str1:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Subtract character counts based on second string\n    for char in str2:\n        if char not in char_count:\n            return False\n        char_count[char] -= 1\n        if char_count[char] == 0:\n            del char_count[char]\n    \n    # If all counts are zero, strings are anagrams\n    return len(char_count) == 0", "index": 0, "passed_case": [3, 4, 5, 6], "case_status": ["False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/55_prompt1a", "code_candidates": [{"code": "def fib(n: int):\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/56_prompt1a", "code_candidates": [{"code": "def is_balanced(brackets: str) -> bool:\n    \"\"\"\n    Return True if every opening bracket '<' has a matching closing bracket '>'\n    and the brackets are properly nested.\n    \n    Args:\n        brackets: A string containing brackets to check\n        \n    Returns:\n        True if brackets are balanced, False otherwise\n    \"\"\"\n    count = 0\n    for char in brackets:\n        if char == '<':\n            count += 1\n        elif char == '>':\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/57_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef is_monotonic(list: List[int]) -> bool:\n    if len(list) <= 1:\n        return True\n    \n    is_non_decreasing = True\n    is_non_increasing = True\n    \n    for i in range(1, len(list)):\n        if list[i] < list[i-1]:\n            is_non_decreasing = False\n        if list[i] > list[i-1]:\n            is_non_increasing = False\n        \n        # Early termination if neither condition holds\n        if not is_non_decreasing and not is_non_increasing:\n            return False\n    \n    return is_non_decreasing or is_non_increasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/58_prompt1a", "code_candidates": [{"code": "def find_common_elements(list1: list, list2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists in ascending order.\n    \n    Args:\n        list1: First list of elements\n        list2: Second list of elements\n    \n    Returns:\n        List of unique common elements sorted in ascending order\n    \"\"\"\n    if not list1 or not list2:\n        return []\n    \n    # Convert lists to sets to find intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find common elements and sort them\n    common_elements = sorted(set1.intersection(set2))\n    \n    return common_elements", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/59_prompt1a", "code_candidates": [{"code": "def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n.\"\"\"\n    largest = -1\n    \n    # Handle factor 2\n    while n % 2 == 0:\n        largest = 2\n        n //= 2\n    \n    # Handle odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest = factor\n            n //= factor\n        factor += 2\n    \n    # If n is still greater than 1, then it's a prime factor\n    if n > 1:\n        largest = n\n    \n    return largest", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/60_prompt1a", "code_candidates": [{"code": "def sum_to_n(n: int):\n    \"\"\"candidate is a function that sums up all numbers.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/61_prompt1a", "code_candidates": [{"code": "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every closing or opening bracket has a corresponding closing or opening bracket.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n    balance = 0\n    for bracket in brackets:\n        if bracket == '(':\n            balance += 1\n        elif bracket == ')':\n            balance -= 1\n            if balance < 0:\n                return False\n    return balance == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/62_prompt1a", "code_candidates": [{"code": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return first or second derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    if len(xs) <= 1:\n        return []\n    \n    return [i * xs[i] for i in range(1, len(xs))]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/63_prompt1a", "code_candidates": [{"code": "def fibfib(n: int):\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Use dynamic programming with space optimization\n    a, b, c = 0, 0, 1  # fibfib(0), fibfib(1), fibfib(2)\n    \n    for i in range(3, n + 1):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/64_prompt1a", "code_candidates": [{"code": "def vowels_count(s):\n    \"\"\"Write a function candidate which takes a string representing\n    a word as input and returns the number of characters or vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n    if not s:\n        return 0\n    \n    vowels = set('aeiou')\n    count = 0\n    s = s.lower()\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/65_prompt1a", "code_candidates": [{"code": "def circular_shift(x: int, shift: int) -> str:\n    # Handle edge case of zero shift\n    if shift == 0:\n        return str(x)\n    \n    # Convert to string to work with digits\n    x_str = str(x)\n    \n    # Handle negative numbers - separate the negative sign\n    is_negative = x_str.startswith('-')\n    if is_negative:\n        digits = x_str[1:]\n    else:\n        digits = x_str\n    \n    # Get number of digits\n    num_digits = len(digits)\n    \n    # Handle case where shift is greater than number of digits\n    if shift > num_digits:\n        # Return reversed digits\n        result = digits[::-1]\n        if is_negative:\n            return '-' + result\n        return result\n    \n    # Normalize shift for circular operations\n    shift = shift % num_digits\n    \n    # Perform circular left shift (or right shift if negative)\n    if shift > 0:\n        # Circular left shift\n        shifted = digits[shift:] + digits[:shift]\n    else:\n        # Circular right shift (negative shift)\n        shift = abs(shift)\n        shifted = digits[-shift:] + digits[:-shift]\n    \n    # Return result with negative sign if needed\n    if is_negative:\n        return '-' + shifted\n    return shifted", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["010", "12", "79", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/66_prompt1a", "code_candidates": [{"code": "def sum_uppercase_ascii(s: str) -> int:\n    \"\"\"\n    Returns the sum of ASCII values of all uppercase letters in the string.\n    If there are no uppercase letters, returns 0.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        Sum of ASCII values of uppercase letters\n    \"\"\"\n    return sum(ord(char) for char in s if char.isupper())", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "131", "67", "69", "131", "153", "151", "327"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/67_prompt1a", "code_candidates": [{"code": "import re\n\ndef fruit_distribution(s, n):\n    # Extract numbers from the string using regular expressions\n    numbers = re.findall(r'\\d+', s)\n    \n    # Convert the first two numbers to integers (apples and oranges)\n    apples = int(numbers[0])\n    oranges = int(numbers[1])\n    \n    # Calculate mangoes by subtracting apples and oranges from total\n    mangoes = n - apples - oranges\n    \n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/68_prompt1a", "code_candidates": [{"code": "def find_min_with_index(arr):\n    \"\"\"\n    Find the minimum value and its first index in an array of non-negative integers.\n    \n    Args:\n        arr: List of non-negative integers\n        \n    Returns:\n        List containing [minimum_value, first_index] or empty list if array is empty\n    \"\"\"\n    if not arr:\n        return []\n    \n    min_value = min(arr)\n    min_index = arr.index(min_value)\n    \n    return [min_value, min_index]", "index": 0, "passed_case": [0, 2, 3, 4, 5], "case_status": ["[2, 1]", "[1, 0]", "[]", "[0, 1]", "[0, 3]", "[4, 1]", "[1, 3]", "[1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/69_prompt1a", "code_candidates": [{"code": "def search(lst):\n    from collections import Counter\n    \n    # Count frequency of each number\n    freq = Counter(lst)\n    \n    # Find candidates where frequency equals the number itself\n    candidates = []\n    for num, count in freq.items():\n        if num > 0 and count == num:\n            candidates.append(num)\n    \n    # Return the smallest if any candidates exist, otherwise -1\n    return min(candidates) if candidates else -1", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7, 8, 12, 13, 16, 19, 20, 24], "case_status": ["1", "4", "-1", "8", "-1", "-1", "2", "1", "-1", "-1", "-1", "3", "1", "4", "1", "-1", "4", "1", "1", "-1", "-1", "-1", "-1", "-1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/70_prompt1a", "code_candidates": [{"code": "def strange_sort_list(lst):\n    if not lst:\n        return []\n    \n    result = []\n    sorted_lst = sorted(lst)\n    take_min = True\n    \n    while sorted_lst:\n        if take_min:\n            result.append(sorted_lst.pop(0))\n        else:\n            result.append(sorted_lst.pop(-1))\n        take_min = not take_min\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/71_prompt1a", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef triangle_area(a: float, b: float, c: float) -> float:\n    # Check if all sides are positive\n    if a <= 0 or b <= 0 or c <= 0:\n        return -1\n    \n    # Check triangle inequality\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return -1\n    \n    # Calculate area using Heron's formula\n    s = (a + b + c) / 2  # semi-perimeter\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return round(area, 2)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["6.0", "-1", "8.18", "1.73", "-1", "16.25", "-1", "0.43", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/72_prompt1a", "code_candidates": [{"code": "def is_palindromic_under_weight(q, w):\n    \"\"\"\n    Returns True if list q is palindromic AND sum of elements is less than or equal to weight w.\n    Otherwise returns False.\n    \n    Args:\n        q: List of numbers\n        w: Weight limit (number)\n    \n    Returns:\n        bool: True if palindromic and sum <= weight, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if q is None:\n        return False\n    \n    # Empty list is considered palindromic\n    if len(q) == 0:\n        return True\n    \n    # Check if palindromic\n    is_palindrome = q == q[::-1]\n    \n    # Calculate sum\n    total_sum = sum(q)\n    \n    # Return True if both conditions are met\n    return is_palindrome and total_sum <= w", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/73_prompt1a", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    if not arr:\n        return 0\n    \n    changes = 0\n    n = len(arr)\n    \n    # Compare elements from both ends moving towards center\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n    \n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/74_prompt1a", "code_candidates": [{"code": "def total_match(lst1, lst2):\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    if total_chars1 >= total_chars2:\n        return lst1\n    else:\n        return lst2", "index": 0, "passed_case": [0, 6], "case_status": ["[]", "['hi', 'admin']", "['hi', 'hi', 'admin', 'project']", "['1', '2', '3', '4', '5']", "['hi', 'admin']", "['hi', 'admin']", "['hi', 'admin']", "['this']", "['this']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/75_prompt1a", "code_candidates": [{"code": "def is_product_of_exactly_3_distinct_primes(n: int) -> bool:\n    if n < 2:\n        return False\n    \n    prime_factors = []\n    d = 2\n    \n    while d * d <= n:\n        while n % d == 0:\n            prime_factors.append(d)\n            n //= d\n        d += 1\n    \n    if n > 1:\n        prime_factors.append(n)\n    \n    # Check if we have exactly 3 distinct prime factors, each appearing exactly once\n    if len(prime_factors) != 3:\n        return False\n    \n    # Check if all prime factors are distinct\n    return len(set(prime_factors)) == 3", "index": 0, "passed_case": [0, 1, 3, 5, 6, 7, 8, 9], "case_status": ["False", "True", "False", "False", "False", "True", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/76_prompt1a", "code_candidates": [{"code": "def is_simple_power(a, b):\n    \"\"\"Returns true if a number x is a power of n and false in other cases.\n    x is a simple power of n if n**k=x\"\"\"\n    if b == 1:\n        return a == 1\n    if b == 0:\n        return a == 1\n    if a == 1:\n        return True\n    \n    current = 1\n    while current < a:\n        current *= b\n        if current == a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/77_prompt1a", "code_candidates": [{"code": "def iscube(a):\n    if a == 0:\n        return True\n    \n    # Handle positive numbers\n    if a > 0:\n        cube_root = round(a ** (1/3))\n        return cube_root ** 3 == a\n    \n    # Handle negative numbers\n    else:\n        cube_root = round((-a) ** (1/3))\n        return (-cube_root) ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/78_prompt1a", "code_candidates": [{"code": "def count_prime_hex_digits(hex_string: str) -> int:\n    \"\"\"\n    Count the number of prime-valued hexadecimal digits in a hexadecimal string.\n    \n    Prime hexadecimal digits are: 2, 3, 5, 7, B (11), D (13)\n    \n    Args:\n        hex_string: A string containing valid hexadecimal characters (0-9, A-F, a-f)\n        \n    Returns:\n        The count of prime-valued hexadecimal digits in the string\n    \"\"\"\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D', 'b', 'd'}\n    \n    count = 0\n    for char in hex_string:\n        if char in prime_hex_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/79_prompt1a", "code_candidates": [{"code": "def decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1' or '2'.\n\n    There will be an extra couple of characters 'db' at different positions (start, or middle, or end) of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db1111db\"\n    decimal_to_binary(32)   # returns \"db100000db\"\n    \"\"\"\n    binary_str = bin(decimal)[2:]  # Convert to binary and remove '0b' prefix\n    return f\"db{binary_str}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/80_prompt1a", "code_candidates": [{"code": "def is_happy(s):\n    # Check if string has at least 3 characters\n    if len(s) < 3:\n        return False\n    \n    # Get all substrings of length 3\n    substrings = []\n    for i in range(len(s) - 2):\n        substrings.append(s[i:i+3])\n    \n    # Check if all substrings are distinct\n    return len(substrings) == len(set(substrings))", "index": 0, "passed_case": [0, 1, 2, 4, 6], "case_status": ["False", "False", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/81_prompt1a", "code_candidates": [{"code": "def gpa_to_letter_grades(gpa_list):\n    \"\"\"\n    Convert a list of numerical GPAs to letter grades.\n    \n    Args:\n        gpa_list: List of numerical GPAs (float or int)\n        \n    Returns:\n        List of letter grades (str)\n        \n    Raises:\n        ValueError: If any GPA is outside the valid range [0.0, 4.0]\n    \"\"\"\n    if not isinstance(gpa_list, list):\n        raise TypeError(\"Input must be a list\")\n    \n    letter_grades = []\n    \n    for gpa in gpa_list:\n        # Check if GPA is within valid range\n        if not isinstance(gpa, (int, float)) or gpa < 0.0 or gpa > 4.0:\n            raise ValueError(f\"GPA {gpa} is outside the valid range [0.0, 4.0]\")\n        \n        # Convert GPA to letter grade\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif 3.7 <= gpa <= 3.9:\n            letter_grades.append('A')\n        elif 3.3 <= gpa <= 3.6:\n            letter_grades.append('A-')\n        elif 3.0 <= gpa <= 3.2:\n            letter_grades.append('B+')\n        elif 2.7 <= gpa <= 2.9:\n            letter_grades.append('B')\n        elif 2.3 <= gpa <= 2.6:\n            letter_grades.append('B-')\n        elif 2.0 <= gpa <= 2.2:\n            letter_grades.append('C+')\n        elif 1.7 <= gpa <= 1.9:\n            letter_grades.append('C')\n        elif 1.3 <= gpa <= 1.6:\n            letter_grades.append('C-')\n        elif 1.0 <= gpa <= 1.2:\n            letter_grades.append('D+')\n        elif 0.7 <= gpa <= 0.9:\n            letter_grades.append('D')\n        elif 0.0 <= gpa <= 0.6:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    \n    return letter_grades", "index": 0, "passed_case": [1, 2], "case_status": ["['A+', 'B+', 'C', 'C+', 'A-']", "['D+']", "['D-']", "['D-']", "['D+', 'D-', 'C-', 'B', 'A-']", "['D-', 'D']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/82_prompt1a", "code_candidates": [{"code": "def is_prime_length(s: str) -> bool:\n    \"\"\"\n    Returns True if string length is a prime number, False otherwise.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        bool: True if length is prime, False otherwise\n        \n    Raises:\n        TypeError: If input is None\n    \"\"\"\n    if s is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    length = len(s)\n    \n    # 0 and 1 are not prime numbers\n    if length < 2:\n        return False\n    \n    # Check for divisors from 2 to sqrt(length)\n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/83_prompt1a", "code_candidates": [{"code": "def count_start_or_end_with_1(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        s = str(i)\n        if s[0] == '1' or s[-1] == '1':\n            count += 1\n    return count", "index": 0, "passed_case": [0], "case_status": ["1", "1", "1", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/84_prompt1a", "code_candidates": [{"code": "def sum_digits_binary(N: int) -> str:\n    digit_sum = sum(int(digit) for digit in str(N))\n    return bin(digit_sum)[2:]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "110", "1100", "1001", "10010"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/85_prompt1a", "code_candidates": [{"code": "def sum_even_at_multiples_of_three(lst: list) -> int:\n    \"\"\"\n    Given a non-empty list of integers, add the even elements that are at indices \n    that are multiples of 3 (0, 3, 6, 9, ...).\n    \n    Args:\n        lst: A non-empty list of integers\n        \n    Returns:\n        The sum of even elements at indices that are multiples of 3\n    \"\"\"\n    total = 0\n    for i in range(0, len(lst), 3):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total", "index": 0, "passed_case": [3], "case_status": ["4", "4", "4", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/86_prompt1a", "code_candidates": [{"code": "def sort_characters_in_words(text):\n    \"\"\"\n    Sort characters within each word in ascending order while preserving word order and spacing.\n    \n    Args:\n        text (str): Input string to process\n        \n    Returns:\n        str: String with characters in each word sorted alphabetically\n    \"\"\"\n    if not text:\n        return text\n    \n    result = []\n    current_word = []\n    \n    for char in text:\n        if char.isalnum():\n            current_word.append(char)\n        else:\n            # Process the current word if it exists\n            if current_word:\n                # Sort characters in the word\n                sorted_word = ''.join(sorted(current_word))\n                result.append(sorted_word)\n                current_word = []\n            # Add the non-alphanumeric character\n            result.append(char)\n    \n    # Handle the last word if text doesn't end with non-alphanumeric char\n    if current_word:\n        sorted_word = ''.join(sorted(current_word))\n        result.append(sorted_word)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 5], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello Wdlor!!!", "", "Hi. My aemn is Meirst Rboot. How aer ouy?"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/87_prompt1a", "code_candidates": [{"code": "def get_row(lst, x):\n    coordinates = []\n    \n    for row_idx, row in enumerate(lst):\n        if row is None:\n            continue\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row first, then by column\n    coordinates.sort(key=lambda coord: (coord[0], coord[1]))\n    \n    return coordinates", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/88_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef sort_array_based_on_sum(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort the array in ascending order if the sum of first and last elements is odd,\n    otherwise sort in descending order. Return a copy of the original array without\n    modifying it.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        A new sorted list based on the sum condition\n    \"\"\"\n    if not arr:\n        return []\n    \n    # Create a copy to avoid modifying the original array\n    result = arr.copy()\n    \n    # Calculate sum of first and last elements\n    sum_first_last = arr[0] + arr[-1]\n    \n    # Sort based on whether the sum is odd or even\n    if sum_first_last % 2 == 1:  # odd\n        result.sort()  # ascending order\n    else:  # even\n        result.sort(reverse=True)  # descending order\n        \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/89_prompt1a", "code_candidates": [{"code": "def caesar_cipher(text: str) -> str:\n    result = []\n    for char in text:\n        if 'a' <= char <= 'z':\n            # Shift by 4 positions with wrapping\n            shifted = (ord(char) - ord('a') + 4) % 26\n            result.append(chr(shifted + ord('a')))\n        else:\n            # Preserve non-lowercase letters\n            result.append(char)\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["lm", "ewhjklnop", "kj", "ix"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/90_prompt1a", "code_candidates": [{"code": "def second_smallest_unique(numbers):\n    if not numbers:\n        return None\n    \n    unique_numbers = set(numbers)\n    \n    if len(unique_numbers) < 2:\n        return None\n    \n    sorted_unique = sorted(unique_numbers)\n    return sorted_unique[1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "2", "None", "None", "1", "None", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/91_prompt1a", "code_candidates": [{"code": "def count_boredoms(text):\n    \"\"\"\n    Count the number of sentences that start with 'I' or 'W' in a string.\n    Sentences are delimited by '.', '?', or '!'.\n    \n    Args:\n        text (str): The input string containing sentences\n        \n    Returns:\n        int: The count of sentences starting with 'I' or 'W'\n    \"\"\"\n    if not text:\n        return 0\n    \n    # Split by sentence delimiters\n    import re\n    sentences = re.split(r'[.?!]+', text)\n    \n    count = 0\n    for sentence in sentences:\n        # Strip whitespace from the beginning of the sentence\n        sentence = sentence.lstrip()\n        # Check if the sentence is not empty and starts with 'I' or 'W'\n        if sentence and (sentence[0] == 'I' or sentence[0] == 'W'):\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 2, 3, 4, 5], "case_status": ["0", "1", "1", "0", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/92_prompt1a", "code_candidates": [{"code": "def check_sum_of_two(a, b, c):\n    \"\"\"\n    Takes 3 numbers and returns True if all are integers AND one equals \n    the sum of the other two. Returns False otherwise.\n    \n    Args:\n        a, b, c: Three numbers to check\n        \n    Returns:\n        bool: True if all are integers and one equals sum of others, False otherwise\n    \"\"\"\n    # Check if all numbers are integers\n    if not all(isinstance(x, int) for x in [a, b, c]):\n        return False\n    \n    # Check if one number equals the sum of the other two\n    return (a == b + c) or (b == a + c) or (c == a + b)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["True", "False", "False", "False", "True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/93_prompt1a", "code_candidates": [{"code": "def encode_message(message: str) -> str:\n    if not message:\n        return \"\"\n    \n    vowels = \"aeiou\"\n    result = []\n    \n    for char in message:\n        # Swap case\n        swapped_char = char.lower() if char.isupper() else char.upper()\n        \n        # Replace vowels\n        if swapped_char.lower() in vowels:\n            # Get the character 2 positions ahead, wrapping around if necessary\n            char_code = ord(swapped_char.lower())\n            new_code = char_code + 2\n            if new_code > ord('z'):\n                new_code = new_code - 26  # Wrap around\n            new_char = chr(new_code)\n            # Preserve the original case\n            if swapped_char.isupper():\n                new_char = new_char.upper()\n            result.append(new_char)\n        else:\n            result.append(swapped_char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["tgst", "mWDCSKR", "ygs", "tHKS KS C MGSSCGG", "k dQnT kNqW wHcT Tq wRkTg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/94_prompt1a", "code_candidates": [{"code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    def digit_sum(n):\n        return sum(int(digit) for digit in str(n))\n    \n    primes = [num for num in lst if is_prime(num)]\n    \n    if not primes:\n        return 0\n    \n    min_prime = min(primes)\n    max_prime = max(primes)\n    \n    return digit_sum(min_prime) + digit_sum(max_prime)", "index": 0, "passed_case": [], "case_status": ["12", "27", "16", "16", "6", "9", "38", "26", "26"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/95_prompt1a", "code_candidates": [{"code": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    \n    # Check if all keys are strings\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    # Check if all keys are lowercase or all keys are uppercase\n    all_lower = all(key.islower() for key in keys)\n    all_upper = all(key.isupper() for key in keys)\n    \n    return all_lower or all_upper", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "False", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/96_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef primes_less_than(n: int) -> List[int]:\n    if n <= 2:\n        return []\n    \n    # Sieve of Eratosthenes\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    return [i for i in range(2, n) if is_prime[i]]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/97_prompt1a", "code_candidates": [{"code": "def product_of_unit_digits(a: int, b: int) -> int:\n    \"\"\"\n    Returns the product of unit digits of two integers.\n    For negative numbers, the unit digit is considered positive.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        Product of unit digits of both integers\n    \"\"\"\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/98_prompt1a", "code_candidates": [{"code": "def count_uppercase_vowels_at_even_indices(s: str) -> int:\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    for i in range(0, len(s), 2):  # iterate through even indices\n        if s[i] in uppercase_vowels:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/99_prompt1a", "code_candidates": [{"code": "def closest_integer(number_str: str) -> int:\n    \"\"\"\n    Takes a string representing a number and returns the closest integer,\n    rounding away from zero when equidistant between two integers.\n    \n    Args:\n        number_str: A string representing a number\n        \n    Returns:\n        The closest integer, with ties rounded away from zero\n    \"\"\"\n    num = float(number_str)\n    \n    if num >= 0:\n        # For positive numbers, round up at 0.5\n        return int(num + 0.5)\n    else:\n        # For negative numbers, round down at -0.5 (away from zero)\n        return int(num - 0.5)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["10", "15", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/100_prompt1a", "code_candidates": [{"code": "def make_a_pile(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of 2*n or n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    result = []\n    current = n\n    \n    for i in range(n):\n        result.append(current)\n        if n % 2 == 1:  # n is odd\n            current += 2  # next odd number\n        else:  # n is even\n            current += 2  # next even number\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/101_prompt1a", "code_candidates": [{"code": "import re\n\ndef words_string(s):\n    \"\"\"\n    You will be given a string of words separated by letters or commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    # Split by comma or whitespace and filter out empty strings\n    words = re.split(r'[,\\s]+', s.strip())\n    return [word for word in words if word]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/102_prompt1a", "code_candidates": [{"code": "def largest_integer_in_range(x: int, y: int) -> int:\n    \"\"\"\n    Returns the largest integer in range [x, y].\n    \n    Args:\n        x: The lower bound of the range (inclusive)\n        y: The upper bound of the range (inclusive)\n    \n    Returns:\n        The largest integer in the range [x, y], or -1 if no such number exists\n    \"\"\"\n    if x > y:\n        return -1\n    \n    return y", "index": 0, "passed_case": [1, 2, 3, 5, 7], "case_status": ["15", "-1", "12354", "-1", "29", "-1", "7", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/103_prompt1a", "code_candidates": [{"code": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    # Calculate the average of integers from n to m (inclusive)\n    total = sum(range(n, m + 1))\n    count = m - n + 1\n    average = total / count\n    \n    # Round to the nearest integer\n    rounded = round(average)\n    \n    # Convert to binary\n    return bin(rounded)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["0b11", "0b1010", "0b1111001010", "0b1111100100", "0b1011000010", "0b101101110", "0b110101101", "0b1001110010", "0b11010111", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/104_prompt1a", "code_candidates": [{"code": "def odd_digit_numbers(x):\n    \"\"\"\n    Return a sorted list of elements that contain only odd digits.\n    \n    Args:\n        x: List of positive integers\n        \n    Returns:\n        List of integers containing only odd digits, sorted in ascending order\n    \"\"\"\n    def has_only_odd_digits(num):\n        \"\"\"Check if a number contains only odd digits.\"\"\"\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                return False\n        return True\n    \n    # Filter numbers with only odd digits and sort the result\n    result = [num for num in x if has_only_odd_digits(num)]\n    return sorted(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 15, 33]", "[]", "[111, 151]", "[31, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/105_prompt1a", "code_candidates": [{"code": "def by_length(arr):\n    # Filter numbers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort in ascending order\n    filtered_arr.sort()\n    \n    # Reverse the array\n    filtered_arr.reverse()\n    \n    # Map numbers to their word representations\n    num_to_word = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    return [num_to_word[num] for num in filtered_arr]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/106_prompt1a", "code_candidates": [{"code": "def f(n):\n    def factorial(x):\n        if x <= 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    def sum_to_x(x):\n        return x * (x + 1) // 2\n    \n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 1:  # odd\n            result.append(factorial(i))\n        else:  # even\n            result.append(sum_to_x(i))\n    \n    return result", "index": 0, "passed_case": [2], "case_status": ["[1, 3, 6, 10, 120]", "[1, 3, 6, 10, 120, 21, 5040]", "[1]", "[1, 3, 6]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/107_prompt1a", "code_candidates": [{"code": "def count_even_odd_palindromes(n: int) -> tuple:\n    \"\"\"\n    Given a positive integer n, return a tuple containing the count of even and odd integer palindromes \n    in the range [1, n] inclusive.\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        A tuple (even_count, odd_count) where even_count is the number of even palindromes \n        and odd_count is the number of odd palindromes in range [1, n]\n    \"\"\"\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        # Check if the number is a palindrome\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/108_prompt1a", "code_candidates": [{"code": "def count_positive_digit_sums(numbers):\n    def digit_sum(n):\n        if n == 0:\n            return 0\n        str_n = str(abs(n))\n        if n < 0:\n            # Only the first digit is negative, others are positive\n            return -int(str_n[0]) + sum(int(digit) for digit in str_n[1:])\n        else:\n            return sum(int(digit) for digit in str_n)\n    \n    count = 0\n    for num in numbers:\n        if digit_sum(num) > 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "0", "6", "5", "4", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/109_prompt1a", "code_candidates": [{"code": "def move_one_ball(arr):\n    if not arr:\n        return True\n    \n    n = len(arr)\n    \n    # Check if array is already sorted in non-decreasing order\n    def is_sorted_asc(arr):\n        for i in range(1, len(arr)):\n            if arr[i] < arr[i-1]:\n                return False\n        return True\n    \n    # Check if array is already sorted in non-increasing order\n    def is_sorted_desc(arr):\n        for i in range(1, len(arr)):\n            if arr[i] > arr[i-1]:\n                return False\n        return True\n    \n    # If already sorted in either order\n    if is_sorted_asc(arr) or is_sorted_desc(arr):\n        return True\n    \n    # Try all possible right shifts\n    for i in range(n):\n        # Perform i right shifts\n        shifted = arr[-i:] + arr[:-i] if i > 0 else arr[:]\n        \n        # Check if sorted in non-decreasing order\n        if is_sorted_asc(shifted):\n            return True\n            \n        # Check if sorted in non-increasing order\n        if is_sorted_desc(shifted):\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/110_prompt1a", "code_candidates": [{"code": "def can_make_all_even(lst1, lst2):\n    # Count odd numbers in lst1 that need to be replaced\n    odd_count_in_lst1 = sum(1 for x in lst1 if x % 2 == 1)\n    \n    # Count even numbers in lst2 that can be used for exchange\n    even_count_in_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If we have enough even numbers in lst2 to replace all odd numbers in lst1\n    if even_count_in_lst2 >= odd_count_in_lst1:\n        return 'YES'\n    else:\n        return 'NO'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["YES", "NO", "YES", "YES", "NO", "NO", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/111_prompt1a", "code_candidates": [{"code": "def letter_frequency(s: str) -> dict:\n    if not s:\n        return {}\n    \n    letters = s.split()\n    frequency = {}\n    \n    for letter in letters:\n        frequency[letter] = frequency.get(letter, 0) + 1\n    \n    max_count = max(frequency.values())\n    return {letter: count for letter, count in frequency.items() if count == max_count}", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/112_prompt1a", "code_candidates": [{"code": "def reverse_delete(s, c):\n    # Create a set of characters to delete for faster lookup\n    chars_to_delete = set(c)\n    \n    # Filter out characters that are in c from s\n    result = ''.join(char for char in s if char not in chars_to_delete)\n    \n    # Check if the result is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/113_prompt1a", "code_candidates": [{"code": "def count_odd_digits(strings):\n    \"\"\"\n    Given a list of strings containing only digits, return a list where each element \n    is a formatted string describing the count of odd digits in the corresponding input string.\n    \n    Args:\n        strings: List[str] - list of strings containing only digits\n        \n    Returns:\n        List[str] - formatted strings describing odd digit counts\n    \"\"\"\n    result = []\n    \n    for s in strings:\n        odd_count = sum(1 for char in s if char in '13579')\n        formatted_string = f'the number of odd elements {odd_count} in the string {odd_count} of the input'\n        result.append(formatted_string)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["['the number of odd elements 4 in the string 4 of the input']", "['the number of odd elements 1 in the string 1 of the input', 'the number of odd elements 8 in the string 8 of the input']", "['the number of odd elements 2 in the string 2 of the input', 'the number of odd elements 3 in the string 3 of the input', 'the number of odd elements 2 in the string 2 of the input']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/114_prompt1a", "code_candidates": [{"code": "def minSubArraySum(nums):\n    if not nums:\n        return 0\n    \n    min_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = min(nums[i], current_sum + nums[i])\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/115_prompt1a", "code_candidates": [{"code": "def max_fill(grid, capacity):\n    import math\n    \n    # Count total water units (1s) in the grid\n    total_water = sum(sum(row) for row in grid)\n    \n    # If no water, no buckets needed\n    if total_water == 0:\n        return 0\n    \n    # Calculate number of bucket fills needed\n    # Each bucket can carry 'capacity' units of water\n    # So we need ceil(total_water / capacity) buckets\n    return math.ceil(total_water / capacity)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["6", "5", "0", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/116_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef sort_by_bits(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort an array of non-negative integers by number of 1-bits in their binary \n    representation (ascending), then by decimal value for ties.\n    \n    Args:\n        arr: List of non-negative integers\n        \n    Returns:\n        Sorted list according to the criteria\n    \"\"\"\n    def count_ones(n: int) -> int:\n        \"\"\"Count the number of 1-bits in binary representation of n\"\"\"\n        return bin(n).count('1')\n    \n    # Sort by number of 1-bits, then by decimal value\n    return sorted(arr, key=lambda x: (count_ones(x), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[1, 2, 4, 3, 5]", "[-4, -2, -6, -5, -3]", "[0, 1, 2, 4, 3]", "[]", "[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "[32, 3, 5, 6, 12, 44]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/117_prompt1a", "code_candidates": [{"code": "def words_with_n_consonants(s: str, n: int) -> list:\n    if not s:\n        return []\n    \n    vowels = set('aeiouAEIOU')\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n and consonant_count > 0:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['little']", "['Mary', 'lamb']", "[]", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/118_prompt1a", "code_candidates": [{"code": "def find_closest_vowel_between_consonants(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n    \n    vowels = set('aeiouAEIOU')\n    \n    # Check left-to-right direction\n    for i in range(1, len(word) - 1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    \n    # Check right-to-left direction\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels and word[i-1] not in vowels and word[i+1] not in vowels:\n            return word[i]\n    \n    return \"\"", "index": 0, "passed_case": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["o", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/119_prompt1a", "code_candidates": [{"code": "def match_parens(lst):\n    def get_balance_info(s):\n        balance = 0\n        min_balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:  # char == ')'\n                balance -= 1\n            min_balance = min(min_balance, balance)\n        return balance, min_balance\n    \n    # Get balance info for both strings\n    balance1, min_balance1 = get_balance_info(lst[0])\n    balance2, min_balance2 = get_balance_info(lst[1])\n    \n    # Try both possible orderings\n    # Order 1: lst[0] + lst[1]\n    total_balance1 = balance1 + balance2\n    min_prefix1 = min_balance1\n    min_suffix1 = min_balance2 - balance1 if balance1 > 0 else min_balance2\n    \n    # Order 2: lst[1] + lst[0]\n    total_balance2 = balance2 + balance1\n    min_prefix2 = min_balance2\n    min_suffix2 = min_balance1 - balance2 if balance2 > 0 else min_balance1\n    \n    # Check if either ordering works\n    if total_balance1 == 0 and min_prefix1 >= 0 and min_suffix1 >= 0:\n        return 'Yes'\n    if total_balance2 == 0 and min_prefix2 >= 0 and min_suffix2 >= 0:\n        return 'Yes'\n    \n    return 'No'", "index": 0, "passed_case": [1, 2, 5, 7, 8, 9], "case_status": ["No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/120_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef k_smallest(arr: List[int], k: int) -> List[int]:\n    if not arr or k <= 0:\n        return []\n    \n    # Sort the array and return first k elements\n    sorted_arr = sorted(arr)\n    return sorted_arr[:k]", "index": 0, "passed_case": [0, 5, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[-4, 4]", "[-3]", "[-123, -3, 0]", "[-123, -3, 0, 1]", "[-13, -8, 0, 0, 3, 5, 15]", "[-10, -1]", "[-7]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/121_prompt1a", "code_candidates": [{"code": "def sum_even_odd_condition(nums):\n    \"\"\"\n    Given a non-empty list of integers, return the sum of elements that satisfy \n    the condition: (element value is even AND position is even) OR \n    (element value is odd AND position is odd).\n    \n    Args:\n        nums: List[int] - a non-empty list of integers\n        \n    Returns:\n        int - sum of elements satisfying the condition\n    \"\"\"\n    total = 0\n    for i, num in enumerate(nums):\n        if (num % 2 == 0 and i % 2 == 0) or (num % 2 == 1 and i % 2 == 1):\n            total += num\n    return total", "index": 0, "passed_case": [], "case_status": ["6", "388", "9", "10", "43", "24"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/122_prompt1a", "code_candidates": [{"code": "def sum_two_digit_elements(arr, k):\n    \"\"\"\n    Return the sum of elements with at most two digits (0-99) from the last k elements of arr.\n    \n    Args:\n        arr: A non-empty array of integers\n        k: An integer representing how many elements from the end to consider\n        \n    Returns:\n        The sum of qualifying elements, or 0 if none qualify\n    \"\"\"\n    # Get the last k elements (or all elements if k > len(arr))\n    last_k_elements = arr[-k:] if k < len(arr) else arr[:]\n    \n    # Sum elements that have at most two digits (0-99)\n    total = sum(x for x in last_k_elements if 0 <= x <= 99)\n    \n    return total", "index": 0, "passed_case": [4], "case_status": ["274", "11", "30", "30", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/123_prompt1a", "code_candidates": [{"code": "def collatz_odd_numbers(n: int) -> list:\n    \"\"\"\n    Returns a sorted list of odd numbers in the Collatz sequence starting with n.\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        A sorted list of odd numbers in the Collatz sequence\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    odd_numbers = set()\n    current = n\n    \n    while current != 1:\n        if current % 2 == 1:  # current is odd\n            odd_numbers.add(current)\n            current = 3 * current + 1\n        else:  # current is even\n            current = current // 2\n    \n    # Add 1 since the sequence always ends with 1\n    odd_numbers.add(1)\n    \n    return sorted(list(odd_numbers))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/124_prompt1a", "code_candidates": [{"code": "def validate_date(date_string):\n    if not date_string:\n        return False\n    \n    parts = date_string.split('-')\n    if len(parts) != 3:\n        return False\n    \n    try:\n        month_str, day_str, year_str = parts\n        \n        # Check if all parts are exactly the right length and numeric\n        if len(month_str) != 2 or len(day_str) != 2 or len(year_str) != 4:\n            return False\n        \n        if not (month_str.isdigit() and day_str.isdigit() and year_str.isdigit()):\n            return False\n        \n        month = int(month_str)\n        day = int(day_str)\n        year = int(year_str)\n        \n        # Check month range\n        if month < 1 or month > 12:\n            return False\n        \n        # Check day range based on month\n        if day < 1:\n            return False\n            \n        # Days in each month\n        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        \n        # Adjust February for leap years\n        if is_leap_year(year):\n            days_in_month[1] = 29\n            \n        if day > days_in_month[month - 1]:\n            return False\n            \n        return True\n    except (ValueError, IndexError):\n        return False\n\ndef is_leap_year(year):\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/125_prompt1a", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef process_string(s: str) -> List[str]:\n    if not s:\n        return []\n    \n    # First priority: split on whitespace and punctuation\n    if re.search(r'[\\s\\W_]+', s):\n        return re.split(r'[\\s\\W_]+', s)\n    \n    # Second priority: split on commas\n    if ',' in s:\n        return s.split(',')\n    \n    # Third priority: count lowercase letters with odd order in alphabet\n    count = 0\n    for char in s:\n        if char.islower():\n            order = ord(char) - ord('a')\n            if order % 2 == 1:\n                count += 1\n    \n    return [str(count)]", "index": 0, "passed_case": [], "case_status": ["['Hello', 'world', '']", "['Hello', 'world', '']", "['Hello', 'world', '']", "['Hello', 'Hello', 'world', '']", "['3']", "['2']", "['1']", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/126_prompt1a", "code_candidates": [{"code": "def is_sorted_with_no_three_consecutive_identical(nums):\n    \"\"\"\n    Check if a list is sorted in non-decreasing order with no three consecutive identical elements.\n    \n    Args:\n        nums: List of integers (non-negative)\n        \n    Returns:\n        bool: True if sorted with no three consecutive identical elements, False otherwise\n    \"\"\"\n    # Empty list returns True\n    if not nums:\n        return True\n    \n    # Single element list returns True\n    if len(nums) == 1:\n        return True\n    \n    # Check for non-decreasing order and no three consecutive identical elements\n    for i in range(1, len(nums)):\n        # Check if current element is less than previous (violates non-decreasing order)\n        if nums[i] < nums[i-1]:\n            return False\n        \n        # Check for three consecutive identical elements\n        if i >= 2 and nums[i] == nums[i-1] == nums[i-2]:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/127_prompt1a", "code_candidates": [{"code": "def intersection(interval1, interval2):\n    \"\"\"Determine whether the length of intersection of two intervals is prime, even, or odd.\"\"\"\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find intersection\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # Check if intervals intersect\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate length of intersection (inclusive)\n    length = intersection_end - intersection_start + 1\n    \n    # Check if length is prime\n    if length < 2:\n        return \"NO\"\n    \n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    \n    return \"YES\"", "index": 0, "passed_case": [0, 2, 3, 4, 5, 7], "case_status": ["NO", "YES", "YES", "YES", "NO", "NO", "YES", "NO"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/128_prompt1a", "code_candidates": [{"code": "from typing import List, Optional\n\ndef sum_abs_mult_signs(arr: List[int]) -> Optional[int]:\n    if not arr:\n        return None\n    \n    if 0 in arr:\n        return 0\n    \n    sum_abs = sum(abs(x) for x in arr)\n    sign_product = 1\n    \n    for x in arr:\n        if x > 0:\n            sign_product *= 1\n        elif x < 0:\n            sign_product *= -1\n    \n    return sum_abs * sign_product", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["-9", "0", "-10", "None", "20", "4", "-4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/129_prompt1a", "code_candidates": [{"code": "def path(grid, k):\n    N = len(grid)\n    if N < 2 or k <= 0:\n        return []\n    \n    # Directions for moving to adjacent cells (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Find all positions for each value\n    positions = {}\n    for i in range(N):\n        for j in range(N):\n            positions[grid[i][j]] = (i, j)\n    \n    # Try all possible starting positions\n    best_path = None\n    \n    def dfs(x, y, path_values, remaining_steps):\n        nonlocal best_path\n        \n        if remaining_steps == 0:\n            if best_path is None or path_values < best_path:\n                best_path = path_values[:]\n            return\n        \n        # Early termination if current path can't be better than best\n        if best_path is not None and path_values > best_path[:len(path_values)]:\n            return\n            \n        # Try all four directions\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                path_values.append(grid[nx][ny])\n                dfs(nx, ny, path_values, remaining_steps - 1)\n                path_values.pop()\n    \n    # Try starting from each cell\n    for i in range(N):\n        for j in range(N):\n            path_values = [grid[i][j]]\n            dfs(i, j, path_values, k - 1)\n    \n    return best_path", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[1, 2, 1]", "[1]", "[1, 2, 1, 2]", "[1, 10, 1, 10, 1, 10, 1]", "[1, 7, 1, 7, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]", "[1, 3, 1, 3, 1, 3, 1, 3]", "[1, 5, 1, 5, 1, 5, 1, 5]", "[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/130_prompt1a", "code_candidates": [{"code": "def modified_tribonacci(n: int) -> list:\n    if n < 0:\n        return []\n    \n    # Initialize the sequence with base cases\n    tri = [0] * (n + 1)\n    tri[0] = 1\n    if n >= 1:\n        tri[1] = 3\n    \n    # Fill the sequence according to the rules\n    for i in range(2, n + 1):\n        if i % 2 == 1:  # i is odd\n            tri[i] = 1 + i // 2\n        else:  # i is even\n            # For even numbers, we need to handle negative indices\n            # tri(-1) is treated as 0\n            prev1 = tri[i-1] if i-1 >= 0 else 0\n            prev2 = tri[i-2] if i-2 >= 0 else 0\n            prev3 = tri[i-3] if i-3 >= 0 else 0\n            tri[i] = prev1 + prev2 + prev3\n    \n    return tri", "index": 0, "passed_case": [8, 9], "case_status": ["[1, 3, 4, 2]", "[1, 3, 4, 2, 9]", "[1, 3, 4, 2, 9, 3]", "[1, 3, 4, 2, 9, 3, 14]", "[1, 3, 4, 2, 9, 3, 14, 4]", "[1, 3, 4, 2, 9, 3, 14, 4, 21]", "[1, 3, 4, 2, 9, 3, 14, 4, 21, 5]", "[1, 3, 4, 2, 9, 3, 14, 4, 21, 5, 30, 6, 41, 7, 54, 8, 69, 9, 86, 10, 105]", "[1]", "[1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/131_prompt1a", "code_candidates": [{"code": "def product_of_odd_digits(n: int) -> int:\n    product = 1\n    has_odd = False\n    \n    for digit in str(n):\n        d = int(digit)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    \n    return product if has_odd else 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["5", "5", "5", "315", "2625", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/132_prompt1a", "code_candidates": [{"code": "def has_nested_brackets(s: str) -> bool:\n    \"\"\"\n    Determines if a string of square brackets contains a valid subsequence \n    with at least one nested bracket (brackets inside other brackets).\n    \n    Args:\n        s: A string containing only square brackets '[' and ']'\n        \n    Returns:\n        True if such a nested subsequence exists, False otherwise\n    \"\"\"\n    # Count of open brackets\n    open_count = 0\n    # Maximum depth reached\n    max_depth = 0\n    \n    # Traverse the string to find the maximum nesting depth\n    for char in s:\n        if char == '[':\n            open_count += 1\n            max_depth = max(max_depth, open_count)\n        elif char == ']':\n            open_count -= 1\n            # If we have more than 1 open bracket at any point, we have nesting\n            if open_count >= 1:\n                return True\n    \n    # If we never had more than 1 open bracket, no nesting exists\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13], "case_status": ["True", "False", "False", "False", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/133_prompt1a", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    if lst is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not lst:\n        return 0\n    \n    total = 0\n    for num in lst:\n        ceiling_value = math.ceil(num)\n        total += ceiling_value * ceiling_value\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/134_prompt1a", "code_candidates": [{"code": "def is_last_char_standalone_letter(s: str) -> bool:\n    if not s:\n        return False\n    \n    # Check if the last character is alphabetical\n    if not s[-1].isalpha():\n        return False\n    \n    # If string has only one character and it's alphabetical, it's standalone\n    if len(s) == 1:\n        return True\n    \n    # Check if the character before the last is a space\n    # This ensures the last character is not part of a larger word\n    return s[-2] == ' '", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["False", "True", "False", "True", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/135_prompt1a", "code_candidates": [{"code": "def can_arrange(arr):\n    \"\"\"Create a function which returns the smallest or largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n    if len(arr) <= 1:\n        return -1\n    \n    # Find the first index where current element is less than previous element\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    \n    return -1", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["3", "-1", "2", "2", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/136_prompt1a", "code_candidates": [{"code": "def closest_to_zero(numbers):\n    \"\"\"\n    Returns a tuple (a, b) where 'a' is the negative integer closest to zero\n    (least negative) and 'b' is the positive integer closest to zero (least positive).\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        tuple: (a, b) where a is the least negative integer or None,\n               and b is the least positive integer or None\n    \"\"\"\n    if not numbers:\n        return (None, None)\n    \n    negative_closest = None\n    positive_closest = None\n    \n    for num in numbers:\n        if num < 0:\n            if negative_closest is None or num > negative_closest:\n                negative_closest = num\n        elif num > 0:\n            if positive_closest is None or num < positive_closest:\n                positive_closest = num\n        # Skip zero (num == 0)\n    \n    return (negative_closest, positive_closest)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/137_prompt1a", "code_candidates": [{"code": "def compare_one(a, b):\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the smaller or larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_one(1, 2.5) \u279e 2.5\n    compare_one(1, \"2,3\") \u279e \"2,3\"\n    compare_one(\"5,1\", \"6\") \u279e \"6\"\n    compare_one(\"1\", 1) \u279e None\n    \"\"\"\n    def to_float(val):\n        if isinstance(val, str):\n            # Replace comma with dot for decimal representation\n            return float(val.replace(',', '.'))\n        return float(val)\n    \n    float_a = to_float(a)\n    float_b = to_float(b)\n    \n    if float_a < float_b:\n        return a\n    elif float_b < float_a:\n        return b\n    else:\n        return None", "index": 0, "passed_case": [7], "case_status": ["1", "1", "2", "5", "1", "5,1", "1", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/138_prompt1a", "code_candidates": [{"code": "def can_be_sum_of_four_positives(n: int) -> bool:\n    \"\"\"\n    Evaluate whether the given number n can be written as the sum of 4 positive integers.\n    \n    Args:\n        n: An integer to check\n        \n    Returns:\n        True if n can be expressed as sum of 4 positive integers, False otherwise\n    \"\"\"\n    # The minimum sum of 4 positive integers is 4 (1+1+1+1)\n    # So any number less than 4 cannot be expressed as such a sum\n    return n >= 4", "index": 0, "passed_case": [2, 3, 5, 7], "case_status": ["True", "True", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/139_prompt1a", "code_candidates": [{"code": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n!, or, brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n    \n    # Calculate factorial of n\n    factorial_n = 1\n    for i in range(1, n + 1):\n        factorial_n *= i\n    \n    # Calculate the special factorial\n    result = 1\n    for i in range(1, n + 1):\n        factorial_i = 1\n        for j in range(1, i + 1):\n            factorial_i *= j\n        result *= factorial_i\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/140_prompt1a", "code_candidates": [{"code": "import re\n\ndef replace_spaces(s: str) -> str:\n    if not s:\n        return s\n    \n    # Replace sequences of 3 or more spaces with a single dash\n    result = re.sub(r' {3,}', '-', s)\n    \n    # Replace remaining sequences of exactly 2 spaces with underscores\n    result = re.sub(r'  ', '_', result)\n    \n    return result", "index": 0, "passed_case": [0, 3], "case_status": ["Example", "Mudasir Hanif", "Yellow Yellow_Dirty_Fellow", "Exa-mple", "-Exa 1 2 2 mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/141_prompt1a", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef validate_file_name(file_name: str) -> bool:\n    # Check if there's exactly one dot\n    if file_name.count('.') != 1:\n        return False\n    \n    # Split into name and extension\n    name_part, extension = file_name.split('.')\n    \n    # Check if name part is non-empty\n    if not name_part:\n        return False\n    \n    # Check if name starts and ends with a latin letter\n    if not (name_part[0].isalpha() and name_part[-1].isalpha()):\n        return False\n    \n    # Check if extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return False\n    \n    # Check if name contains exactly 3 digits\n    digit_count = sum(1 for char in name_part if char.isdigit())\n    if digit_count != 3:\n        return False\n    \n    return True", "index": 0, "passed_case": [], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "True", "False", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/142_prompt1a", "code_candidates": [{"code": "def process_list_elements(numbers: list) -> int:\n    \"\"\"\n    Process list elements by applying operations based on index:\n    - Cube elements at indices multiple of 3\n    - Square elements at indices multiple of 4 but not 3\n    - Leave others unchanged\n    - Return the sum of all processed elements\n    \n    Args:\n        numbers: List of numbers to process\n        \n    Returns:\n        Sum of processed elements\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    total = 0\n    for i, num in enumerate(numbers):\n        if i % 12 == 0:  # Multiple of both 3 and 4 (i.e., 12)\n            total += num ** 3\n        elif i % 4 == 0:  # Multiple of 4 but not 3\n            total += num ** 2\n        else:  # All other indices\n            total += num\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 5, 8], "case_status": ["6", "14", "0", "9", "-5", "0", "20", "-175710", "0", "-18620", "-1972"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/143_prompt1a", "code_candidates": [{"code": "def filter_words_by_length(sentence: str, lengths: list[int]) -> str:\n    if not sentence or not lengths:\n        return \"\"\n    \n    words = sentence.split()\n    filtered_words = [word for word in words if len(word) in lengths]\n    \n    return \" \".join(filtered_words)", "index": 0, "passed_case": [5], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/144_prompt1a", "code_candidates": [{"code": "def simplify(a, b):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n, or x + n. The function returns True if x * n or x + n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = True\n    simplify(\"1/6\", \"2/1\") = False\n    simplify(\"7/10\", \"10/2\") = False\n    \"\"\"\n    from fractions import Fraction\n    \n    # Parse the fractions\n    frac_a = Fraction(a)\n    frac_b = Fraction(b)\n    \n    # Calculate both operations\n    product = frac_a * frac_b\n    sum_result = frac_a + frac_b\n    \n    # Check if either result is a whole number\n    return product.denominator == 1 or sum_result.denominator == 1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/145_prompt1a", "code_candidates": [{"code": "def sort_by_digit_sum(numbers):\n    \"\"\"\n    Sort integers by sum of digits in descending order, with tie-breaking by original index position.\n    For negative numbers, sum of digits is calculated using absolute value.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        List of integers sorted by digit sum (descending), then by original index (ascending)\n    \"\"\"\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Create list of (digit_sum, original_index, number) tuples\n    indexed_numbers = [(digit_sum(num), i, num) for i, num in enumerate(numbers)]\n    \n    # Sort by digit_sum (descending) then by original_index (ascending)\n    sorted_numbers = sorted(indexed_numbers, key=lambda x: (-x[0], x[1]))\n    \n    # Extract just the numbers from the sorted tuples\n    return [num for _, _, num in sorted_numbers]", "index": 0, "passed_case": [2], "case_status": ["[-12, 11, -11, 1, -1]", "[3457, 463, 56, 1234, 145, 37, 46, 423, 423, 423, 53, 6, 3, 2, 0]", "[]", "[-98, 54, 43, -32, -3, -11, 2, 1]", "[9, 8, 7, 6, 5, 4, 3, 2, 11, 1, 10]", "[-76, 6, 6, 23, 4, -21, 0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/146_prompt1a", "code_candidates": [{"code": "def count_numbers(arr):\n    \"\"\"\n    Count numbers in array where:\n    1) number is not equal to 10, AND\n    2) first and last digits are both odd OR both even\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        int: Count of numbers meeting criteria\n    \"\"\"\n    def is_odd_digit(digit):\n        return digit % 2 == 1\n    \n    def get_first_digit(num):\n        return int(str(abs(num))[0])\n    \n    def get_last_digit(num):\n        return int(str(abs(num))[-1])\n    \n    count = 0\n    for num in arr:\n        if num == 10:\n            continue\n            \n        first_digit = get_first_digit(num)\n        last_digit = get_last_digit(num)\n        \n        first_is_odd = is_odd_digit(first_digit)\n        last_is_odd = is_odd_digit(last_digit)\n        \n        if first_is_odd == last_is_odd:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [3, 6], "case_status": ["4", "3", "4", "4", "5", "1", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/147_prompt1a", "code_candidates": [{"code": "def get_max_triples(n):\n    # Create array a where a[i] = i * i + i - 1\n    a = [i * i + i - 1 for i in range(1, n + 1)]\n    \n    # Count triples where sum is divisible by 3\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1], "case_status": ["1", "4", "24", "51744"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/148_prompt1a", "code_candidates": [{"code": "def bf(planet1, planet2):\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["('Saturn', 'Uranus')", "('Venus',)", "('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')", "('Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus')", "()", "()", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/149_prompt1a", "code_candidates": [{"code": "def filter_and_sort_strings(strings):\n    \"\"\"\n    Filter strings with odd lengths, then sort remaining strings by length \n    (ascending order) with alphabetical ascending order as tiebreaker.\n    If all strings have odd lengths, return empty list.\n    \n    Args:\n        strings: List of strings\n        \n    Returns:\n        List of strings filtered and sorted\n    \"\"\"\n    # Filter strings with even lengths\n    even_length_strings = [s for s in strings if len(s) % 2 == 0]\n    \n    # If all strings have odd lengths, return empty list\n    if len(even_length_strings) == 0 and len(strings) > 0:\n        return []\n    \n    # Sort by length first, then alphabetically\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['aa']", "['AI', 'asdf', 'school']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['cc', 'dd', 'aaaa', 'bbbb']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/150_prompt1a", "code_candidates": [{"code": "def func(a, b, c):\n    if a is None:\n        raise TypeError(\"Parameter 'a' cannot be None\")\n    if not isinstance(a, (int, float)):\n        raise TypeError(\"Parameter 'a' must be a numeric type\")\n    if a % 2 == 1:\n        return b\n    else:\n        return c", "index": 0, "passed_case": [0, 2, 3, 4, 7], "case_status": ["34", "8", "33", "3", "-1", "1245", "56", "1234", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/151_prompt1a", "code_candidates": [{"code": "def sum_of_squares(numbers):\n    \"\"\"\n    Return the sum of squares of non-negative integers in the list.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        int: Sum of squares of non-negative integers\n    \"\"\"\n    total = 0\n    for num in numbers:\n        if isinstance(num, int) and num >= 0:\n            total += num ** 2\n    return total", "index": 0, "passed_case": [0, 2, 3, 5, 6], "case_status": ["0", "41", "0", "0", "64", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/152_prompt1a", "code_candidates": [{"code": "from typing import List\n\ndef compare_scores(game: List[int], guess: List[int]) -> List[int]:\n    \"\"\"\n    Compare game scores with guesses and return an array where each element \n    represents how far off each guess was.\n    \n    Args:\n        game: List of actual game scores\n        guess: List of guessed scores\n        \n    Returns:\n        List where each element is 0 for correct guesses or the absolute \n        difference for incorrect guesses\n    \"\"\"\n    result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/153_prompt1a", "code_candidates": [{"code": "def strongest_extension(class_name: str, extensions: list) -> str:\n    def calculate_strength(extension: str) -> int:\n        uppercase_count = sum(1 for c in extension if c.isupper())\n        lowercase_count = sum(1 for c in extension if c.islower())\n        return uppercase_count - lowercase_count\n    \n    max_strength = float('-inf')\n    strongest_ext = extensions[0] if extensions else \"\"\n    \n    for extension in extensions:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_ext = extension\n    \n    return f\"{class_name}.{strongest_ext}\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["Watashi.eIGHt8OKe", "Boku123.YEs.WeCaNe", "__YESIMHERE.NuLl__", "K.TAR", "__HAHA.123", "YameRore.okIWILL123", "finNNalLLly.WoW", "_.Bb", "Sp.671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/154_prompt1a", "code_candidates": [{"code": "def cycpattern_check(a, b):\n    if not b:\n        return True\n    if len(b) > len(a):\n        return False\n    \n    # Check if b or any of its rotations is a substring of a\n    # Create a string that contains all possible rotations of b\n    # by concatenating b with itself\n    doubled_b = b + b\n    \n    # Check if a is a substring of doubled_b\n    # This works because all rotations of b will appear as substrings in doubled_b\n    for i in range(len(b)):\n        rotation = doubled_b[i:i+len(b)]\n        if rotation in a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/155_prompt1a", "code_candidates": [{"code": "def count_even_odd_digits(n: int) -> tuple[int, int]:\n    \"\"\"\n    Given an integer, return a tuple (even_count, odd_count) where even_count \n    is the number of even digits and odd_count is the number of odd digits \n    in the absolute value of the input number.\n    \n    Args:\n        n: An integer\n        \n    Returns:\n        A tuple containing (even_count, odd_count)\n    \"\"\"\n    # Convert to absolute value to handle negative numbers\n    abs_n = abs(n)\n    \n    # Handle special case of 0\n    if abs_n == 0:\n        return (1, 0)\n    \n    even_count = 0\n    odd_count = 0\n    \n    # Extract each digit and count even/odd\n    while abs_n > 0:\n        digit = abs_n % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        abs_n //= 10\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(1, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/156_prompt1a", "code_candidates": [{"code": "def int_to_mini_roman(num):\n    \"\"\"\n    Convert an integer to its binary representation as a lowercase string.\n    \n    Args:\n        num (int): The integer to convert\n        \n    Returns:\n        str: Binary representation of the integer in lowercase\n    \"\"\"\n    return bin(num)[2:].lower()", "index": 0, "passed_case": [], "case_status": ["10011", "10011000", "11111011", "110101010", "111110100", "1", "100", "101011", "1011010", "1011110", "1000010100", "1110000100", "1111100010", "1111101000"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/157_prompt1a", "code_candidates": [{"code": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a specific triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # Sort the sides to identify the largest side (potential hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check if it's a valid triangle (triangle inequality)\n    if a <= 0 or b <= 0 or c <= 0:\n        return False\n    \n    # Check Pythagorean theorem: a\u00b2 + b\u00b2 = c\u00b2\n    # Using a small tolerance for floating point comparison\n    return abs(sides[0]**2 + sides[1]**2 - sides[2]**2) < 1e-10", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/158_prompt1a", "code_candidates": [{"code": "def max_unique_word(words):\n    if not words:\n        return \"\"\n    \n    max_unique = -1\n    result = \"\"\n    \n    for word in words:\n        unique_count = len(set(word))\n        if unique_count > max_unique or (unique_count == max_unique and word < result):\n            max_unique = unique_count\n            result = word\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "enam", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/159_prompt1a", "code_candidates": [{"code": "def eat(x, y, z):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat no or more carrots to complete the day's meals.\n    you should return an array of [ total number of needed or eaten carrots before or after your meals,\n                                    the number of carrots needed or eaten left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    # Total carrots eaten = already eaten + carrots we need to eat\n    # But we can't eat more than what's available\n    carrots_to_eat = min(y, z)\n    total_eaten = x + carrots_to_eat\n    remaining_after_eating = z - carrots_to_eat\n    \n    return [total_eaten, remaining_after_eating]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["[11, 4]", "[12, 1]", "[11, 0]", "[7, 0]", "[9, 2]", "[5, 0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/160_prompt1a", "code_candidates": [{"code": "def do_algebra(operators, operands):\n    \"\"\"\n    Given two lists, use the two given lists to build the algebraic \n    expression and return the result of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operators = ['+', '*', '-']\n    operands = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n    \"\"\"\n    # Start with the first operand\n    result = operands[0]\n    \n    # Apply each operator with the corresponding operand\n    for i, operator in enumerate(operators):\n        operand = operands[i + 1]\n        \n        if operator == '+':\n            result += operand\n        elif operator == '-':\n            result -= operand\n        elif operator == '*':\n            result *= operand\n        elif operator == '//':\n            result //= operand\n        elif operator == '**':\n            result **= operand\n    \n    return result", "index": 0, "passed_case": [0, 2], "case_status": ["37", "15", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/161_prompt1a", "code_candidates": [{"code": "def solve(s):\n    # Check if string contains any letters\n    has_letters = any(c.isalpha() for c in s)\n    \n    if not has_letters:\n        # No letters found, reverse the entire string\n        return s[::-1]\n    else:\n        # Has letters, reverse case of each letter\n        result = []\n        for c in s:\n            if c.isalpha():\n                # Reverse the case\n                if c.islower():\n                    result.append(c.upper())\n                else:\n                    result.append(c.lower())\n            else:\n                # Keep non-letter characters unchanged\n                result.append(c)\n        return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["aSdF", "4321", "AB", "#A@c", "#aSDFw^45", "2@6#", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/162_prompt1a", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its ideal hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/163_prompt1a", "code_candidates": [{"code": "def even_numbers_in_range(a: int, b: int) -> list[int]:\n    \"\"\"\n    Return even numbers between a and b (inclusive) in ascending order.\n    \n    Args:\n        a: First positive integer\n        b: Second positive integer\n        \n    Returns:\n        List of even numbers in ascending order, or empty list if none exist\n    \"\"\"\n    # Ensure a is the smaller number\n    start, end = min(a, b), max(a, b)\n    \n    # Find all even numbers in the range\n    even_numbers = []\n    for num in range(start, end + 1):\n        if num % 2 == 0:\n            even_numbers.append(num)\n    \n    return even_numbers", "index": 0, "passed_case": [], "case_status": ["[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132]", "[18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1a"}
{"name": "HumanEval/0_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef has_pair_with_large_difference(numbers: List[float], threshold: float) -> bool:\n    \"\"\"\n    Check if in given list of numbers, are any two numbers whose absolute difference \n    is greater than the given threshold.\n    \n    Args:\n        numbers: List of numbers\n        threshold: The threshold value for comparison\n        \n    Returns:\n        True if such a pair exists, False otherwise\n    \"\"\"\n    if len(numbers) < 2:\n        return False\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) > threshold:\n                return True\n    \n    return False", "index": 0, "passed_case": [0, 2, 4, 5], "case_status": ["True", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/1_prompt1c", "code_candidates": [{"code": "def separate_parenthesized_groups(s: str) -> list:\n    \"\"\"\n    Separate parenthesized groups from input string, ignoring spaces.\n    \n    Args:\n        s: Input string containing parenthesized groups\n        \n    Returns:\n        List of complete parenthesized groups including the parentheses\n    \"\"\"\n    result = []\n    current_group = \"\"\n    balance = 0\n    \n    for char in s:\n        if char == ' ':\n            continue\n            \n        if char == '(':\n            if balance == 0:\n                current_group = \"\"\n            current_group += char\n            balance += 1\n        elif char == ')':\n            current_group += char\n            balance -= 1\n            if balance == 0:\n                result.append(current_group)\n        else:\n            current_group += char\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/2_prompt1c", "code_candidates": [{"code": "def truncate_number(number: float) -> int:\n    \"\"\"\n    Given a positive floating point number, return the integer part of the number.\n    \n    Args:\n        number: A positive floating point number\n        \n    Returns:\n        The integer part of the number\n        \n    Examples:\n        >>> truncate_number(3.5)\n        3\n        >>> truncate_number(7.9)\n        7\n        >>> truncate_number(2.0)\n        2\n    \"\"\"\n    return int(number)", "index": 0, "passed_case": [], "case_status": ["3", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/3_prompt1c", "code_candidates": [{"code": "def below_zero(operations):\n    \"\"\"\n    Returns True if the running balance of operations falls below zero at any point, False otherwise.\n    \n    Args:\n        operations: List of integers representing operations\n        \n    Returns:\n        bool: True if running balance goes below zero, False otherwise\n    \"\"\"\n    if not operations:\n        return False\n    \n    running_sum = 0\n    for op in operations:\n        running_sum += op\n        if running_sum < 0:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/4_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.5\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/5_prompt1c", "code_candidates": [{"code": "def insert_delimiter(lst, delimiter):\n    if len(lst) <= 1:\n        return lst + [delimiter] if lst else []\n    \n    result = []\n    for i, element in enumerate(lst):\n        result.append(element)\n        if i < len(lst) - 1:\n            result.append(delimiter)\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[5, 8, 6, 8, 3, 8, 2]", "[2, 2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/6_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    groups = paren_string.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        result.append(max_depth)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/7_prompt1c", "code_candidates": [{"code": "def filter_strings_with_substring(strings: list[str], substring: str) -> list[str]:\n    \"\"\"\n    Filter a list of strings to return only those containing the specified substring.\n    \n    Args:\n        strings: List of strings to filter\n        substring: Substring to search for\n        \n    Returns:\n        List of strings containing the substring\n    \"\"\"\n    if not strings:\n        return []\n    \n    return [s for s in strings if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/8_prompt1c", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef product_and_sum(numbers: List[int]) -> Tuple[int, int]:\n    product = 1\n    sum_val = 0\n    \n    for num in numbers:\n        product *= num\n        sum_val += num\n    \n    return (product, sum_val)", "index": 0, "passed_case": [4], "case_status": ["(1, 0)", "(1, 3)", "(0, 100)", "(105, 15)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/9_prompt1c", "code_candidates": [{"code": "def rolling_max(numbers):\n    \"\"\"\n    Generate a list of rolling maximum elements from a given list of integers.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        List of rolling maximum values\n        \n    Raises:\n        TypeError: If input is None\n    \"\"\"\n    if numbers is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/10_prompt1c", "code_candidates": [{"code": "def shortest_palindrome(s: str) -> str:\n    if not s:\n        return s\n    \n    # Find the longest palindromic prefix\n    # We'll check if the string is already a palindrome\n    # If not, we'll find the longest palindromic prefix from the left\n    def is_palindrome(string):\n        return string == string[::-1]\n    \n    # Try to find the longest palindromic prefix\n    # by checking if s[0:n] is palindrome for decreasing n\n    for i in range(len(s), 0, -1):\n        if is_palindrome(s[:i]):\n            # Found the longest palindromic prefix\n            # Append reverse of the remaining part to the front\n            return s[i-1::-1] + s\n    \n    # If no palindromic prefix found (should not happen for non-empty string)\n    # This case handles the first character being the longest palindromic prefix\n    return s[::-1][1:] + s", "index": 0, "passed_case": [0], "case_status": ["", "xx", "xxyz", "xyxxyx", "jjerry"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/11_prompt1c", "code_candidates": [{"code": "def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '011'\n    \"\"\"\n    return ''.join('0' if x == y else '1' for x, y in zip(a, b))", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/12_prompt1c", "code_candidates": [{"code": "from typing import List, Optional\n\ndef longest_string(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    \n    longest = strings[0]\n    for string in strings:\n        if len(string) > len(longest):\n            longest = string\n    \n    return longest", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/13_prompt1c", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    a, b = abs(a), abs(b)\n    while b:\n        a, b = b, a % b\n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/14_prompt1c", "code_candidates": [{"code": "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['abc', 'ab', 'a']\n    \"\"\"\n    return [string[:i] for i in range(len(string), 0, -1)]", "index": 0, "passed_case": [0], "case_status": ["[]", "['asdfgh', 'asdfg', 'asdf', 'asd', 'as', 'a']", "['WWW', 'WW', 'W']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/15_prompt1c", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing period-delimited numbers starting from 0 upto n inclusive. >>> string_sequence(0) '0' >>> string_sequence(5) '0.1.2.3.4.5' \"\"\"\n    return '.'.join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0], "case_status": ["0", "0.1.2.3", "0.1.2.3.4.5.6.7.8.9.10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/16_prompt1c", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    6\n    >>> count_distinct_characters('Jerry')\n    5\n    \"\"\"\n    return len(set(string.lower()))", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/17_prompt1c", "code_candidates": [{"code": "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [1, 4, 2, 4, 4, 2, 2, 2, 2, 1, 1]\n    \"\"\"\n    note_map = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    # Split the string by spaces and filter out empty strings\n    notes = [note for note in music_string.split(' ') if note]\n    \n    # Map each note to its beat value\n    return [note_map[note] for note in notes]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[]", "[4, 4, 4, 4]", "[1, 1, 1, 1]", "[2, 2, 1, 1, 4, 4, 4, 4]", "[2, 1, 2, 1, 4, 2, 4, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/18_prompt1c", "code_candidates": [{"code": "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    2\n    \"\"\"\n    if not substring:\n        return 0\n    \n    count = 0\n    start = 0\n    \n    while True:\n        pos = string.find(substring, start)\n        if pos != -1:\n            count += 1\n            start = pos + 1\n        else:\n            break\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/19_prompt1c", "code_candidates": [{"code": "def sort_number_words(input_str):\n    word_to_num = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    words = input_str.split()\n    sorted_words = sorted(words, key=lambda word: word_to_num[word])\n    \n    return ' '.join(sorted_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "three", "three five nine", "zero four five seven eight nine", "zero one two three four five six"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/20_prompt1c", "code_candidates": [{"code": "def find_min_difference_pair(numbers):\n    if not numbers or len(numbers) < 2:\n        return None\n    \n    min_diff = float('inf')\n    result = None\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff or (diff == min_diff and \n                                 (result is None or \n                                  numbers[i] < result[0] or \n                                  (numbers[i] == result[0] and numbers[j] < result[1]))):\n                min_diff = diff\n                result = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/21_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef linear_transform(numbers: List[float]) -> List[float]:\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/22_prompt1c", "code_candidates": [{"code": "def filter_integers(input_list):\n    \"\"\"\n    Filter out integers from the input list and return only non-integer values.\n    \n    Args:\n        input_list: A list of mixed data types\n        \n    Returns:\n        A new list containing only elements that are not integers\n    \"\"\"\n    return [item for item in input_list if not isinstance(item, int)]", "index": 0, "passed_case": [0], "case_status": ["[]", "[{}, [], 23.2, 'adasd']", "['c', 'a', 'b']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/23_prompt1c", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\"Return length of given string.\"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/24_prompt1c", "code_candidates": [{"code": "def largest_proper_divisor(n):\n    if n == 1:\n        return 1\n    \n    # Check from n//2 down to 1 to find the largest proper divisor\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    \n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/25_prompt1c", "code_candidates": [{"code": "def factorize(n):\n    if n <= 1:\n        return []\n    \n    factors = []\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n    \n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/26_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef remove_duplicates(lst: List[int]) -> List[int]:\n    \"\"\"\n    Remove all elements that occur more than once from the list,\n    keeping only elements that appear exactly once, while preserving\n    their original order.\n    \n    Args:\n        lst: A list of integers\n        \n    Returns:\n        A list containing only elements that appeared exactly once in the input,\n        in their original order\n    \"\"\"\n    # Count occurrences of each element\n    count = {}\n    for num in lst:\n        count[num] = count.get(num, 0) + 1\n    \n    # Filter elements that appear exactly once, preserving order\n    result = []\n    for num in lst:\n        if count[num] == 1:\n            result.append(num)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[1, 2, 3, 4]", "[1, 4, 5]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/27_prompt1c", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase. Non-alphabetic characters should remain unchanged. >>> flip_case('Hello') 'hello' >>> flip_case('') '' >>> flip_case('Hello123!') 'hELLO123!' >>> flip_case('WORLD') 'world' >>> flip_case('test123') 'TEST123' >>> flip_case('!@#$%') '!@#$%' >>> flip_case('MiXeD cAsE') 'mIxEd CaSe' \"\"\"\n    return string.swapcase()", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/28_prompt1c", "code_candidates": [{"code": "def reverse_concat(strings):\n    \"\"\"\n    Concatenates strings in reversed order with spaces between them.\n    \n    Args:\n        strings: List of strings to concatenate\n        \n    Returns:\n        str: Concatenated string with strings in reversed order separated by spaces\n        \n    Raises:\n        TypeError: If input is None\n    \"\"\"\n    if strings is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not strings:\n        return \"\"\n    \n    return \" \".join(reversed(strings))", "index": 0, "passed_case": [0], "case_status": ["", "z y x", "k w z y x"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/29_prompt1c", "code_candidates": [{"code": "from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['bcd', 'cde']\n    \"\"\"\n    return [s for s in strings if not s.startswith(prefix)]", "index": 0, "passed_case": [0], "case_status": ["[]", "['asd', 'xxy', 'john doe']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/30_prompt1c", "code_candidates": [{"code": "def get_positive(numbers: list) -> list:\n    \"\"\"\n    Return only positive numbers in the list.\n    \n    Args:\n        numbers: A list of numbers\n        \n    Returns:\n        A list containing only positive numbers (greater than zero)\n    \"\"\"\n    return [num for num in numbers if num > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/31_prompt1c", "code_candidates": [{"code": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/32_prompt1c", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef find_polynomial_zero(coefficients: List[float]) -> float:\n    \"\"\"\n    Finds a zero of a polynomial defined by coefficients.\n    \n    Args:\n        coefficients: List of coefficients in ascending order of powers (constant term first)\n        \n    Returns:\n        A real number x such that the polynomial evaluates to zero\n        \n    Raises:\n        ValueError: If coefficients list is empty, all-zero coefficients, or odd length\n    \"\"\"\n    if not coefficients:\n        raise ValueError(\"Coefficients list cannot be empty\")\n    \n    if len(coefficients) % 2 == 1:\n        raise ValueError(\"Coefficients list must have even length\")\n    \n    if all(coef == 0 for coef in coefficients):\n        raise ValueError(\"Coefficients cannot all be zero\")\n    \n    # For linear polynomial (degree 1): a0 + a1*x = 0 => x = -a0/a1\n    if len(coefficients) == 2:\n        a0, a1 = coefficients\n        if a1 == 0:\n            raise ValueError(\"Leading coefficient cannot be zero\")\n        return -a0 / a1\n    \n    # For higher degree polynomials, use numerical method (bisection method)\n    # First, find an interval where the function changes sign\n    def evaluate_polynomial(x: float) -> float:\n        result = 0.0\n        for i, coef in enumerate(coefficients):\n            result += coef * (x ** i)\n        return result\n    \n    # Try to find an interval where the function changes sign\n    # Start with a reasonable range\n    x1, x2 = -10.0, 10.0\n    \n    # Check if we can find a sign change\n    f1 = evaluate_polynomial(x1)\n    f2 = evaluate_polynomial(x2)\n    \n    # If both have same sign, try to find a better interval\n    if f1 * f2 > 0:\n        # Try to find a sign change by sampling more points\n        found_interval = False\n        for i in range(1, 21):  # Try 20 points\n            x = -10.0 + i * 1.0\n            fx = evaluate_polynomial(x)\n            if f1 * fx < 0:\n                x2 = x\n                f2 = fx\n                found_interval = True\n                break\n            elif fx * f2 < 0:\n                x1 = x\n                f1 = fx\n                found_interval = True\n                break\n        \n        if not found_interval:\n            # If still no sign change, try a wider range\n            x1, x2 = -100.0, 100.0\n            f1 = evaluate_polynomial(x1)\n            f2 = evaluate_polynomial(x2)\n            \n            # If still no sign change, raise error\n            if f1 * f2 > 0:\n                raise ValueError(\"Cannot find an interval with sign change\")\n    \n    # Bisection method to find root\n    tolerance = 1e-10\n    max_iterations = 1000\n    \n    for _ in range(max_iterations):\n        x_mid = (x1 + x2) / 2.0\n        f_mid = evaluate_polynomial(x_mid)\n        \n        if abs(f_mid) < tolerance:\n            return x_mid\n            \n        if f1 * f_mid < 0:\n            x2 = x_mid\n            f2 = f_mid\n        else:\n            x1 = x_mid\n            f1 = f_mid\n    \n    return (x1 + x2) / 2.0", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/33_prompt1c", "code_candidates": [{"code": "def sort_indices_0_3_6_9(arr):\n    \"\"\"\n    Sort elements at indices 0, 3, 6, 9... (0-indexed) in ascending order\n    while keeping all other elements in their original positions.\n    \n    Args:\n        arr: List of integers to be sorted in-place\n        \n    Returns:\n        None (modifies the list in-place)\n    \"\"\"\n    if not arr:\n        return\n    \n    # Extract elements at indices 0, 3, 6, 9...\n    elements = []\n    indices = []\n    \n    for i in range(0, len(arr), 3):\n        elements.append(arr[i])\n        indices.append(i)\n    \n    # Sort the extracted elements\n    elements.sort()\n    \n    # Put the sorted elements back at their respective indices\n    for i, index in enumerate(indices):\n        arr[index] = elements[i]", "index": 0, "passed_case": [], "case_status": ["None", "None", "None", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/34_prompt1c", "code_candidates": [{"code": "def get_sorted_unique_elements(numbers: list) -> list:\n    \"\"\"\n    Return sorted unique elements in a list in ascending order.\n    \n    Args:\n        numbers: A list of integers\n        \n    Returns:\n        A new list containing only the unique elements from the input list, \n        sorted in ascending order\n        \n    Raises:\n        TypeError: If the input list contains None values\n    \"\"\"\n    if not numbers:\n        return []\n    \n    if None in numbers:\n        raise TypeError(\"Input list contains None values\")\n    \n    return sorted(list(set(numbers)))", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/35_prompt1c", "code_candidates": [{"code": "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\"\"\"\n    if not l:\n        raise ValueError(\"Empty list has no maximum element\")\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/36_prompt1c", "code_candidates": [{"code": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "2", "3", "3", "6", "192", "639", "8026"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/37_prompt1c", "code_candidates": [{"code": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [3, 2, 1]\n    >>> sort_even([5, 6, 3, 4])\n    [6, 5, 4, 3]\n    \"\"\"\n    # Extract values at even indices\n    even_values = [l[i] for i in range(0, len(l), 2)]\n    \n    # Sort the even values\n    even_values.sort()\n    \n    # Create result list\n    result = l.copy()\n    \n    # Place sorted even values back at even indices\n    even_index = 0\n    for i in range(0, len(result), 2):\n        result[i] = even_values[even_index]\n        even_index += 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[1, 2, 3]", "[-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]", "[-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/38_prompt1c", "code_candidates": [{"code": "def encode_cyclic(s: str) -> str:\n    result = []\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            result.append(group[1:] + group[0])\n        else:\n            result.append(group)\n    return ''.join(result)\n\ndef decode_cyclic(s: str) -> str:\n    result = []\n    for i in range(0, len(s), 3):\n        group = s[i:i+3]\n        if len(group) == 3:\n            result.append(group[-1] + group[:-1])\n        else:\n            result.append(group)\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/39_prompt1c", "code_candidates": [{"code": "def prime_fibonacci(n: int) -> int:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    a, b = 0, 1\n    count = 0\n    \n    while count < n:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a\n    \n    return a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["2", "3", "5", "13", "89", "233", "1597", "28657", "514229", "433494437"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/40_prompt1c", "code_candidates": [{"code": "def three_sum_zero(l):\n    if len(l) < 3:\n        return False\n    \n    # Sort the list to enable two-pointer technique\n    sorted_list = sorted(l)\n    \n    # Iterate through each element as the first element of potential triplet\n    for i in range(len(sorted_list) - 2):\n        # Use two pointers to find if there's a pair that sums to negative of current element\n        left = i + 1\n        right = len(sorted_list) - 1\n        \n        while left < right:\n            current_sum = sorted_list[i] + sorted_list[left] + sorted_list[right]\n            \n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/41_prompt1c", "code_candidates": [{"code": "def is_prime(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    if n <= 0:\n        return 0\n    \n    # Each car moving left to right will collide with each car moving right to left\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/42_prompt1c", "code_candidates": [{"code": "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1. For example: incr_list([1, 2, 3]) should return [2, 3, 4], and incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) should return [6, 4, 6, 3, 4, 4, 10, 1, 124]. Handle empty list by returning empty list. Raise TypeError if input is None or contains non-numeric elements.\"\"\"\n    if l is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not all(isinstance(x, (int, float)) for x in l):\n        raise TypeError(\"All elements must be numeric\")\n    \n    return [x + 1 for x in l]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/43_prompt1c", "code_candidates": [{"code": "def has_two_sum_zero(nums):\n    if len(nums) < 2:\n        return False\n    \n    seen = set()\n    for num in nums:\n        if -num in seen:\n            return True\n        seen.add(num)\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/44_prompt1c", "code_candidates": [{"code": "def change_base(x: int, base: int) -> str:\n    if x == 0:\n        return '0'\n    \n    digits = \"0123456789abcdef\"\n    result = \"\"\n    \n    while x > 0:\n        result = digits[x % base] + result\n        x //= base\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/45_prompt1c", "code_candidates": [{"code": "def triangle_area(a, h):\n    \"\"\"Given length of a side (base) and height, return area for a triangle. The area is calculated as (1/2) * base * height. For example, triangle_area(5, 3) should return 7.5.\"\"\"\n    return 0.5 * a * h", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/46_prompt1c", "code_candidates": [{"code": "def fib4(n: int):\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    \n    # Initialize the first four values\n    a, b, c, d = 0, 0, 2, 0\n    \n    # Iteratively compute fib4 values\n    for i in range(4, n + 1):\n        next_val = a + b + c + d\n        a, b, c, d = b, c, d, next_val\n    \n    return d", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["4", "28", "104", "386"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/47_prompt1c", "code_candidates": [{"code": "def median(l: list):\n    \"\"\"Return median of elements in the list l. For odd-length lists, return the middle element. For even-length lists, return the average of the two middle elements. The list is first sorted in ascending order before median calculation. Examples: median([3, 1, 2, 4, 5]) returns 3. median([-10, 4, 6, 1000, 10, 20]) returns 8.0.\"\"\"\n    if not l:\n        return None\n    \n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    \n    if n % 2 == 1:\n        return sorted_list[n // 2]\n    else:\n        mid1 = sorted_list[n // 2 - 1]\n        mid2 = sorted_list[n // 2]\n        return (mid1 + mid2) / 2.0", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "8.0", "5", "5.5", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/48_prompt1c", "code_candidates": [{"code": "def is_palindrome(text: str):\n    \"\"\"\n    Checks if given string is a palindrome (reads the same forwards and backwards)\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/49_prompt1c", "code_candidates": [{"code": "def modp(n: int, p: int):\n    return pow(2, n, p)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/50_prompt1c", "code_candidates": [{"code": "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function which shifts every character by 5. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/51_prompt1c", "code_candidates": [{"code": "def remove_vowels(input_string: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in input_string if char not in vowels)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/52_prompt1c", "code_candidates": [{"code": "def below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t. Return False otherwise.\"\"\"\n    return all(x < t for x in l)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/53_prompt1c", "code_candidates": [{"code": "def add(x: int, y: int) -> int:\n    \"\"\"Add two numbers x and y, returning their sum. Examples: add(2, 3) should return 5, add(5, 7) should return 12.\"\"\"\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/54_prompt1c", "code_candidates": [{"code": "def is_same_characters(str1: str, str2: str) -> bool:\n    return set(str1) == set(str2)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/55_prompt1c", "code_candidates": [{"code": "def fib(n: int) -> int:\n    if n <= 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/56_prompt1c", "code_candidates": [{"code": "def is_valid_brackets(s: str) -> bool:\n    \"\"\"\n    Returns True if all opening brackets '<' have corresponding closing brackets '>',\n    and False otherwise. Validates that brackets are properly matched and nested.\n    \n    Args:\n        s: A string containing brackets to validate\n        \n    Returns:\n        bool: True if brackets are properly matched and nested, False otherwise\n    \"\"\"\n    count = 0\n    for char in s:\n        if char == '<':\n            count += 1\n        elif char == '>':\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/57_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef is_monotonic(nums: List[int]) -> bool:\n    if len(nums) <= 1:\n        return True\n    \n    is_increasing = True\n    is_decreasing = True\n    \n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            is_increasing = False\n        if nums[i] > nums[i-1]:\n            is_decreasing = False\n        \n        # Early termination if neither monotonic increasing nor decreasing\n        if not is_increasing and not is_decreasing:\n            return False\n    \n    return is_increasing or is_decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/58_prompt1c", "code_candidates": [{"code": "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [653, 5, 1]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [3, 2]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/59_prompt1c", "code_candidates": [{"code": "def largest_prime_factor(n):\n    \"\"\"\n    Return the largest prime factor of n, where n > 1 and n is not prime.\n    \n    Args:\n        n (int): A composite number greater than 1\n        \n    Returns:\n        int: The largest prime factor of n\n    \"\"\"\n    if n <= 1:\n        return None\n    \n    largest_factor = -1\n    \n    # Check for factor 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        factor += 2\n    \n    # If n is still greater than 1, then it's a prime factor\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/60_prompt1c", "code_candidates": [{"code": "def sum_to_n(n: int) -> int:\n    return sum(range(1, n + 1)) * 2", "index": 0, "passed_case": [], "case_status": ["2", "42", "132", "930", "10100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/61_prompt1c", "code_candidates": [{"code": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    Check if all parentheses in a string are properly matched.\n    \n    Args:\n        s: A string containing parentheses to check\n        \n    Returns:\n        True if all parentheses are properly matched, False otherwise\n    \"\"\"\n    count = 0\n    for char in s:\n        if char == '(':\n            count += 1\n        elif char == ')':\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/62_prompt1c", "code_candidates": [{"code": "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [20, 12, 4, 1]\n    >>> derivative([1, 2, 3])\n    [6, 2]\n    \"\"\"\n    if len(xs) <= 1:\n        return []\n    \n    result = []\n    for i in range(1, len(xs)):\n        result.append(i * xs[i])\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/63_prompt1c", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    \n    # Initialize the first three values\n    a, b, c = 0, 1, 1\n    \n    # Compute iteratively from 3 to n\n    for _ in range(3, n):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6], "case_status": ["1", "1", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/64_prompt1c", "code_candidates": [{"code": "def vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    5\n    >>> vowels_count(\"ACEDY\")\n    5\n    \"\"\"\n    if not s:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/65_prompt1c", "code_candidates": [{"code": "def circular_shift(x: int, shift: int) -> str:\n    # Convert to string and handle negative numbers\n    s = str(x)\n    is_negative = s.startswith('-')\n    if is_negative:\n        s = s[1:]  # Remove the negative sign for processing\n    \n    # Handle zero shift\n    if shift == 0:\n        return str(x)\n    \n    # Handle shift greater than digit count\n    if shift > len(s):\n        # Reverse the entire string (including negative sign if present)\n        result = s[::-1]\n        if is_negative:\n            result = '-' + result\n        return result\n    \n    # Perform circular right shift\n    # For right shift by k positions, we take last k digits and move them to front\n    shift = shift % len(s)  # Handle cases where shift equals length\n    if shift == 0:\n        return str(x)\n    \n    shifted = s[-shift:] + s[:-shift]\n    \n    # Reattach negative sign if needed\n    if is_negative:\n        shifted = '-' + shifted\n    \n    return shifted", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["001", "12", "79", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/66_prompt1c", "code_candidates": [{"code": "def sum_uppercase_ascii(input_string: str) -> int:\n    \"\"\"\n    Returns the sum of ASCII codes of uppercase letters (A-Z) in the input string.\n    \n    Args:\n        input_string: A string to process\n        \n    Returns:\n        int: Sum of ASCII codes of uppercase letters, or 0 if none exist\n    \"\"\"\n    if not input_string:\n        return 0\n    \n    total = 0\n    for char in input_string:\n        if 'A' <= char <= 'Z':\n            total += ord(char)\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "131", "67", "69", "131", "153", "151", "327"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/67_prompt1c", "code_candidates": [{"code": "import re\nfrom typing import List, Dict\n\ndef count_mangoes(fruit_string: str, total_fruits: int) -> int:\n    # Extract numbers from the string using regex\n    numbers = re.findall(r'\\d+', fruit_string)\n    \n    # Parse apples and oranges counts\n    apples = int(numbers[0])\n    oranges = int(numbers[1])\n    \n    # Calculate mangoes\n    mangoes = total_fruits - apples - oranges\n    \n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/68_prompt1c", "code_candidates": [{"code": "def find_smallest_even(arr):\n    if not arr:\n        return []\n    \n    smallest_even = None\n    smallest_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:  # Check if number is even\n            if smallest_even is None or num < smallest_even:\n                smallest_even = num\n                smallest_index = i\n    \n    if smallest_even is None:\n        return []\n    \n    return [smallest_even, smallest_index]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2, 1]", "[2, 1]", "[]", "[0, 1]", "[0, 3]", "[4, 1]", "[6, 1]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/69_prompt1c", "code_candidates": [{"code": "def search(lst):\n    from collections import Counter\n    \n    # Count frequency of each number\n    freq = Counter(lst)\n    \n    # Find the greatest integer that satisfies the condition\n    result = -1\n    for num, count in freq.items():\n        if num > 0 and count >= num and num > result:\n            result = num\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], "case_status": ["1", "4", "-1", "8", "2", "1", "2", "1", "-1", "1", "1", "5", "1", "4", "2", "1", "4", "4", "2", "-1", "-1", "2", "1", "1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/70_prompt1c", "code_candidates": [{"code": "def strange_sorting(arr):\n    \"\"\"\n    Performs 'strange' sorting by alternating between picking minimum and maximum values\n    from remaining elements, starting with minimum.\n    \n    Args:\n        arr: List of elements to sort\n        \n    Returns:\n        List with elements sorted in strange order\n    \"\"\"\n    if not arr:\n        return []\n    \n    result = []\n    remaining = sorted(arr)  # Sort to easily access min/max\n    \n    pick_min = True  # Flag to alternate between min and max\n    \n    while remaining:\n        if pick_min:\n            # Pick minimum (first element in sorted list)\n            result.append(remaining.pop(0))\n        else:\n            # Pick maximum (last element in sorted list)\n            result.append(remaining.pop())\n        \n        pick_min = not pick_min  # Alternate for next iteration\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/71_prompt1c", "code_candidates": [{"code": "import math\n\ndef triangle_area(a, b, c):\n    # Check if the sides form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    \n    # Calculate the area using Heron's formula\n    s = (a + b + c) / 2  # semi-perimeter\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return round(area, 2)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["6.0", "-1", "8.18", "1.73", "-1", "16.25", "-1", "0.43", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/72_prompt1c", "code_candidates": [{"code": "def is_palindrome_under_weight(q, w):\n    \"\"\"\n    Returns True if list q is palindromic and sum of its elements is <= w.\n    Otherwise returns False.\n    \n    Args:\n        q: List of numbers\n        w: Maximum allowed weight (number)\n    \n    Returns:\n        bool: True if q is palindromic and sum <= w, False otherwise\n    \"\"\"\n    # Check if list is empty\n    if not q:\n        return True\n    \n    # Check if palindromic\n    is_palindrome = q == q[::-1]\n    \n    # Check if sum is within weight limit\n    total_sum = sum(q)\n    within_weight = total_sum <= w\n    \n    return is_palindrome and within_weight", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/73_prompt1c", "code_candidates": [{"code": "def min_changes_to_palindrome(arr):\n    \"\"\"\n    Find the minimum number of elements that need to be changed to make the array palindromic.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        int: Minimum number of changes needed to make array palindromic\n    \"\"\"\n    if not arr:\n        return 0\n    \n    changes = 0\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/74_prompt1c", "code_candidates": [{"code": "def list_with_fewer_chars(list1: list[str], list2: list[str]) -> list[str]:\n    \"\"\"\n    Compare total character counts between two lists of strings and return the list with fewer characters.\n    If character counts are equal, return the first list.\n    \n    Args:\n        list1: First list of strings\n        list2: Second list of strings\n        \n    Returns:\n        The list with fewer total characters, or list1 if equal\n    \"\"\"\n    # Calculate total character count for each list\n    count1 = sum(len(s) for s in list1)\n    count2 = sum(len(s) for s in list2)\n    \n    # Return the list with fewer characters, or list1 if equal\n    return list1 if count1 <= count2 else list2", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[]", "['hi', 'hi']", "['hi', 'admin']", "['4']", "['hI', 'Hi']", "['hI', 'hi', 'hi']", "['hi', 'admin']", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/75_prompt1c", "code_candidates": [{"code": "def is_multiply_prime(n):\n    if n < 2:\n        return False\n    \n    prime_factors = []\n    d = 2\n    \n    while d * d <= n:\n        while n % d == 0:\n            prime_factors.append(d)\n            n //= d\n        d += 1\n    \n    if n > 1:\n        prime_factors.append(n)\n    \n    return len(prime_factors) == 3", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["False", "True", "True", "False", "True", "True", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/76_prompt1c", "code_candidates": [{"code": "def is_power(x: int, n: int) -> bool:\n    # Handle special cases\n    if n == 0:\n        return x == 0 or x == 1\n    if n == 1:\n        return x == 1\n    if n == -1:\n        return x == 1 or x == -1\n    if x == 0:\n        return n == 0\n    if x == 1:\n        return True\n    \n    # For positive n and x\n    if n > 0 and x > 0:\n        current = 1\n        while current < x:\n            current *= n\n        return current == x\n    \n    # For negative n and positive x\n    if n < 0 and x > 0:\n        current = 1\n        while current < x:\n            current *= n\n            if current < 1:  # If we go below 1, it's not a valid power\n                return False\n        return current == x\n    \n    # For negative n and negative x\n    if n < 0 and x < 0:\n        current = 1\n        while current > x:\n            current *= n\n            if current > -1:  # If we go above -1, it's not a valid power\n                return False\n        return current == x\n    \n    # For positive n and negative x\n    if n > 0 and x < 0:\n        return False\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/77_prompt1c", "code_candidates": [{"code": "def iscube(n):\n    if n == 0:\n        return True\n    \n    # Handle positive numbers\n    if n > 0:\n        cube_root = round(n ** (1/3))\n        return cube_root ** 3 == n\n    \n    # Handle negative numbers\n    else:\n        cube_root = round((-n) ** (1/3))\n        return (-cube_root) ** 3 == n", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/78_prompt1c", "code_candidates": [{"code": "def hex_key(num):\n    # Define hexadecimal digits that represent prime numbers\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count prime hexadecimal digits in the input string\n    count = 0\n    for digit in num:\n        if digit in prime_hex_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/79_prompt1c", "code_candidates": [{"code": "def decimal_to_binary(decimal: int) -> str:\n    binary = bin(decimal)[2:]\n    return f\"db{binary}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/80_prompt1c", "code_candidates": [{"code": "def is_happy(s):\n    # Strings with length less than 3 are not happy\n    if len(s) < 3:\n        return False\n    \n    # Check every group of 3 consecutive characters\n    for i in range(len(s) - 2):\n        # Get the current group of 3 characters\n        group = s[i:i+3]\n        # Check if all characters in the group are distinct\n        if len(set(group)) != 3:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "False", "True", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/81_prompt1c", "code_candidates": [{"code": "def gpa_to_letter_grade(gpa: float) -> str:\n    if gpa < 0.0 or gpa > 4.0:\n        raise ValueError(\"GPA must be between 0.0 and 4.0\")\n    \n    if gpa == 0.0:\n        return 'E'\n    elif gpa > 3.7:\n        return 'A+'\n    elif gpa > 3.3:\n        return 'A'\n    elif gpa > 3.0:\n        return 'A-'\n    elif gpa > 2.7:\n        return 'B+'\n    elif gpa > 2.3:\n        return 'B'\n    elif gpa > 2.0:\n        return 'B-'\n    elif gpa > 1.7:\n        return 'C+'\n    elif gpa > 1.3:\n        return 'C'\n    elif gpa > 1.0:\n        return 'C-'\n    elif gpa > 0.7:\n        return 'D+'\n    elif gpa > 0.0:\n        return 'D'\n    else:\n        return 'E'", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/82_prompt1c", "code_candidates": [{"code": "def is_prime_length(s: str) -> bool:\n    length = len(s)\n    \n    # Handle edge cases: empty string or length 1\n    if length < 2:\n        return False\n    \n    # Check if length is prime\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/84_prompt1c", "code_candidates": [{"code": "def sum_digits_to_binary(N: int) -> str:\n    # Calculate the sum of digits\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    return bin(digit_sum)[2:]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "110", "1100", "1001", "10010"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/85_prompt1c", "code_candidates": [{"code": "def add(lst):\n    \"\"\"\n    Return the sum of even elements that are located at odd indices.\n    \n    Args:\n        lst: A non-empty list of integers\n        \n    Returns:\n        int: Sum of even elements at odd indices\n    \"\"\"\n    total = 0\n    for i in range(1, len(lst), 2):  # Start at index 1, step by 2 to get odd indices\n        if lst[i] % 2 == 0:  # Check if element is even\n            total += lst[i]\n    return total", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["88", "122", "0", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/86_prompt1c", "code_candidates": [{"code": "def anti_shuffle(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    anti_shuffle('Hi') returns 'iH'\n    anti_shuffle('hello') returns 'ollhe'\n    anti_shuffle('Hello World!!!') returns 'roldW!!! olleH'\n    \"\"\"\n    words = s.split(' ')\n    ordered_words = []\n    \n    for word in words:\n        # Sort characters in the word by ASCII value\n        sorted_chars = sorted(word)\n        # Join the sorted characters back into a string\n        ordered_word = ''.join(sorted_chars)\n        ordered_words.append(ordered_word)\n    \n    # Join all ordered words back with spaces\n    return ' '.join(ordered_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello !!!Wdlor", "", ".Hi My aemn is Meirst .Rboot How aer ?ouy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/87_prompt1c", "code_candidates": [{"code": "def find_integer_coordinates(matrix, x):\n    \"\"\"\n    Find all occurrences of integer x in a 2D nested list and return coordinates\n    as (row, column) tuples, sorted by row ascending then column descending\n    within each row.\n    \n    Args:\n        matrix: 2D nested list of integers\n        x: integer to search for\n        \n    Returns:\n        List of (row, column) tuples sorted by row ascending then column descending\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n    \n    coordinates = []\n    \n    for row_idx, row in enumerate(matrix):\n        if not row:  # Skip empty rows\n            continue\n        for col_idx, value in enumerate(row):\n            if value == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    \n    return coordinates", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/88_prompt1c", "code_candidates": [{"code": "def sort_array(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [5, 4, 3, 2, 1, 0]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [0, 1, 2, 3, 4, 5, 6]\n    \"\"\"\n    if not array:\n        return []\n    \n    if len(array) == 1:\n        return array[:]\n    \n    first = array[0]\n    last = array[-1]\n    sum_first_last = first + last\n    \n    # Create a copy of the array to avoid modifying the original\n    result = array[:]\n    \n    if sum_first_last % 2 == 1:  # odd sum - ascending order\n        result.sort()\n    else:  # even sum - descending order\n        result.sort(reverse=True)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/89_prompt1c", "code_candidates": [{"code": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'kl'\n    encrypt('asdfghjkl') returns 'cvfiknqrs'\n    encrypt('gf') returns 'ji'\n    encrypt('et') returns 'gv'\n    \"\"\"\n    shift = 2 * 2  # shift by 4 positions\n    result = []\n    \n    for char in s:\n        if char.isalpha():\n            # Determine if uppercase or lowercase\n            base = ord('A') if char.isupper() else ord('a')\n            # Apply rotation with wrap-around\n            rotated = (ord(char) - base + shift) % 26 + base\n            result.append(chr(rotated))\n        else:\n            # Non-alphabetic characters remain unchanged\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["lm", "ewhjklnop", "kj", "ix"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/90_prompt1c", "code_candidates": [{"code": "def second_smallest_unique(numbers):\n    \"\"\"\n    Returns the second smallest unique element from a list of integers.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        The second smallest unique element, or None if there are fewer than two unique elements\n    \"\"\"\n    if not numbers:\n        return None\n    \n    # Get unique elements and sort them\n    unique_numbers = sorted(set(numbers))\n    \n    # Check if we have at least 2 unique elements\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest unique element\n    return unique_numbers[1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "2", "None", "None", "1", "None", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/91_prompt1c", "code_candidates": [{"code": "def is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> is_bored(\"Hello world\")\n    1\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    3\n    \"\"\"\n    if not S:\n        return 0\n    \n    # Split by sentence delimiters\n    import re\n    sentences = re.split(r'[.?!]', S)\n    \n    count = 0\n    for sentence in sentences:\n        # Strip whitespace and check if sentence is not empty\n        sentence = sentence.strip()\n        if sentence and sentence.startswith('I'):\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 2, 3, 4, 5], "case_status": ["0", "1", "1", "0", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/92_prompt1c", "code_candidates": [{"code": "def check_sum_of_two(a: float, b: float, c: float) -> bool:\n    # Check if all numbers are integers (including floats that represent whole numbers)\n    def is_integer_value(x: float) -> bool:\n        return isinstance(x, (int, float)) and (x.is_integer() if isinstance(x, float) else isinstance(x, int))\n    \n    # Verify all inputs are integers\n    if not all(is_integer_value(x) for x in [a, b, c]):\n        return False\n    \n    # Convert to int for easier comparison\n    a, b, c = int(a), int(b), int(c)\n    \n    # Check if one number equals the sum of the other two\n    return a == b + c or b == a + c or c == a + b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["True", "False", "False", "False", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/93_prompt1c", "code_candidates": [{"code": "def encode_message(message: str) -> str:\n    if not message:\n        return message\n    \n    # Step 1: Swap case of all letters\n    swapped = message.swapcase()\n    \n    # Step 2: Replace vowels with letters 2 positions ahead\n    vowels = 'aeiouAEIOU'\n    result = []\n    \n    for char in swapped:\n        if char.lower() in 'aeiou':\n            # Get the character 2 positions ahead in the alphabet\n            if char.islower():\n                # For lowercase vowels\n                new_char = chr((ord(char) - ord('a') + 2) % 26 + ord('a'))\n            else:\n                # For uppercase vowels\n                new_char = chr((ord(char) - ord('A') + 2) % 26 + ord('A'))\n            result.append(new_char)\n        else:\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["tgst", "mWDCSKR", "ygs", "tHKS KS C MGSSCGG", "k dQnT kNqW wHcT Tq wRkTg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/94_prompt1c", "code_candidates": [{"code": "def skjkasdkd(lst):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    def digit_sum(n):\n        return sum(int(digit) for digit in str(n))\n    \n    primes = [num for num in lst if is_prime(num)]\n    \n    if not primes:\n        return 0\n    \n    largest_prime = max(primes)\n    return digit_sum(largest_prime)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["10", "25", "13", "11", "3", "7", "19", "19", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/95_prompt1c", "code_candidates": [{"code": "def check_keys_case(d: dict) -> bool:\n    if not d:\n        return False\n    \n    if not all(isinstance(key, str) for key in d.keys()):\n        return False\n    \n    keys = list(d.keys())\n    all_lower = all(key.islower() for key in keys)\n    all_upper = all(key.isupper() for key in keys)\n    \n    return all_lower or all_upper", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "False", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/96_prompt1c", "code_candidates": [{"code": "def primes_less_than_n(n: int) -> list[int]:\n    if n <= 1:\n        return []\n    \n    # Special case: if n is 2, return [1] since 1 is considered prime\n    if n == 2:\n        return [1]\n    \n    # Sieve of Eratosthenes to find primes less than n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Collect primes less than n\n    primes = []\n    for i in range(1, n):  # Start from 1 since 1 is considered prime\n        if is_prime[i]:\n            primes.append(i)\n    \n    return primes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/97_prompt1c", "code_candidates": [{"code": "def multiply(a: int, b: int) -> int:\n    \"\"\"\n    Returns the product of the unit digits of two integers.\n    For negative numbers, uses the absolute value to determine the unit digit.\n    \n    Args:\n        a: First integer\n        b: Second integer\n    \n    Returns:\n        Product of the unit digits of a and b\n    \"\"\"\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/98_prompt1c", "code_candidates": [{"code": "def count_upper(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper('aBCdEf') returns 2\n    count_upper('abcdefg') returns 1\n    count_upper('dBBE') returns 1\n    \"\"\"\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    for i in range(0, len(s), 2):  # iterate through even indices\n        if s[i] in uppercase_vowels:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "0", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/99_prompt1c", "code_candidates": [{"code": "import math\nfrom typing import Union\n\ndef round_to_nearest(number_str: str) -> int:\n    \"\"\"\n    Takes a string representing a number and returns the closest integer to it.\n    For equidistant cases, rounds away from zero.\n    For non-equidistant cases, rounds to the nearest integer.\n    Raises ValueError for invalid input.\n    \n    Args:\n        number_str: String representation of a number\n        \n    Returns:\n        Closest integer according to rounding rules\n        \n    Raises:\n        ValueError: If input string is not a valid number\n    \"\"\"\n    try:\n        num = float(number_str)\n    except ValueError:\n        raise ValueError(\"Invalid input: not a valid number\")\n    \n    # Handle special cases\n    if math.isnan(num) or math.isinf(num):\n        raise ValueError(\"Invalid input: not a finite number\")\n    \n    # Check if it's exactly halfway\n    if num % 1 == 0.5 or num % 1 == -0.5:\n        # Round away from zero\n        if num > 0:\n            return math.ceil(num)\n        else:\n            return math.floor(num)\n    else:\n        # Regular rounding\n        return round(num)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["10", "15", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/100_prompt1c", "code_candidates": [{"code": "def build_stone_levels(n: int) -> list[int]:\n    if n <= 0:\n        return []\n    \n    result = []\n    current = n\n    \n    while current > 0:\n        result.append(current)\n        current -= 2\n    \n    # If we stopped at a negative number, we need to remove it\n    if result and result[-1] < 0:\n        result.pop()\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[3, 1]", "[4, 2]", "[5, 3, 1]", "[6, 4, 2]", "[8, 6, 4, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/101_prompt1c", "code_candidates": [{"code": "def words_string(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"six\"]\n    \"\"\"\n    if not s:\n        return []\n    \n    # Split by comma first, then by space, and filter out empty strings\n    parts = s.split(',')\n    words = []\n    for part in parts:\n        words.extend(part.split())\n    \n    # Return the last word\n    return [words[-1]] if words else []", "index": 0, "passed_case": [4], "case_status": ["['John']", "['six']", "['name']", "['six']", "[]", "['gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/102_prompt1c", "code_candidates": [{"code": "def largest_even_in_range(x: int, y: int) -> int:\n    # Ensure x is the lower bound and y is the upper bound\n    if x > y:\n        x, y = y, x\n    \n    # Start from the upper bound and work backwards to find the largest even number\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    \n    # If no even number is found, return -1\n    return -1", "index": 0, "passed_case": [0, 2, 4, 6, 7], "case_status": ["14", "12", "12354", "5234", "28", "26", "-1", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/103_prompt1c", "code_candidates": [{"code": "def rounded_avg(n, m):\n    if n > m:\n        return -1\n    \n    # Calculate the sum of integers from n to m\n    total = sum(range(n, m + 1))\n    # Calculate the count of integers\n    count = m - n + 1\n    # Calculate the average and round to nearest integer\n    avg = round(total / count)\n    # Convert to binary and return\n    return bin(avg)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["0b11", "0b1010", "0b1111001010", "0b1111100100", "0b1011000010", "0b101101110", "0b110101101", "0b1001110010", "0b11010111", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/104_prompt1c", "code_candidates": [{"code": "def odd_digit_elements(x):\n    \"\"\"\n    Return a sorted list of all elements that contain only odd digits (1,3,5,7,9).\n    \n    Args:\n        x: List of positive integers\n        \n    Returns:\n        List of integers containing only odd digits, sorted in increasing order\n    \"\"\"\n    odd_digits = {'1', '3', '5', '7', '9'}\n    result = []\n    \n    for num in x:\n        if all(str(num) != '0' and digit in odd_digits for digit in str(num)):\n            result.append(num)\n    \n    return sorted(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 15, 33]", "[]", "[111, 151]", "[31, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/105_prompt1c", "code_candidates": [{"code": "def filter_sort_reverse_translate(numbers):\n    # Filter numbers between 1 and 9 inclusive\n    filtered = [num for num in numbers if 1 <= num <= 9]\n    \n    # Sort in ascending order\n    filtered.sort()\n    \n    # Reverse the array\n    filtered.reverse()\n    \n    # Replace each digit with its corresponding name\n    digit_names = {\n        1: 'One',\n        2: 'Two',\n        3: 'Three',\n        4: 'Four',\n        5: 'Five',\n        6: 'Six',\n        7: 'Seven',\n        8: 'Eight',\n        9: 'Nine'\n    }\n    \n    result = [digit_names[num] for num in filtered]\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/106_prompt1c", "code_candidates": [{"code": "def f(n):\n    if n == 0:\n        return []\n    \n    result = []\n    for i in range(n):\n        if i % 2 == 0:  # even index - factorial\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:  # odd index - sum from 1 to i\n            sum_val = sum(range(1, i + 1))\n            result.append(sum_val)\n    \n    return result", "index": 0, "passed_case": [2], "case_status": ["[1, 1, 2, 6, 24]", "[1, 1, 2, 6, 24, 15, 720]", "[1]", "[1, 1, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/107_prompt1c", "code_candidates": [{"code": "def even_odd_palindrome(n):\n    def is_palindrome(num):\n        s = str(num)\n        return s == s[::-1]\n    \n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/108_prompt1c", "code_candidates": [{"code": "def count_positive_digit_sums(numbers):\n    \"\"\"\n    Count elements where sum of digits >= 0, with negative numbers having their first digit treated as negative.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        int: Count of numbers with digit sum >= 0\n    \"\"\"\n    def digit_sum(n):\n        \"\"\"Calculate sum of digits with first digit negative for negative numbers.\"\"\"\n        if n == 0:\n            return 0\n        \n        # Convert to string to easily access digits\n        s = str(abs(n))\n        digits = [int(d) for d in s]\n        \n        # If original number was negative, make first digit negative\n        if n < 0:\n            digits[0] = -digits[0]\n            \n        return sum(digits)\n    \n    count = 0\n    for num in numbers:\n        if digit_sum(num) >= 0:\n            count += 1\n            \n    return count", "index": 0, "passed_case": [0, 2, 4, 7], "case_status": ["0", "1", "6", "6", "4", "6", "2", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/109_prompt1c", "code_candidates": [{"code": "def can_sort_by_right_shifts(arr):\n    if not arr:\n        return True\n    \n    n = len(arr)\n    break_points = 0\n    break_index = -1\n    \n    # Count break points where arr[i] > arr[i+1]\n    for i in range(n):\n        next_index = (i + 1) % n\n        if arr[i] > arr[next_index]:\n            break_points += 1\n            break_index = i\n    \n    # If no break points, array is already sorted\n    if break_points == 0:\n        return True\n    \n    # If more than one break point, cannot be sorted by right shifts\n    if break_points > 1:\n        return False\n    \n    # If exactly one break point, check if rotating at that point gives sorted array\n    # The array should be sorted when viewed as circular array\n    # This means the element after break point should be <= first element\n    return arr[(break_index + 1) % n] <= arr[0]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/110_prompt1c", "code_candidates": [{"code": "def exchange(lst1, lst2):\n    # Count odd numbers in lst1\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # Count even numbers in lst2\n    even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If we have enough even numbers in lst2 to replace all odd numbers in lst1\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["YES", "NO", "YES", "YES", "NO", "NO", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/111_prompt1c", "code_candidates": [{"code": "def histogram(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    histogram('a b c') == {'a': 1}\n    histogram('a b b a') == {'a': 2}\n    histogram('a b c a b') == {'a': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"\n    if not test:\n        return {}\n    \n    # Split the string and count occurrences\n    letters = test.split()\n    count_dict = {}\n    \n    for letter in letters:\n        count_dict[letter] = count_dict.get(letter, 0) + 1\n    \n    # Find the maximum count\n    max_count = max(count_dict.values())\n    \n    # Return all letters with maximum count\n    return {letter: count for letter, count in count_dict.items() if count == max_count}", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/112_prompt1c", "code_candidates": [{"code": "def remove_chars_and_check_palindrome(s: str, c: str) -> tuple:\n    # Remove all characters from s that appear in c\n    result = ''.join(char for char in s if char not in c)\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/113_prompt1c", "code_candidates": [{"code": "def count_odd_digits(strings):\n    \"\"\"\n    Given a list of strings containing only digits, return a list where each element \n    is a formatted string that indicates the count of odd digits in the corresponding \n    input string.\n    \n    Args:\n        strings: List[str] - List of strings containing only digits\n        \n    Returns:\n        List[str] - List of formatted strings with odd digit counts\n    \"\"\"\n    result = []\n    template = \"The count of odd digits is {}\"\n    \n    for string in strings:\n        odd_count = sum(1 for char in string if char in '13579')\n        result.append(template.format(odd_count))\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["['The count of odd digits is 4']", "['The count of odd digits is 1', 'The count of odd digits is 8']", "['The count of odd digits is 2', 'The count of odd digits is 3', 'The count of odd digits is 2']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/114_prompt1c", "code_candidates": [{"code": "def minSubArraySum(nums):\n    if not nums:\n        return 0\n    \n    min_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = min(nums[i], current_sum + nums[i])\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/115_prompt1c", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef count_bucket_operations(wells: List[List[int]], bucket_capacity: int) -> int:\n    \"\"\"\n    Calculate the number of bucket lowering operations needed to empty all wells.\n    \n    Args:\n        wells: A list of lists where each inner list represents a well with 0s and 1s\n               (1 represents a unit of water)\n        bucket_capacity: The capacity of each bucket\n    \n    Returns:\n        The total number of bucket operations needed to empty all wells\n    \"\"\"\n    if bucket_capacity <= 0:\n        raise ValueError(\"Bucket capacity must be positive\")\n    \n    total_operations = 0\n    \n    for well in wells:\n        water_units = sum(well)\n        if water_units > 0:\n            operations = math.ceil(water_units / bucket_capacity)\n            total_operations += operations\n    \n    return total_operations", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["6", "5", "0", "4", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/116_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef sort_by_binary_ones(arr: List[int]) -> List[int]:\n    if not arr:\n        return []\n    \n    def count_ones(n: int) -> int:\n        return bin(abs(n)).count('1')\n    \n    # Sort by number of 1s (descending), then by decimal value (ascending)\n    return sorted(arr, key=lambda x: (-count_ones(x), x))", "index": 0, "passed_case": [3, 6, 7], "case_status": ["[3, 5, 1, 2, 4]", "[-6, -5, -3, -4, -2]", "[3, 1, 2, 4, 0]", "[]", "[77, 7, 3, 3, 5, 5, 5, 2, 2, 4, 4]", "[44, 3, 5, 6, 12, 32]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/117_prompt1c", "code_candidates": [{"code": "def select_words(s, n):\n    if not s:\n        return []\n    \n    vowels = set('aeiouAEIOU')\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['little']", "['Mary', 'lamb']", "[]", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/118_prompt1c", "code_candidates": [{"code": "def find_closest_vowel_between_consonants(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n    \n    vowels = \"aeiouAEIOU\"\n    \n    # Process from right to left, excluding first and last characters\n    for i in range(len(word) - 2, 0, -1):\n        char = word[i]\n        left_char = word[i - 1]\n        right_char = word[i + 1]\n        \n        # Check if current character is a vowel\n        if char in vowels:\n            # Check if both adjacent characters are consonants\n            if left_char not in vowels and right_char not in vowels:\n                return char\n    \n    return \"\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["u", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/119_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef is_balanced(s: str) -> bool:\n    balance = 0\n    for char in s:\n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0\n\ndef check_balanced_concatenation(lst: List[str]) -> str:\n    if not lst or len(lst) != 2:\n        return 'No'\n    \n    s1, s2 = lst[0], lst[1]\n    \n    # Check both concatenation orders\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "Yes", "No", "No", "No", "Yes", "Yes"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/120_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef k_smallest_elements(arr: List[int], k: int) -> List[int]:\n    \"\"\"\n    Return the k smallest elements from the array, sorted in ascending order.\n    \n    Args:\n        arr: List of integers\n        k: Number of smallest elements to return\n        \n    Returns:\n        List of k smallest elements sorted in ascending order\n    \"\"\"\n    # Handle edge cases\n    if not arr or k <= 0:\n        return []\n    \n    # If k is greater than array length, return all elements sorted\n    if k >= len(arr):\n        return sorted(arr)\n    \n    # Sort array and return first k elements\n    return sorted(arr)[:k]", "index": 0, "passed_case": [0, 5, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[-4, 4]", "[-3]", "[-123, -3, 0]", "[-123, -3, 0, 1]", "[-13, -8, 0, 0, 3, 5, 15]", "[-10, -1]", "[-7]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/121_prompt1c", "code_candidates": [{"code": "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 1\n    solution([3, 3, 3, 3, 3]) ==> 3\n    solution([30, 13, 24, 321]) ==>30\n    \"\"\"\n    total = 0\n    for i in range(0, len(lst), 2):  # iterate through even indices\n        if lst[i] % 2 == 1:  # check if the element is odd\n            total += lst[i]\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["9", "0", "5", "0", "23", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/122_prompt1c", "code_candidates": [{"code": "def sum_two_digit_elements(arr, k):\n    \"\"\"\n    Returns the sum of elements with at most two digits (0-99) from the first k elements of arr.\n    \n    Args:\n        arr: List of integers\n        k: Integer representing how many elements from the start to consider\n        \n    Returns:\n        Integer sum of elements in range [0, 99] from first k elements\n    \"\"\"\n    total = 0\n    for i in range(min(k, len(arr))):\n        if 0 <= arr[i] <= 99:\n            total += arr[i]\n    return total", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["1", "0", "125", "24", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/123_prompt1c", "code_candidates": [{"code": "def collatz_odds(n: int) -> list[int]:\n    \"\"\"\n    Return a sorted list of all odd numbers in the Collatz sequence starting with n.\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        A sorted list of all odd numbers in the Collatz sequence\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    odd_numbers = set()\n    current = n\n    \n    while current != 1:\n        if current % 2 == 1:  # odd number\n            odd_numbers.add(current)\n            current = 3 * current + 1\n        else:  # even number\n            current = current // 2\n    \n    # Add 1 since the sequence always ends with 1\n    odd_numbers.add(1)\n    \n    return sorted(list(odd_numbers))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/124_prompt1c", "code_candidates": [{"code": "def is_valid_date(date_string):\n    \"\"\"\n    Validates a date string in mm-dd-yyyy format.\n    \n    Args:\n        date_string (str): Date string to validate\n        \n    Returns:\n        bool: True if valid date, False otherwise\n    \"\"\"\n    # Check if the format matches mm-dd-yyyy\n    if not isinstance(date_string, str) or len(date_string) != 10:\n        return False\n    \n    if date_string[2] != '-' or date_string[5] != '-':\n        return False\n    \n    try:\n        month_str, day_str, year_str = date_string.split('-')\n        \n        # Check if all parts are numeric and have correct lengths\n        if not (month_str.isdigit() and day_str.isdigit() and year_str.isdigit()):\n            return False\n            \n        if len(month_str) != 2 or len(day_str) != 2 or len(year_str) != 4:\n            return False\n            \n        month = int(month_str)\n        day = int(day_str)\n        year = int(year_str)\n        \n    except (ValueError, IndexError):\n        return False\n    \n    # Validate month range\n    if month < 1 or month > 12:\n        return False\n    \n    # Validate day based on month\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Adjust February for leap year\n    if is_leap_year(year):\n        days_in_month[1] = 29\n    \n    max_days = days_in_month[month - 1]\n    \n    if day < 1 or day > max_days:\n        return False\n    \n    return True\n\ndef is_leap_year(year):\n    \"\"\"\n    Determines if a year is a leap year.\n    \n    Args:\n        year (int): Year to check\n        \n    Returns:\n        bool: True if leap year, False otherwise\n    \"\"\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/125_prompt1c", "code_candidates": [{"code": "def process_string(s):\n    if not s:\n        return []\n    \n    if ' ' in s:\n        return s.split(' ')[0]\n    elif ',' in s:\n        return s.split(',')[::-1][0]\n    else:\n        count = 0\n        for char in s:\n            if char.islower():\n                ord_val = ord(char)\n                if ord_val % 2 == 1:\n                    count += 1\n        return count", "index": 0, "passed_case": [4], "case_status": ["Hello", "world!", "Hello", "Hello,Hello,world", "3", "3", "3", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/126_prompt1c", "code_candidates": [{"code": "def is_sorted(lst):\n    \"\"\"\n    Determine if a list is sorted in non-decreasing order.\n    \n    Args:\n        lst: A list of comparable elements\n        \n    Returns:\n        bool: True if the list is sorted in non-decreasing order, False otherwise\n    \"\"\"\n    # Empty lists and single-element lists are considered sorted\n    if len(lst) <= 1:\n        return True\n    \n    # Check each adjacent pair of elements\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i-1]:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/127_prompt1c", "code_candidates": [{"code": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef check_intersection_prime(a, b, c, d):\n    # Find intersection of intervals [a, b] and [c, d]\n    start = max(a, c)\n    end = min(b, d)\n    \n    # If no intersection\n    if start > end:\n        return 'NO'\n    \n    # Calculate length of intersection\n    length = end - start + 1\n    \n    # Check if length is prime\n    if is_prime(length):\n        return 'YES'\n    else:\n        return 'NO'", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/128_prompt1c", "code_candidates": [{"code": "from typing import List, Optional\n\ndef signed_sum_abs(numbers: List[float]) -> Optional[float]:\n    if not numbers:\n        return None\n    \n    sign_product = 1\n    abs_sum = 0\n    \n    for num in numbers:\n        abs_sum += abs(num)\n        if num > 0:\n            sign_product *= 1\n        elif num < 0:\n            sign_product *= -1\n        else:  # num == 0\n            sign_product = 0\n            break\n    \n    return sign_product * abs_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["-9", "0", "-10", "None", "20", "4", "-4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/129_prompt1c", "code_candidates": [{"code": "def minPath(grid, k):\n    if not grid or not grid[0] or k <= 0:\n        return []\n    \n    n = len(grid)\n    if k == 1:\n        # Find the maximum value in the grid\n        max_val = max(max(row) for row in grid)\n        return [max_val]\n    \n    # Directions for moving to neighbors (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Find all possible starting positions\n    # We want to start from the cell with the smallest value to get the minimum path\n    min_val = min(min(row) for row in grid)\n    \n    # Find all positions with the minimum value\n    start_positions = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == min_val:\n                start_positions.append((i, j))\n    \n    # For k=1, we already handled it above\n    # For k>1, we need to find the lexicographically smallest path\n    # We'll use a BFS approach to explore all paths of length k\n    # and keep track of the minimum one\n    \n    min_path = None\n    \n    # BFS with priority queue approach\n    from heapq import heappush, heappop\n    \n    # Priority queue: (path_tuple, current_row, current_col, steps_taken)\n    pq = []\n    \n    # Initialize with all positions having the minimum value\n    for r, c in start_positions:\n        path = [grid[r][c]]\n        heappush(pq, (path, r, c, 1))\n    \n    while pq:\n        path, r, c, steps = heappop(pq)\n        \n        if steps == k:\n            if min_path is None or path < min_path:\n                min_path = path\n            continue\n            \n        # If we already have a better path, skip\n        if min_path is not None and path > min_path:\n            continue\n            \n        # Explore neighbors\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < n:\n                new_path = path + [grid[nr][nc]]\n                heappush(pq, (new_path, nr, nc, steps + 1))\n    \n    return min_path if min_path is not None else []", "index": 0, "passed_case": [0, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[1, 2, 1]", "[9]", "[1, 2, 1, 2]", "[1, 10, 1, 10, 1, 10, 1]", "[1, 7, 1, 7, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1]", "[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]", "[1, 3, 1, 3, 1, 3, 1, 3]", "[1, 5, 1, 5, 1, 5, 1, 5]", "[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/130_prompt1c", "code_candidates": [{"code": "def tri(n):\n    if n < 0:\n        return []\n    \n    sequence = [0] * (n + 1)\n    sequence[0] = 1\n    if n >= 1:\n        sequence[1] = 1\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence[i] = 1 + i // 2\n        else:\n            sequence[i] = sequence[i-1] + sequence[i-2] + sequence[i-3]\n    \n    return sequence", "index": 0, "passed_case": [8], "case_status": ["[1, 1, 2, 4]", "[1, 1, 2, 4, 3]", "[1, 1, 2, 4, 3, 9]", "[1, 1, 2, 4, 3, 9, 4]", "[1, 1, 2, 4, 3, 9, 4, 16]", "[1, 1, 2, 4, 3, 9, 4, 16, 5]", "[1, 1, 2, 4, 3, 9, 4, 16, 5, 25]", "[1, 1, 2, 4, 3, 9, 4, 16, 5, 25, 6, 36, 7, 49, 8, 64, 9, 81, 10, 100, 11]", "[1]", "[1, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/131_prompt1c", "code_candidates": [{"code": "def digits(n):\n    product = 1\n    has_odd = False\n    \n    for digit in str(n):\n        d = int(digit)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    \n    return product if has_odd else 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["5", "5", "5", "315", "2625", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/132_prompt1c", "code_candidates": [{"code": "def is_nested(string):\n    \"\"\"\n    Check if there is a valid subsequence of brackets where at least one bracket is nested.\n    \n    Args:\n        string: A string containing only square brackets\n        \n    Returns:\n        bool: True if there is a nested subsequence, False otherwise\n    \"\"\"\n    # Count opening and closing brackets\n    open_count = 0\n    close_count = 0\n    \n    # Track if we have a valid nested structure\n    max_depth = 0\n    current_depth = 0\n    \n    # Process each character\n    for char in string:\n        if char == '[':\n            open_count += 1\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ']':\n            close_count += 1\n            current_depth -= 1\n            \n            # If we close more than we opened, it's invalid\n            if current_depth < 0:\n                return False\n    \n    # Valid brackets must have equal counts and depth > 1 for nesting\n    if open_count != close_count:\n        return False\n        \n    # For a nested structure, we need at least depth of 2\n    # But we also need to check if there's a valid subsequence with nesting\n    # A subsequence is nested if we can find a valid sequence where depth > 1\n    \n    # Reset counters for second pass\n    current_depth = 0\n    nested_found = False\n    \n    # Check if there's any nesting in the sequence\n    for char in string:\n        if char == '[':\n            current_depth += 1\n            if current_depth > 1:\n                nested_found = True\n        elif char == ']':\n            current_depth -= 1\n    \n    # If we found nesting in the sequence, return True\n    if nested_found:\n        return True\n    \n    # Special case: if we have a valid sequence with depth 1 but multiple pairs\n    # like \"[][]\", this should return True\n    # But if we have \"[]\", this should also return True\n    # And if we have \"[[][]]\", this should return False (no nesting in subsequence)\n    \n    # Let's re-evaluate the problem:\n    # We need to find if there exists a subsequence that is nested\n    # A subsequence is nested if it has a depth > 1\n    \n    # Actually, let's think differently:\n    # The examples suggest that:\n    # - \"[[]]\" -> False (valid but no nested subsequence)\n    # - \"[]]]]]]][[[[[]\" -> True (has nested structure)\n    # - \"[][]\" -> True (has valid subsequence with nesting)\n    # - \"[]\" -> True (valid subsequence)\n    # - \"[[][]]\" -> False (no nested subsequence)\n    # - \"[[]][[\" -> False (no nested subsequence)\n    \n    # Looking at the examples more carefully:\n    # We want to check if there exists a subsequence that is properly nested\n    # This means we can find a valid subsequence where at least one bracket is nested\n    \n    # Let's check if we have a valid bracket sequence with nesting\n    # A valid nested subsequence means we can find a valid subsequence with depth > 1\n    \n    # Reset and check if we can form a valid nested subsequence\n    stack = []\n    max_depth = 0\n    \n    for char in string:\n        if char == '[':\n            stack.append(char)\n            max_depth = max(max_depth, len(stack))\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                # Unmatched closing bracket\n                return False\n    \n    # If we have a valid sequence and max depth > 1, we have nesting\n    # But we also need to check if there's a valid subsequence that's nested\n    \n    # Actually, let's re-read the examples:\n    # \"[[]]\" -> False: This is a valid sequence but no subsequence is nested\n    # \"[]]]]]]][[[[[]\" -> True: This has nested structure\n    # \"[][]\" -> True: This has valid subsequences\n    # \"[]\" -> True: This is valid\n    # \"[[][]]\" -> False: This is valid but no nested subsequence\n    # \"[[]][[\" -> False: This is not valid\n    \n    # The key insight: we want to check if there exists a valid subsequence\n    # where at least one bracket is nested (i.e., inside another pair)\n    \n    # Let's approach this differently:\n    # We need to find if there's a valid subsequence with nesting\n    \n    # If we have a valid bracket sequence, we can check if it has nesting\n    # by tracking depth\n    \n    # But the examples suggest we're looking for a subsequence that is nested\n    # Let's just check if we have a valid sequence with nesting\n    \n    # Reset for final check\n    depth = 0\n    max_depth = 0\n    \n    for char in string:\n        if char == '[':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif char == ']':\n            depth -= 1\n    \n    # If we have valid brackets and max depth > 1, we have nesting\n    # But we also need to make sure we can form a valid subsequence\n    # which means we need equal brackets\n    \n    if open_count != close_count:\n        return False\n    \n    # If we have valid brackets and max depth > 1, we have nesting\n    return max_depth > 1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13], "case_status": ["True", "False", "False", "False", "True", "False", "True", "False", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/133_prompt1c", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef sum_squares(lst: List[float]) -> int:\n    return sum(math.ceil(x) ** 2 for x in lst)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/134_prompt1c", "code_candidates": [{"code": "def is_last_char_non_word_alpha(s: str) -> bool:\n    if not s:\n        return False\n    \n    # Find the last non-space character\n    last_char_index = -1\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] != ' ':\n            last_char_index = i\n            break\n    \n    # If no non-space character found, return False\n    if last_char_index == -1:\n        return False\n    \n    # Check if the last non-space character is alphabetical\n    if not s[last_char_index].isalpha():\n        return False\n    \n    # Check if it's the first character or preceded by a space\n    if last_char_index == 0:\n        return True\n    \n    # Check if preceded by a space\n    return s[last_char_index - 1] == ' '", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 8], "case_status": ["False", "True", "False", "True", "False", "False", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/135_prompt1c", "code_candidates": [{"code": "def find_last_descent_index(arr):\n    \"\"\"\n    Returns the largest index where an element is strictly less than the element \n    immediately preceding it. Returns -1 if no such index exists.\n    \n    Args:\n        arr: List of numbers\n        \n    Returns:\n        int: Largest descent index, or -1 if none exists\n    \"\"\"\n    if len(arr) < 2:\n        return -1\n    \n    last_descent_index = -1\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            last_descent_index = i\n    \n    return last_descent_index", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "-1", "2", "4", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/136_prompt1c", "code_candidates": [{"code": "def largest_smallest_integers(lst):\n    largest_negative = None\n    smallest_positive = None\n    \n    for num in lst:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n    \n    return (largest_negative, smallest_positive)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/137_prompt1c", "code_candidates": [{"code": "def compare_values(val1, val2):\n    \"\"\"\n    Compare two values and return the larger one in its original type.\n    \n    Args:\n        val1, val2: integers, floats, or strings representing real numbers\n        \n    Returns:\n        The larger value in its original type, or None if equal\n        \n    Raises:\n        TypeError: if either value is None or types are incompatible\n        ValueError: if a string cannot be parsed as a number\n    \"\"\"\n    if val1 is None or val2 is None:\n        raise TypeError(\"Cannot compare None values\")\n    \n    def parse_value(val):\n        if isinstance(val, (int, float)):\n            return float(val)\n        elif isinstance(val, str):\n            # Replace comma with dot for decimal separator\n            normalized_str = val.replace(',', '.')\n            try:\n                return float(normalized_str)\n            except ValueError:\n                raise ValueError(f\"Cannot parse '{val}' as a number\")\n        else:\n            raise TypeError(f\"Unsupported type: {type(val)}\")\n    \n    # Parse values for comparison\n    parsed_val1 = parse_value(val1)\n    parsed_val2 = parse_value(val2)\n    \n    # Compare and return appropriate value\n    if parsed_val1 > parsed_val2:\n        return val1\n    elif parsed_val2 > parsed_val1:\n        return val2\n    else:\n        return None", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["2", "2.5", "3", "6", "2,3", "6", "2", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/138_prompt1c", "code_candidates": [{"code": "def can_be_sum_of_4_positive_evens(n: int) -> bool:\n    \"\"\"\n    Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n    \n    Args:\n        n: An integer to evaluate\n        \n    Returns:\n        True if n can be written as sum of exactly 4 positive even numbers, False otherwise\n    \"\"\"\n    # Minimum possible sum is 8 (2+2+2+2)\n    # For n < 8, return False\n    if n < 8:\n        return False\n    \n    # A number n can be expressed as sum of 4 positive even numbers \n    # if and only if n is even and n >= 8\n    return n % 2 == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/139_prompt1c", "code_candidates": [{"code": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be greater than 0\")\n    \n    def factorial(num):\n        if num <= 1:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n    \n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/140_prompt1c", "code_candidates": [{"code": "import re\n\ndef fix_spaces(text):\n    # Replace sequences of 3 or more spaces with a single dash\n    text = re.sub(r' {3,}', '-', text)\n    # Replace remaining single spaces with underscores\n    text = text.replace(' ', '_')\n    return text", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["Example", "Mudasir_Hanif_", "Yellow_Yellow__Dirty__Fellow", "Exa-mple", "-Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/141_prompt1c", "code_candidates": [{"code": "import re\nfrom typing import List, Dict\n\ndef validate_filename(filename: str) -> str:\n    # Check for exactly one dot\n    if filename.count('.') != 1:\n        return 'No'\n    \n    # Split into prefix and suffix\n    prefix, suffix = filename.split('.')\n    \n    # Check if prefix is non-empty and starts with a letter\n    if not prefix or not prefix[0].isalpha():\n        return 'No'\n    \n    # Check if suffix is one of the allowed types\n    if suffix not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # Count digits in entire filename\n    digit_count = sum(1 for char in filename if char.isdigit())\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], "case_status": ["Yes", "No", "No", "Yes", "Yes", "No", "No", "No", "No", "No", "Yes", "No", "No", "No", "No", "No", "Yes", "Yes", "Yes", "No", "No", "No", "No", "No", "No", "No"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/142_prompt1c", "code_candidates": [{"code": "def process_list_by_index(nums):\n    \"\"\"\n    Process list elements by index: square elements at indices that are multiples of 3, \n    cube elements at indices that are multiples of 4 but not 3, leave others unchanged, \n    then return sum.\n    \n    Args:\n        nums: List of numbers\n        \n    Returns:\n        int: Sum of processed elements\n    \"\"\"\n    if not nums:\n        return 0\n    \n    total = 0\n    for i, num in enumerate(nums):\n        if i % 3 == 0:\n            # Index is multiple of 3, square the element\n            total += num ** 2\n        elif i % 4 == 0:\n            # Index is multiple of 4 but not 3, cube the element\n            total += num ** 3\n        else:\n            # Leave unchanged\n            total += num\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["6", "14", "0", "9", "-3", "0", "-126", "3030", "0", "-14196", "-1448"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/143_prompt1c", "code_candidates": [{"code": "def words_in_sentence(sentence):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["is", "go for", "there is no place", "Hi am Hussein", "go for it", "", "is"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/144_prompt1c", "code_candidates": [{"code": "def simplify(x, n):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n. The function returns True if x * n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = False\n    simplify(\"1/6\", \"2/1\") = True\n    simplify(\"7/10\", \"10/2\") = True\n    \"\"\"\n    # Parse the fractions\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    # Multiply the fractions: (x_num/x_den) * (n_num/n_den) = (x_num*n_num)/(x_den*n_den)\n    result_num = x_num * n_num\n    result_den = x_den * n_den\n    \n    # Check if the result is a whole number (denominator divides numerator evenly)\n    return result_num % result_den == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/145_prompt1c", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [1, 11, -1, -12, -11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Create list of (digit_sum, original_index, value) tuples\n    indexed_nums = [(digit_sum(num), i, num) for i, num in enumerate(nums)]\n    \n    # Sort by digit sum first, then by original index for stability\n    indexed_nums.sort(key=lambda x: (x[0], x[1]))\n    \n    # Extract just the values in the new order\n    return [num for _, _, num in indexed_nums]", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/146_prompt1c", "code_candidates": [{"code": "def count_special_numbers(numbers):\n    \"\"\"\n    Count elements that are greater than 10 and have both first and last digits as odd numbers.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        int: Count of numbers meeting all criteria\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    count = 0\n    odd_digits = {1, 3, 5, 7, 9}\n    \n    for num in numbers:\n        # Skip numbers <= 10\n        if num <= 10:\n            continue\n            \n        # Work with absolute value for negative numbers\n        abs_num = abs(num)\n        \n        # Get last digit\n        last_digit = abs_num % 10\n        \n        # Get first digit\n        first_digit = abs_num\n        while first_digit >= 10:\n            first_digit //= 10\n            \n        # Check if both first and last digits are odd\n        if first_digit in odd_digits and last_digit in odd_digits:\n            count += 1\n            \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "1", "2", "4", "3", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/147_prompt1c", "code_candidates": [{"code": "def get_max_triples(n):\n    # Create array a where a[i] = i * i - i + 1\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    \n    # Count triples where sum is divisible by 3\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "4", "36", "53361"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/148_prompt1c", "code_candidates": [{"code": "def planets_between(planet1: str, planet2: str) -> tuple:\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    try:\n        index1 = planets.index(planet1)\n        index2 = planets.index(planet2)\n    except ValueError:\n        return ()\n    \n    if index1 >= index2:\n        return ()\n    \n    return tuple(planets[index1 + 1:index2])", "index": 0, "passed_case": [0, 2, 4, 5, 6], "case_status": ["('Saturn', 'Uranus')", "()", "('Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn')", "()", "()", "()", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/149_prompt1c", "code_candidates": [{"code": "def sorted_list_sum(lst):\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort by length first, then alphabetically\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['aa']", "['AI', 'asdf', 'school']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['cc', 'dd', 'aaaa', 'bbbb']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/150_prompt1c", "code_candidates": [{"code": "def x_or_y(n, x, y):\n    if n < 2:\n        return x\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return x\n    return y", "index": 0, "passed_case": [], "case_status": ["12", "8", "5212", "52", "12", "1245", "56", "34", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/151_prompt1c", "code_candidates": [{"code": "def sum_odd_squares(numbers):\n    \"\"\"\n    Return the sum of squares of odd integers in the list.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        int: Sum of squares of odd integers\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    total = 0\n    for num in numbers:\n        # Check if the number is an integer and positive\n        if isinstance(num, int) and num > 0:\n            # Check if it's odd\n            if num % 2 == 1:\n                total += num ** 2\n        # Handle float numbers that are actually integers\n        elif isinstance(num, float) and num.is_integer() and num > 0:\n            int_num = int(num)\n            if int_num % 2 == 1:\n                total += int_num ** 2\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "25", "0", "0", "0", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/152_prompt1c", "code_candidates": [{"code": "from typing import List\n\ndef calculate_differences(game: List[int], guess: List[int]) -> List[int]:\n    \"\"\"\n    Calculate the absolute difference between corresponding elements in game and guess arrays.\n    \n    Args:\n        game: List of game scores\n        guess: List of guesses\n        \n    Returns:\n        List of absolute differences between corresponding elements\n    \"\"\"\n    return [abs(game[i] - guess[i]) for i in range(len(game))]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/153_prompt1c", "code_candidates": [{"code": "def Strongest_Extension(class_name, extensions):\n    def calculate_strength(extension):\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        return cap - sm\n    \n    strongest_ext = extensions[0]\n    strongest_strength = calculate_strength(extensions[0])\n    \n    for ext in extensions[1:]:\n        strength = calculate_strength(ext)\n        if strength > strongest_strength:\n            strongest_strength = strength\n            strongest_ext = ext\n    \n    return f\"{class_name}.{strongest_ext}\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["Watashi.eIGHt8OKe", "Boku123.YEs.WeCaNe", "__YESIMHERE.NuLl__", "K.TAR", "__HAHA.123", "YameRore.okIWILL123", "finNNalLLly.WoW", "_.Bb", "Sp.671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/154_prompt1c", "code_candidates": [{"code": "def cycpattern_check(a, b):\n    if not b:\n        return True\n    if not a:\n        return False\n    \n    # Generate all rotations of b\n    rotations = []\n    for i in range(len(b)):\n        rotations.append(b[i:] + b[:i])\n    \n    # Check if any rotation is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/155_prompt1c", "code_candidates": [{"code": "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (2, 1)\n    \"\"\"\n    # Convert to string and remove negative sign if present\n    num_str = str(abs(num))\n    \n    even_count = 0\n    odd_count = 0\n    \n    for digit_char in num_str:\n        digit = int(digit_char)\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(1, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/156_prompt1c", "code_candidates": [{"code": "def int_to_roman(num: int) -> str:\n    if not 1 <= num <= 1000:\n        raise ValueError(\"Input must be between 1 and 1000\")\n    \n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    \n    result = []\n    for i in range(len(values)):\n        count = num // values[i]\n        if count:\n            result.append(symbols[i] * count)\n            num -= values[i] * count\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/157_prompt1c", "code_candidates": [{"code": "def right_angle_triangle(a: float, b: float, c: float) -> bool:\n    # Sort the sides to identify the longest side (hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check if the sum of squares of the two shorter sides\n    # equals the square of the longest side\n    return abs(sides[0]**2 + sides[1]**2 - sides[2]**2) < 1e-10", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/158_prompt1c", "code_candidates": [{"code": "def word_with_max_unique_chars(strings):\n    if not strings:\n        return None\n    \n    max_unique = -1\n    result = None\n    \n    for string in strings:\n        unique_count = len(set(string))\n        if unique_count > max_unique or (unique_count == max_unique and (result is None or string < result)):\n            max_unique = unique_count\n            result = string\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["string", "enam", "aaaaaaa", "abc", "footbott", "gonna", "nation", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/159_prompt1c", "code_candidates": [{"code": "def eat(number, need, remaining):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    * eat(5, 6, 10) -> [11, 10]\n    * eat(4, 8, 9) -> [12, 9]\n    * eat(1, 10, 10) -> [11, 10]\n    * eat(2, 11, 5) -> [7, 5]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \"\"\"\n    # Calculate how many carrots we can actually eat\n    actual_eaten = min(need, remaining)\n    \n    # Total eaten = already eaten + newly eaten\n    total_eaten = number + actual_eaten\n    \n    # Carrots left = remaining - actual eaten\n    carrots_left = remaining\n    \n    return [total_eaten, carrots_left]", "index": 0, "passed_case": [], "case_status": ["[11, 10]", "[12, 9]", "[11, 10]", "[7, 5]", "[9, 7]", "[5, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/160_prompt1c", "code_candidates": [{"code": "def evaluate_expression(operands: list, operators: list) -> float:\n    \"\"\"\n    Evaluate an algebraic expression built from operator and operand lists.\n    \n    Args:\n        operands: List of numbers\n        operators: List of operators ('+', '-', '*', '/')\n        \n    Returns:\n        Result of the expression evaluated left to right\n        \n    Raises:\n        ValueError: If operand count is not exactly one more than operator count\n        ZeroDivisionError: If division by zero occurs\n    \"\"\"\n    if len(operands) != len(operators) + 1:\n        raise ValueError(\"Operand count must be exactly one more than operator count\")\n    \n    if not operands:\n        raise ValueError(\"Operands list cannot be empty\")\n    \n    result = operands[0]\n    \n    for i, operator in enumerate(operators):\n        operand = operands[i + 1]\n        \n        if operator == '+':\n            result += operand\n        elif operator == '-':\n            result -= operand\n        elif operator == '*':\n            result *= operand\n        elif operator == '/':\n            if operand == 0:\n                raise ZeroDivisionError(\"Division by zero\")\n            result /= operand\n        else:\n            raise ValueError(f\"Unsupported operator: {operator}\")\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/161_prompt1c", "code_candidates": [{"code": "def reverse_case(s: str) -> str:\n    # Check if string contains any letters\n    has_letters = any(c.isalpha() for c in s)\n    \n    # If no letters, return reversed string\n    if not has_letters:\n        return s[::-1]\n    \n    # Reverse case of all letters, keep non-letters unchanged\n    result = []\n    for c in s:\n        if c.isalpha():\n            # Toggle case: uppercase to lowercase and vice versa\n            if c.isupper():\n                result.append(c.lower())\n            else:\n                result.append(c.upper())\n        else:\n            result.append(c)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["aSdF", "4321", "AB", "#A@c", "#aSDFw^45", "2@6#", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/162_prompt1c", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    if text is None:\n        raise TypeError\n    if text == \"\":\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/163_prompt1c", "code_candidates": [{"code": "def find_even_numbers(a: int, b: int) -> list[int]:\n    \"\"\"\n    Return all even numbers between a and b (inclusive) in ascending order.\n    \n    Args:\n        a: First positive integer (inclusive)\n        b: Second positive integer (inclusive)\n    \n    Returns:\n        List of even numbers in ascending order, or empty list if none exist\n    \"\"\"\n    # Ensure a is the smaller number and b is the larger number\n    start, end = min(a, b), max(a, b)\n    \n    # Find the first even number >= start\n    first_even = start if start % 2 == 0 else start + 1\n    \n    # If first even number is greater than end, return empty list\n    if first_even > end:\n        return []\n    \n    # Generate all even numbers from first_even to end\n    result = []\n    current = first_even\n    while current <= end:\n        result.append(current)\n        current += 2\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10]", "[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132]", "[18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1c"}
{"name": "HumanEval/0_prompt1p", "code_candidates": [{"code": "def has_close_elements(numbers: list, threshold: float) -> bool:\n    \"\"\"\n    Check if a list of numbers contains elements that are 'close' to each other.\n    \n    Args:\n        numbers: List of numbers\n        threshold: Maximum allowed absolute difference between elements\n        \n    Returns:\n        True if any two elements are within the threshold, False otherwise\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/1_prompt1p", "code_candidates": [{"code": "def separate_parentheses_groups(s: str) -> list[str]:\n    \"\"\"\n    Separate a string containing multiple groups of nested parentheses into individual balanced groups.\n    \n    Args:\n        s: A string containing nested parentheses\n        \n    Returns:\n        A list of strings, each containing a balanced group of parentheses\n    \"\"\"\n    result = []\n    current_group = \"\"\n    balance = 0\n    \n    for char in s:\n        if char == ' ':\n            continue\n            \n        current_group += char\n        \n        if char == '(':\n            balance += 1\n        elif char == ')':\n            balance -= 1\n            \n        if balance == 0 and current_group:\n            result.append(current_group)\n            current_group = \"\"\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/2_prompt1p", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, return the integer part (largest integer smaller than given number).\"\"\"\n    return float(int(number))", "index": 0, "passed_case": [], "case_status": ["3.0", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/3_prompt1p", "code_candidates": [{"code": "from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account falls below zero. \"\"\"\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/4_prompt1p", "code_candidates": [{"code": "def mean_absolute_deviation(numbers):\n    if len(numbers) <= 1:\n        return 0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_deviations) / len(numbers)\n    \n    return mad", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/5_prompt1p", "code_candidates": [{"code": "def intersperse(numbers: list[int], delimiter: int) -> list[int]:\n    if len(numbers) <= 1:\n        return numbers[:]\n    \n    result = []\n    for i, num in enumerate(numbers):\n        result.append(num)\n        if i < len(numbers) - 1:\n            result.append(delimiter)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[5, 8, 6, 8, 3, 8, 2]", "[2, 2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/6_prompt1p", "code_candidates": [{"code": "def parse_parentheses_groups(s: str) -> list[int]:\n    groups = s.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        result.append(max_depth)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/7_prompt1p", "code_candidates": [{"code": "def filter_strings_by_substring(strings: list[str], substring: str) -> list[str]:\n    \"\"\"\n    Filter a list of strings to return only those that contain the specified substring.\n    \n    Args:\n        strings: List of strings to filter\n        substring: Substring to search for\n        \n    Returns:\n        List of strings containing the substring\n    \"\"\"\n    return [s for s in strings if substring in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/8_prompt1p", "code_candidates": [{"code": "from typing import List, Tuple\nfrom functools import reduce\nimport operator\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    total_product = reduce(operator.mul, numbers, 1)\n    \n    return (total_sum, total_product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/9_prompt1p", "code_candidates": [{"code": "def rolling_max(numbers: list[int]) -> list[int]:\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/10_prompt1p", "code_candidates": [{"code": "def make_palindrome(string: str) -> str:\n    if not string:\n        return ''\n    \n    # Find the longest prefix that is also a suffix when we reverse the string\n    # This helps us find the minimum characters to add at the beginning\n    reversed_string = string[::-1]\n    \n    # Try to find the longest prefix of string that matches a suffix of reversed_string\n    for i in range(len(string)):\n        if string.startswith(reversed_string[i:]):\n            # Add the necessary characters from reversed_string to make palindrome\n            return reversed_string[:i] + string\n    \n    # If no prefix matches, we need to add all reversed characters except the last one\n    return reversed_string[:-1] + string", "index": 0, "passed_case": [0, 1, 3], "case_status": ["", "x", "zyxyz", "xyx", "yrrejerry"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/11_prompt1p", "code_candidates": [{"code": "def string_xor(a: str, b: str) -> str:\n    if len(a) != len(b):\n        raise ValueError(\"Strings must have equal length\")\n    \n    result = []\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result.append('0')\n        else:\n            result.append('1')\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/12_prompt1p", "code_candidates": [{"code": "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return one of them. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    \"\"\"\n    if not strings:\n        return None\n    \n    return max(strings, key=len)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/13_prompt1p", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    if a < 0 or b < 0:\n        raise ValueError(\"Both parameters must be non-negative integers\")\n    \n    if a == 0 and b == 0:\n        return 0\n    \n    while b:\n        a, b = b, a % b\n    \n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/14_prompt1p", "code_candidates": [{"code": "def get_prefixes(s: str) -> list[str]:\n    return [s[:i] for i in range(len(s) + 1)]", "index": 0, "passed_case": [], "case_status": ["['']", "['', 'a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['', 'W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/15_prompt1p", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers from 1 to n (inclusive). If n is 0 or negative, return an empty string. \"\"\"\n    if n <= 0:\n        return \"\"\n    return \" \".join(str(i) for i in range(1, n + 1))", "index": 0, "passed_case": [], "case_status": ["", "1 2 3", "1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/16_prompt1p", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters does it consist of\n    \"\"\"\n    return len(set(string))", "index": 0, "passed_case": [0, 1], "case_status": ["0", "5", "9", "2", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/17_prompt1p", "code_candidates": [{"code": "def parse_notes(notes: str) -> list[float]:\n    if not notes:\n        return []\n    \n    note_durations = {\n        'W': 4.0,\n        'H': 2.0,\n        'Q': 1.0,\n        'E': 0.5\n    }\n    \n    result = []\n    for char in notes:\n        if char not in note_durations:\n            raise ValueError(f\"Invalid note character: {char}\")\n        result.append(note_durations[char])\n    \n    return result", "index": 0, "passed_case": [0], "case_status": ["[]", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/18_prompt1p", "code_candidates": [{"code": "def count_substring(main_string: str, substring: str) -> int:\n    \"\"\"\n    Count non-overlapping occurrences of substring in main_string.\n    \n    Args:\n        main_string: The string to search in\n        substring: The substring to search for\n        \n    Returns:\n        Number of non-overlapping occurrences\n    \"\"\"\n    # Handle edge cases\n    if not main_string or not substring or len(substring) > len(main_string):\n        return 0\n    \n    count = 0\n    start = 0\n    \n    # Search for substring starting from each position\n    while start <= len(main_string) - len(substring):\n        pos = main_string.find(substring, start)\n        if pos == -1:  # substring not found\n            break\n        count += 1\n        start = pos + 1  # Move start by 1 to find next non-overlapping occurrence\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/19_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals.\n    Sort the numbers in ascending order and return as a space-delimited string.\n    Handle empty strings, invalid inputs, and duplicates appropriately.\n    \n    - Empty string input returns empty string\n    - Invalid inputs (non-numeric values) raise ValueError\n    - Duplicates are preserved in the output\n    - Numbers are sorted numerically, not lexicographically\n    - Output maintains space-delimited format\n    \"\"\"\n    if not numbers:\n        return \"\"\n    \n    parts = numbers.split()\n    numeric_values = []\n    \n    for part in parts:\n        try:\n            numeric_values.append(float(part))\n        except ValueError:\n            raise ValueError(f\"Invalid input: '{part}' is not a number\")\n    \n    numeric_values.sort()\n    \n    # Convert back to strings, handling integers properly\n    result = []\n    for num in numeric_values:\n        if num.is_integer():\n            result.append(str(int(num)))\n        else:\n            result.append(str(num))\n    \n    return \" \".join(result)", "index": 0, "passed_case": [0], "case_status": ["", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/20_prompt1p", "code_candidates": [{"code": "def find_closest_pair(numbers):\n    \"\"\"\n    Find the pair of numbers in the list that are closest to each other.\n    \n    Args:\n        numbers: List of numbers (length at least 2)\n        \n    Returns:\n        Tuple of two numbers that are closest, in ascending order\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n    \n    min_distance = float('inf')\n    closest_pair = None\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            distance = abs(numbers[i] - numbers[j])\n            if distance < min_distance:\n                min_distance = distance\n                # Store in ascending order\n                closest_pair = (min(numbers[i], numbers[j]), max(numbers[i], numbers[j]))\n    \n    return closest_pair", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(3.9, 4.0)", "(5.0, 5.9)", "(2.0, 2.2)", "(2.0, 2.0)", "(2.2, 3.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/21_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef rescale(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply min-max scaling to rescale values to range [0, 1]\n    \n    Min-max scaling formula: (x - min) / (max - min)\n    \n    Args:\n        numbers: List of at least two float values\n        \n    Returns:\n        List of float values scaled to range [0, 1]\n        \n    Example:\n        >>> rescale([1.0, 2.0, 3.0])\n        [0.0, 0.5, 1.0]\n        >>> rescale([10.0, 20.0])\n        [0.0, 1.0]\n    \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    return [(x - min_val) / (max_val - min_val) for x in numbers]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/22_prompt1p", "code_candidates": [{"code": "def filter_integers(values):\n    \"\"\"\n    Filter given list of any python values and return only integer values.\n    \n    Args:\n        values: List of any python values\n        \n    Returns:\n        List containing only int values from the input list\n    \"\"\"\n    return [value for value in values if type(value) is int]", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 9]", "[3, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/23_prompt1p", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return length\n    \"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/24_prompt1p", "code_candidates": [{"code": "def largest_proper_divisor(n: int) -> int | None:\n    if n == 0:\n        raise ValueError(\"n must be non-zero\")\n    if n < 0:\n        raise ValueError(\"n must be positive\")\n    if n == 1:\n        return None\n    \n    # Start from n//2 and go down to 1\n    # The first divisor we find will be the largest\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    \n    return None", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/25_prompt1p", "code_candidates": [{"code": "def prime_factors(n: int) -> list[int]:\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    if n == 1:\n        return []\n    \n    factors = []\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n    \n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/26_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef remove_duplicates(nums: List[int]) -> List[int]:\n    \"\"\"\n    Remove elements that occur more than once from a list of integers.\n    Only elements that appear exactly once are kept.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        List with duplicates removed (keeping only unique elements)\n    \"\"\"\n    # Count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Keep only numbers that appear exactly once\n    result = []\n    for num in nums:\n        if count[num] == 1:\n            result.append(num)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[1, 2, 3, 4]", "[1, 4, 5]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/27_prompt1p", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase characters to lowercase. Leave non-alphabetic characters unchanged. \"\"\"\n    result = []\n    for char in string:\n        if char.islower():\n            result.append(char.upper())\n        elif char.isupper():\n            result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/28_prompt1p", "code_candidates": [{"code": "def concatenate_strings(string_list: list[str]) -> str:\n    return ''.join(string_list)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "xyz", "xyzwk"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/29_prompt1p", "code_candidates": [{"code": "def filter_by_prefix(strings: list[str], x: str) -> list[str]:\n    \"\"\"\n    Filter an input list of strings to return only those that start with the given prefix 'x'.\n    \n    Args:\n        strings: List of strings to filter\n        x: Prefix to match at the beginning of strings\n        \n    Returns:\n        List of strings that start with prefix 'x'\n    \"\"\"\n    return [s for s in strings if s.startswith(x)]", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/30_prompt1p", "code_candidates": [{"code": "def get_positive(l: list):\n    \"\"\"\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [x for x in l if x > 0]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[4, 5, 6]", "[5, 3, 2, 3, 3, 9, 123, 1]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/31_prompt1p", "code_candidates": [{"code": "def is_prime(n):\n    \"\"\"Return True if n is a prime number, False otherwise. Negative numbers, 0, and 1 are not considered prime. Non-integer inputs should raise TypeError.\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    \n    if n < 2:\n        return False\n    \n    if n == 2:\n        return True\n    \n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["False", "True", "True", "True", "True", "False", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/32_prompt1p", "code_candidates": [{"code": "from typing import List\nimport math\n\ndef find_zero(xs: List[float]) -> float:\n    # Handle zero polynomial (all coefficients are zero)\n    if all(x == 0 for x in xs):\n        return 0.0\n    \n    # Handle constant polynomial (degree 0)\n    if len(xs) == 1:\n        if xs[0] == 0:\n            return 0.0\n        else:\n            raise ValueError(\"No real zero found\")\n    \n    # Handle linear polynomial (degree 1)\n    if len(xs) == 2:\n        # xs[0] + xs[1] * x = 0\n        if xs[1] == 0:\n            if xs[0] == 0:\n                return 0.0\n            else:\n                raise ValueError(\"No real zero found\")\n        return -xs[0] / xs[1]\n    \n    # For higher degree polynomials, use numerical method (bisection method)\n    # First, check if we can find a sign change in a reasonable range\n    def evaluate_polynomial(x: float) -> float:\n        result = 0.0\n        for i, coeff in enumerate(xs):\n            result += coeff * (x ** i)\n        return result\n    \n    # Try to find a sign change\n    for i in range(-1000, 1001):\n        x1 = float(i) / 10.0\n        x2 = x1 + 0.1\n        y1 = evaluate_polynomial(x1)\n        y2 = evaluate_polynomial(x2)\n        \n        # Check if there's a sign change\n        if y1 * y2 <= 0:\n            # Found a sign change, use bisection method\n            a, b = x1, x2\n            for _ in range(100):  # Maximum iterations\n                c = (a + b) / 2.0\n                yc = evaluate_polynomial(c)\n                \n                if abs(yc) < 1e-10:\n                    return c\n                    \n                if y1 * yc <= 0:\n                    b = c\n                    y2 = yc\n                else:\n                    a = c\n                    y1 = yc\n            \n            return c\n    \n    # If no sign change found in range, try a broader search\n    for i in range(-10000, 10001):\n        x = float(i) / 100.0\n        y = evaluate_polynomial(x)\n        if abs(y) < 1e-10:\n            return x\n    \n    # If still no zero found, raise ValueError\n    raise ValueError(\"No real zero found\")", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/33_prompt1p", "code_candidates": [{"code": "def sort_divisible_by_three(lst):\n    \"\"\"\n    Sort elements at indices divisible by 3 in ascending order while keeping \n    elements at other indices unchanged.\n    \n    Args:\n        lst: List of elements\n        \n    Returns:\n        New list with elements at indices 0, 3, 6, 9, ... sorted in ascending order\n    \"\"\"\n    if not lst:\n        return []\n    \n    # Create a copy of the original list\n    result = lst.copy()\n    \n    # Extract elements at indices divisible by 3\n    divisible_by_three = [lst[i] for i in range(0, len(lst), 3)]\n    \n    # Sort these elements\n    divisible_by_three.sort()\n    \n    # Put the sorted elements back at indices divisible by 3\n    sorted_index = 0\n    for i in range(0, len(result), 3):\n        result[i] = divisible_by_three[sorted_index]\n        sorted_index += 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[2, 6, 3, 4, 8, 9, 5]", "[2, 8, 3, 4, 6, 9, 5]", "[2, 6, 9, 4, 8, 3, 5]", "[2, 6, 3, 4, 8, 9, 5, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/34_prompt1p", "code_candidates": [{"code": "def unique(l: list):\n    \"\"\"Return unique elements from the list in the order of their first appearance.\"\"\"\n    seen = set()\n    result = []\n    \n    for item in l:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[5, 3, 2, 9, 0, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/35_prompt1p", "code_candidates": [{"code": "def find_max(lst):\n    if not lst:\n        raise ValueError(\"List is empty\")\n    \n    max_element = lst[0]\n    for element in lst[1:]:\n        if element > max_element:\n            max_element = element\n    \n    return max_element", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/36_prompt1p", "code_candidates": [{"code": "def fizz_buzz(n: int) -> int:\n    count = 0\n    for i in range(n):\n        if i % 3 == 0:\n            count += str(i).count('7')\n    return count", "index": 0, "passed_case": [], "case_status": ["1", "4", "5", "6", "12", "399", "1332", "16665"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/37_prompt1p", "code_candidates": [{"code": "def process_list(input_list):\n    \"\"\"\n    Takes a list and returns a new list where:\n    - Odd indices remain unchanged\n    - Even indices contain values from even indices of the original list\n    - Values at even indices are copied in their original order\n    \n    Args:\n        input_list: List of elements\n        \n    Returns:\n        New list with the transformation applied\n    \"\"\"\n    if not input_list:\n        return []\n    \n    result = [None] * len(input_list)\n    \n    # Copy values from even indices of original list to even indices of result\n    for i in range(0, len(input_list), 2):\n        result[i] = input_list[i]\n    \n    # Odd indices remain unchanged (already None or preserved)\n    # But we need to handle the case where we might have odd indices\n    # that should be copied from original list\n    \n    # Actually, let me re-read the requirement...\n    # The problem is asking to preserve odd indices, but I need to make sure\n    # that even indices get values from original even indices\n    \n    # Let me re-implement correctly:\n    result = input_list.copy()  # Start with a copy\n    \n    # Only even indices should be modified to contain values from original even indices\n    # But since we're copying from even indices to even indices, \n    # the values are already in the right place in the copy\n    \n    # Actually, let me read this more carefully:\n    # \"even indices contain values from even indices of the original list\"\n    # This means we take values from original even indices (0,2,4...) \n    # and put them at even indices (0,2,4...) of the result\n    \n    # So we just need to make sure even indices have values from original even indices\n    # and odd indices remain unchanged\n    \n    # The simplest approach - copy the original list, then replace odd indices\n    # with values from the original list at odd indices (which means no change)\n    # Wait, that's not right either.\n    \n    # Let me re-read: \"even indices contain values from even indices of the original list\"\n    # This means we're taking values from positions 0,2,4... of input and placing them \n    # at positions 0,2,4... of result. This is already the case in a copy.\n    \n    # But the problem says \"odd indices remain unchanged\" - so we should preserve \n    # the values at odd positions from the original list.\n    \n    # The result should be a list where:\n    # - result[0] = input[0] (even index)\n    # - result[1] = input[1] (odd index - unchanged)\n    # - result[2] = input[2] (even index)\n    # - result[3] = input[3] (odd index - unchanged)\n    # etc.\n    \n    # This is just a copy of the original list, so let me just return a copy\n    # But that seems too simple. Let me think again...\n    \n    # Looking at it differently: \n    # Original list: [a, b, c, d, e, f]\n    # Result should be: [a, b, c, d, e, f] \n    # But wait, that's just a copy.\n    \n    # Let me think of it as: \n    # Take values from even positions of original list and place them at even positions of result\n    # This is already the case in a copy.\n    \n    # Actually, I think the requirement is saying:\n    # - Keep odd indices as they are\n    # - Even indices should get values from even indices of original list (which is the same)\n    \n    # So it's just a copy. But let me make sure I understand the example correctly.\n    # If input = [1, 2, 3, 4, 5, 6]\n    # Even indices in original: 0,2,4 -> values 1,3,5\n    # These should go to even indices in result: 0,2,4 -> values 1,3,5\n    # Odd indices in original: 1,3,5 -> values 2,4,6\n    # These should stay at odd indices in result: 1,3,5 -> values 2,4,6\n    # So result = [1, 2, 3, 4, 5, 6] - same as input\n    \n    # But that seems too trivial. Let me assume the requirement is to return a copy.\n    \n    return input_list.copy()", "index": 0, "passed_case": [0], "case_status": ["[1, 2, 3]", "[5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]", "[5, 8, -12, 4, 23, 2, 3, 11, 12, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/38_prompt1p", "code_candidates": [{"code": "def candidate(encoded_string: str) -> str:\n    \"\"\"\n    Decodes a string that was encoded using encode_cyclic.\n    \n    Args:\n        encoded_string: The encoded string\n        \n    Returns:\n        The original string before encoding\n    \"\"\"\n    if not encoded_string:\n        return \"\"\n    \n    result = []\n    \n    # Process the string in groups of 3 characters\n    for i in range(0, len(encoded_string), 3):\n        group = encoded_string[i:i+3]\n        \n        # If group has less than 3 characters, leave it unchanged\n        if len(group) < 3:\n            result.append(group)\n        else:\n            # Reverse the cyclic encoding: move first char to the back\n            # This is the reverse of moving last char to front\n            decoded_group = group[1:] + group[0]\n            result.append(decoded_group)\n    \n    return \"\".join(result)", "index": 0, "passed_case": [], "case_status": ["xdahihdexrvxncscbagh", "rtaugwnwrshoaizfyz", "ekikgymdcldlztib", "mrdjcrlutwsgvcbhy", "dchomifulgllvi", "tucruffxhiomruwkhvyy", "zhbikmscgw", "pguomueeirhxxri", "mnselhcqpdybfeunzvt", "tmmioqvraxd", "irykyundjafoixxfqyqd", "qjuetgflyqrykatdpalz", "hhbcsccxpyyree", "fprtiqrngwyxjgwumvlo", "hodkhcrashhswachub", "cbkiqhgvpre", "hspzzpdngndvnlnboxv", "budkmxhzdrggnoeofihc", "dzrrbuyacnhfgppmb", "mmaziznojzwx", "pvwjegsgbbxrbxkpbs", "bqffqccctmvhhdsbst", "vcnqssgkikvwmhiuevj", "ckytaocsdqrgliech", "ojfjrwutzvqavrj", "deirdxjeitg", "ugvpiqcibiunkba", "fuirxorwncad", "lrbesrbnezjl", "vlgdhvrlyn", "hxezfzafnkfxzznzvxh", "wfzbdmgphjolzh", "gavimkicyqlum", "arkfdibsindtzlxtknqd", "isgnbwzaqxrvvxxg", "vnckktxvdjjqkvn", "rwjnegvvmtxfmsjr", "gjjsnzktuo", "govzqpfzxjvcuqvtk", "vyhzjhagebh", "ctyuonwsgpwmemhuw", "dyyhynwfzq", "hbredovzotqrokytx", "onrpfxyoiihuqyyhpu", "wocijhrkkecehm", "cwgknnnronbg", "wyssayampyljrmnx", "hztiphanpvmkmvzoxf", "atrsmscvaeun", "ifbgmkkokiymiyncp", "bxrulhucyb", "ahghtevepd", "wgoliytftdxwjyfadsj", "mvmcwguswwhdvyjdtzz", "lzbvrnqlcaukdnpunlo", "xnfiqurtzoyp", "ixsckhhiosyomtvk", "fpklpgkzii", "rwigaqxchrnpwyhwpup", "czamjhjwhlvsqprln", "wkljoidihkxgrdxfyw", "pgxsixtyqgjdj", "jlfrawbeijbrw", "puysdapjpfok", "dippcmucsv", "zeecsjrhdy", "zttythoqmsojsnjt", "dtxuygvgic", "rhfacfwnojtp", "whjojwhcvi", "zsvdgnurheeifcbtzjxs", "oodwwjqmiorpct", "knxativchs", "vaybisfyyupqfoiusnp", "nplvkkkdfnw", "mjvbyrkocdikqymav", "bonlgqptyyuoibgjre", "dwptauwzhrfjnarch", "uodwepwjqin", "ophmreqgtcxeziynk", "jiasxjpsvreokplrry", "gokswhymhknbwxpz", "zmvpueqbedskqodo", "nxecueipzk", "uwmvckkrmyuwbprhtcu", "xjhdcnwyufdoawjzbkbj", "elnnhqzsvfffmct", "pvhhseiouvoioazrjvf", "solnjuowijg", "hpdlmswsjvjaamis", "byxptxzjyzhtulhigtvy", "uveuduzbjsobelxkcjxn", "zgeqrlfqizip", "zxkcdoheyvvxmz", "zlcimaordxlvsvilmu", "pvhrathktuc", "jowdunbebdjprdhoemlv", "xnsnxepuditnlbwogo", "vldulrmlbdigo", "uvgautkbzhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/39_prompt1p", "code_candidates": [{"code": "def fibonacci(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    \n    return b", "index": 0, "passed_case": [], "case_status": ["1", "1", "2", "3", "5", "8", "13", "21", "34", "55"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/40_prompt1p", "code_candidates": [{"code": "def three_sum_zero(nums):\n    \"\"\"\n    Returns True if there exist three distinct indices in the list such that \n    the elements at those indices sum to zero.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        bool: True if three distinct elements sum to zero, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if not nums or len(nums) < 3:\n        return False\n    \n    # Sort the array to enable two-pointer technique\n    nums.sort()\n    n = len(nums)\n    \n    # Iterate through each element as the first element of potential triplet\n    for i in range(n - 2):\n        # Use two pointers to find the other two elements\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                return True\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/41_prompt1p", "code_candidates": [{"code": "def car_race_collision(n: int) -> int:\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/42_prompt1p", "code_candidates": [{"code": "def incr_list(l: list) -> list:\n    \"\"\"Return list with elements incremented by 1. Assumes list contains numeric elements (int/float). If non-numeric elements are present, raise a TypeError.\"\"\"\n    result = []\n    for item in l:\n        if not isinstance(item, (int, float)):\n            raise TypeError(\"All elements must be numeric\")\n        result.append(item + 1)\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[4, 3, 2]", "[6, 3, 6, 3, 4, 4, 10, 1, 124]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/43_prompt1p", "code_candidates": [{"code": "def pairs_sum_to_zero(l):\n    seen = set()\n    for num in l:\n        if -num in seen:\n            return True\n        seen.add(num)\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/44_prompt1p", "code_candidates": [{"code": "def change_base(number: int, target_base: int) -> str:\n    if not (2 <= target_base <= 36):\n        raise ValueError(\"Base must be between 2 and 36 inclusive\")\n    \n    if number == 0:\n        return '0'\n    \n    digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    result = []\n    is_negative = number < 0\n    number = abs(number)\n    \n    while number > 0:\n        result.append(digits[number % target_base])\n        number //= target_base\n    \n    result_str = ''.join(reversed(result))\n    return '-' + result_str if is_negative else result_str", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/45_prompt1p", "code_candidates": [{"code": "def triangle_area(a, h):\n    \"\"\"Given length of a side (a) and height (h), return the area of the triangle using formula: area = (1/2) * a * h. Handles positive values correctly. Returns float representing the triangle area. For negative inputs, raises ValueError. For zero inputs, returns 0.0.\"\"\"\n    if a < 0 or h < 0:\n        raise ValueError(\"Inputs must be non-negative\")\n    return 0.5 * a * h", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/46_prompt1p", "code_candidates": [{"code": "def fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    \"\"\"\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    \n    # Initialize the first four values\n    a, b, c, d = 0, 0, 2, 0\n    \n    # Iteratively compute fib4(n)\n    for _ in range(4, n + 1):\n        next_val = a + b + c + d\n        a, b, c, d = b, c, d, next_val\n    \n    return d", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["4", "28", "104", "386"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/47_prompt1p", "code_candidates": [{"code": "def median(l: list):\n    \"\"\"Return the median value of elements in the list l. For an odd-length list, return the middle element. For an even-length list, return the average of the two middle elements. The list should be sorted first. The function returns a numeric value (int or float) representing the median.\"\"\"\n    if not l:\n        raise ValueError(\"List cannot be empty\")\n    \n    sorted_list = sorted(l)\n    n = len(sorted_list)\n    \n    if n % 2 == 1:\n        return sorted_list[n // 2]\n    else:\n        mid1 = sorted_list[n // 2 - 1]\n        mid2 = sorted_list[n // 2]\n        return (mid1 + mid2) / 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "8.0", "5", "5.5", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/48_prompt1p", "code_candidates": [{"code": "def is_palindrome(text: str) -> bool:\n    # Extract only alphabetic characters and convert to lowercase\n    cleaned = ''.join(char.lower() for char in text if char.isalpha())\n    \n    # Check if the cleaned string is equal to its reverse\n    return cleaned == cleaned[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/49_prompt1p", "code_candidates": [{"code": "def modp(n: int, p: int) -> int:\n    return (2 ** n) % p", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/50_prompt1p", "code_candidates": [{"code": "def candidate(encoded_string):\n    \"\"\"\n    Decodes a string that was encoded using the encode_shift function.\n    \n    Args:\n        encoded_string (str): The encoded string to decode\n        \n    Returns:\n        str: The original decoded string\n    \"\"\"\n    result = []\n    \n    for char in encoded_string:\n        if 'a' <= char <= 'z':\n            # Shift back by 3 positions (reverse of encode_shift)\n            # Handle wrapping around the alphabet\n            shifted = (ord(char) - ord('a') - 3) % 26\n            decoded_char = chr(shifted + ord('a'))\n            result.append(decoded_char)\n        else:\n            # Keep non-lowercase letters unchanged\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [], "case_status": ["fczkjjgzfxzteupdceij", "vctiywytpjqukbcabh", "mkgiamfeofnnvkbd", "tfoetlwvnuiyedxja", "ejfokqwnhnnixk", "wevwhtzjhqokwytjxmaa", "jdbmokeiuy", "iwrowqgkgjzttkz", "puonjgsreadfgwhbxpv", "oovqsktcxzf", "takawmflphqczzksahsf", "lwsvignahtascvmrcfnb", "jdjueezreatagg", "rthksvpitazyiyloxwnq", "qfjjemcutjujceywdj", "dmesjkxritg", "urjbrbpiffxpnppqzdx", "wfdozmbfjiitqgphkqje", "btfdwtceajhprriod", "ocokbbqlpyzb", "xyrgiliduztdzmddur", "shdsehevexjofujuvd", "epxuusmkixymjkogxwl", "maecqvufetiskgnej", "lhqtylvbwscxtlx", "gkffztgklvi", "ixwksrkdewpkdcm", "wkhzqtyptcfe", "tdnutgpgdlnb", "nixjxfnatp", "zgjhbbhpchzmbpbxzbj", "hbyfodrjiqnlbj", "cxiomkeaknwso", "tmcfkhukdfvpnzbmpvsf", "uikdypcsbtxzzzxi", "pexmvmxfzlslxpm", "yltgipxoxzhvulot", "llipbuvwmq", "qxisrbbzhxelsxwvm", "ajxljbigcdj", "vaeqpwuiyyorojgwy", "aafapjhbys", "dtjfqgbqxstvmaqvz", "ptqhzrqkajwkaasrwj", "qeyljkmmteggjo", "yieppmtqpdip", "auycauorcnlaoptz", "bvjrjkprcomxxbozhq", "vtcouuxcewpg", "hdkomiqmmaokapker", "ztdnjweawd", "jicvgjgrxf", "iqykanhvvzyfahlfucl", "xooyieuywjfyalxvbfb", "bdntpxneswmcprfpnwq", "phzswkvbtarq", "zukmjekqjaquvxom", "rmhrinbkmk", "yktcsiejzprtajyrwyr", "bceljoyjlxunrtsnp", "mnyqklkjfzimfztayh", "izrkzuasvlfil", "nhlcytgkddtly", "warfculrrqmh", "krfeoreuwx", "ggbulejfta", "vvbvjasoqqlupluv", "vzfaiwikxe", "jhtehcpqyvrl", "jlylyqexjk", "uxbipftjwgkgedhblvzu", "qfqylyokstrqev", "pzmvkcejxu", "caxkudaahrswqkhupwr", "rnpmmxfhmpy", "lxoatdqemkmfaoscx", "qpdisnvarwqadiktgl", "yrfcwvbjyhltctpej", "qfwgrylsykp", "rjqtgoivszgekabpm", "kclzluuxrgqtrnmtat", "qmiyjuojapdmzryb", "oxbwgrdgsumfqfsq", "zgpwgerbkm", "yowemxtomwyartdvejw", "ljzepfawyfqhylcdmbdl", "npgjspuxbhhhevo", "xjrugjqwkqkxcbqlxth", "qnulwpykqli", "rfjounulylcxokcu", "azdvzrlabjvbnjwivkxa", "xgwfwwdlbqdunzgelmzp", "igbtnsskhkrb", "zmbfqegajxzxob", "nebocktfqnxzxkuown", "xjrcvtmvjwe", "qylwpfgddlrffjtgoqnx", "puzzgpwfrvpkdyniqq", "nfxntwndokifq", "xiwwvcdbmjg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/51_prompt1p", "code_candidates": [{"code": "def remove_vowels(text):\n    \"\"\"Removes all vowels (a, e, i, o, u) from the input string and returns the result.\"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/52_prompt1p", "code_candidates": [{"code": "def below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t, False otherwise.\"\"\"\n    return all(x < t for x in l)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/53_prompt1p", "code_candidates": [{"code": "def add(x: int, y: int) -> int:\n    \"\"\"Returns the sum of two integers x and y\"\"\"\n    return x + y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104], "case_status": ["1", "1", "5", "12", "12", "768", "784", "531", "370", "858", "1450", "1471", "693", "464", "125", "461", "1133", "601", "936", "1383", "987", "684", "887", "1718", "783", "988", "1146", "632", "379", "1761", "448", "483", "466", "1219", "888", "870", "1217", "676", "1940", "467", "865", "1492", "1539", "1252", "787", "792", "723", "1024", "377", "1113", "990", "673", "1114", "1227", "545", "577", "959", "1677", "1362", "696", "825", "1292", "417", "861", "1223", "1359", "794", "1033", "1649", "851", "1075", "856", "733", "341", "1151", "1545", "1632", "539", "1182", "1310", "1594", "615", "413", "1014", "1125", "1033", "1036", "1516", "778", "365", "1026", "866", "929", "268", "805", "1507", "1042", "459", "1000", "1020", "1251", "1447", "976", "1434", "815"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/54_prompt1p", "code_candidates": [{"code": "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/55_prompt1p", "code_candidates": [{"code": "def fib(n: int):\n    \"\"\"\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/56_prompt1p", "code_candidates": [{"code": "def is_valid_brackets(s: str) -> bool:\n    \"\"\"\n    Validates if a string of '<' and '>' brackets is properly matched and nested.\n    \n    Args:\n        s: A string containing only '<' and '>' characters\n        \n    Returns:\n        True if all '<' brackets have matching '>' brackets in proper order, False otherwise\n    \"\"\"\n    count = 0\n    for char in s:\n        if char == '<':\n            count += 1\n        elif char == '>':\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/57_prompt1p", "code_candidates": [{"code": "def is_monotonic(nums):\n    \"\"\"\n    Determines if a list is monotonic (either entirely non-decreasing or non-increasing).\n    \n    Args:\n        nums: A list of numbers\n        \n    Returns:\n        bool: True if the list is monotonic, False otherwise\n    \"\"\"\n    # Empty lists and single-element lists are considered monotonic\n    if len(nums) <= 1:\n        return True\n    \n    # Check if the list is non-decreasing\n    is_non_decreasing = all(nums[i] >= nums[i-1] for i in range(1, len(nums)))\n    \n    # Check if the list is non-increasing\n    is_non_increasing = all(nums[i] <= nums[i-1] for i in range(1, len(nums)))\n    \n    # Return True if either condition is met\n    return is_non_decreasing or is_non_increasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/58_prompt1p", "code_candidates": [{"code": "def common(l1: list, l2: list):\n    \"\"\"Return common.\"\"\"\n    return sorted(list(set(l1) & set(l2)))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/59_prompt1p", "code_candidates": [{"code": "def largest_prime_factor(n):\n    \"\"\"\n    Return the largest prime factor of n, where n > 1 and n is not a prime number.\n    \n    Args:\n        n (int): An integer greater than 1 that is not prime\n        \n    Returns:\n        int: The largest prime factor of n\n    \"\"\"\n    # Handle the case where n is even\n    largest_factor = -1\n    \n    # Remove all factors of 2\n    while n % 2 == 0:\n        largest_factor = 2\n        n = n // 2\n    \n    # Check odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest_factor = factor\n            n = n // factor\n        factor += 2\n    \n    # If n is still greater than 1, then it's a prime factor\n    if n > 1:\n        largest_factor = n\n    \n    return largest_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/60_prompt1p", "code_candidates": [{"code": "def sum_to_n(n: int) -> int:\n    \"\"\"\n    Calculate the sum of all integers from 1 to n (inclusive).\n    \n    Args:\n        n: A positive integer\n        \n    Returns:\n        The sum of consecutive integers from 1 to n\n        \n    Examples:\n        >>> sum_to_n(3)\n        6\n        >>> sum_to_n(5)\n        15\n        >>> sum_to_n(1)\n        1\n    \"\"\"\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/61_prompt1p", "code_candidates": [{"code": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    Validates if a string of parentheses is properly balanced.\n    \n    Args:\n        s: A string containing parentheses to validate\n        \n    Returns:\n        True if all opening brackets have matching closing brackets in correct order and nesting, False otherwise\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/62_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef polynomial_derivative(coefficients: List[float]) -> List[float]:\n    \"\"\"\n    Computes the derivative of a polynomial given as a list of coefficients.\n    \n    Args:\n        coefficients: List of polynomial coefficients [a0, a1, a2, ..., an]\n        \n    Returns:\n        List of coefficients representing the derivative polynomial\n    \"\"\"\n    # Handle edge cases\n    if not coefficients or len(coefficients) == 1:\n        return [0]\n    \n    # Compute derivative coefficients\n    derivative = []\n    for i in range(1, len(coefficients)):\n        derivative.append(i * coefficients[i])\n    \n    return derivative", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/63_prompt1p", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Initialize the base cases\n    a, b, c = 0, 0, 1\n    \n    # Compute iteratively from 3 to n\n    for i in range(3, n + 1):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/64_prompt1p", "code_candidates": [{"code": "def vowels_count(s):\n    \"\"\"Write a function candidate which takes a string representing\n    a word as input.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    \"\"\"\n    if not s:\n        return 0\n    \n    vowels = set('aeiou')\n    count = 0\n    s = s.lower()\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/65_prompt1p", "code_candidates": [{"code": "def circular_shift(x: int, shift: int) -> str:\n    # Convert to string and remove sign if negative\n    digits = str(abs(x))\n    n = len(digits)\n    \n    # Handle edge cases\n    if n == 0:\n        return \"\"\n    \n    # Normalize shift using modulo\n    shift = shift % n\n    \n    # Perform right circular shift\n    if shift == 0:\n        return digits\n    else:\n        return digits[-shift:] + digits[:-shift]", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["001", "12", "97", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/66_prompt1p", "code_candidates": [{"code": "def digitSum(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of numeric digits in the string.\n    If no digits are present, return 0.\n    \n    Examples:\n    - digitSum(\"abc123\") returns 6 (1+2+3)\n    - digitSum(\"hello\") returns 0 (no digits)\n    - digitSum(\"a1b2c3\") returns 6 (1+2+3)\n    - digitSum(\"\") returns 0 (empty string)\n    \"\"\"\n    total = 0\n    for char in s:\n        if char.isdigit():\n            total += int(char)\n    return total", "index": 0, "passed_case": [0], "case_status": ["0", "0", "0", "0", "0", "0", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/67_prompt1p", "code_candidates": [{"code": "import re\n\ndef count_mangoes(fruit_string: str, total_fruits: int) -> int:\n    \"\"\"\n    Parse a string representing apples and oranges in a basket and calculate the number of mangoes.\n    \n    Args:\n        fruit_string: String in format \"X apples and Y oranges\"\n        total_fruits: Total number of fruits in the basket\n        \n    Returns:\n        Number of mangoes in the basket\n        \n    Raises:\n        ValueError: If string format is invalid or contains negative numbers\n    \"\"\"\n    # Match the expected pattern\n    pattern = r\"(\\d+)\\s+apples\\s+and\\s+(\\d+)\\s+oranges\"\n    match = re.match(pattern, fruit_string)\n    \n    if not match:\n        raise ValueError(\"Invalid string format\")\n    \n    apples = int(match.group(1))\n    oranges = int(match.group(2))\n    \n    # Check for negative numbers\n    if apples < 0 or oranges < 0:\n        raise ValueError(\"Negative numbers not allowed\")\n    \n    # Calculate mangoes\n    mangoes = total_fruits - apples - oranges\n    \n    # Check if result is valid\n    if mangoes < 0:\n        raise ValueError(\"Invalid fruit counts: total fruits less than apples and oranges\")\n    \n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/68_prompt1p", "code_candidates": [{"code": "from typing import List, Optional\n\ndef pluck_branch(branch: List[int]) -> Optional[int]:\n    \"\"\"\n    Pluck the node with the smallest value from a tree branch.\n    \n    Args:\n        branch: List of non-negative integers representing tree nodes\n        \n    Returns:\n        The smallest value in the branch, or None if branch is empty\n    \"\"\"\n    if not branch:\n        return None\n    \n    return min(branch)", "index": 0, "passed_case": [], "case_status": ["2", "1", "None", "0", "0", "4", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/69_prompt1p", "code_candidates": [{"code": "def search(lst):\n    if not lst:\n        return None\n    \n    # Count occurrences of each number\n    count_dict = {}\n    for num in lst:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    \n    # Find the greatest number that appears at least once\n    max_valid = None\n    for num, count in count_dict.items():\n        if count >= 1:\n            if max_valid is None or num > max_valid:\n                max_valid = num\n    \n    return max_valid", "index": 0, "passed_case": [1, 3, 12], "case_status": ["5", "4", "3", "8", "3", "10", "8", "10", "8", "10", "10", "10", "1", "10", "10", "10", "10", "10", "10", "10", "10", "10", "10", "10", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/70_prompt1p", "code_candidates": [{"code": "def strange_order(nums):\n    if not nums:\n        return []\n    \n    sorted_nums = sorted(nums)\n    result = []\n    left, right = 0, len(sorted_nums) - 1\n    take_from_left = True\n    \n    while left <= right:\n        if take_from_left:\n            result.append(sorted_nums[left])\n            left += 1\n        else:\n            result.append(sorted_nums[right])\n            right -= 1\n        take_from_left = not take_from_left\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/71_prompt1p", "code_candidates": [{"code": "def triangle_area(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area(3, 4, 5) == 6.00\n    '''\n    # Check if the sides form a valid triangle\n    if a + b <= c or a + c <= b or b + c <= a:\n        return None\n    \n    # Calculate area using Heron's formula\n    s = (a + b + c) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    \n    return round(area, 2)", "index": 0, "passed_case": [0, 2, 3, 5, 7], "case_status": ["6.0", "None", "8.18", "1.73", "None", "16.25", "None", "0.43", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/72_prompt1p", "code_candidates": [{"code": "def can_fly(q, w):\n    # Edge cases\n    if not q:\n        return True\n    \n    if len(q) == 1:\n        return True\n    \n    # Check if palindromic\n    if q != q[::-1]:\n        return False\n    \n    # Check weight limit\n    total_weight = sum(q)\n    if total_weight > w:\n        return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/73_prompt1p", "code_candidates": [{"code": "def smallest_change(arr):\n    \"\"\"\n    Given an array arr of integers, find the number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n    \"\"\"\n    if not arr:\n        return 0\n    \n    changes = 0\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/74_prompt1p", "code_candidates": [{"code": "def list_with_more_chars(list1, list2):\n    \"\"\"\n    Returns the list that has the total number of characters in all strings.\n    If both lists have equal character counts, returns the first list.\n    Handles empty lists as having 0 characters.\n    Raises TypeError if either list is None.\n    \"\"\"\n    if list1 is None or list2 is None:\n        raise TypeError(\"Lists cannot be None\")\n    \n    # Calculate total characters in each list\n    total_chars1 = sum(len(s) for s in list1)\n    total_chars2 = sum(len(s) for s in list2)\n    \n    # Return the list with more characters, or first if equal\n    return list1 if total_chars1 >= total_chars2 else list2", "index": 0, "passed_case": [0, 6], "case_status": ["[]", "['hi', 'admin']", "['hi', 'hi', 'admin', 'project']", "['1', '2', '3', '4', '5']", "['hi', 'admin']", "['hi', 'admin']", "['hi', 'admin']", "['this']", "['this']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/75_prompt1p", "code_candidates": [{"code": "def is_multiply_prime(n):\n    if n < 2:\n        return False\n    \n    def get_prime_factors_count(num):\n        count = 0\n        d = 2\n        while d * d <= num:\n            while num % d == 0:\n                count += 1\n                num //= d\n            d += 1\n        if num > 1:\n            count += 1\n        return count\n    \n    prime_factors_count = get_prime_factors_count(n)\n    return prime_factors_count >= 2", "index": 0, "passed_case": [0, 1, 2, 4, 5, 9], "case_status": ["False", "True", "True", "True", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/76_prompt1p", "code_candidates": [{"code": "def is_simple_power(x, n):\n    # Handle edge cases\n    if n == 0:\n        return x == 0\n    \n    if n == 1:\n        return x == 1\n    \n    if x == 0:\n        return False\n    \n    if x == 1:\n        return True\n    \n    # Handle negative numbers\n    if x < 0 and n > 0:\n        return False\n    \n    if x < 0 and n < 0:\n        # For negative x and negative n, we need odd power\n        abs_x = abs(x)\n        abs_n = abs(n)\n        k = 1\n        power = abs_n\n        while power < abs_x:\n            power *= abs_n\n            k += 1\n        return power == abs_x and k % 2 == 1\n    \n    # For positive numbers\n    if x > 0 and n > 0:\n        k = 1\n        power = n\n        while power < x:\n            power *= n\n            k += 1\n        return power == x\n    \n    # For positive x and negative n\n    if x > 0 and n < 0:\n        k = 1\n        power = 1 / n\n        while power > x:\n            power /= n\n            k += 1\n        return power == x\n    \n    # For negative x and positive n\n    if x < 0 and n > 0:\n        return False\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/77_prompt1p", "code_candidates": [{"code": "def is_perfect_cube(a: int) -> bool:\n    if a == 0:\n        return True\n    \n    # Handle positive numbers\n    if a > 0:\n        cube_root = round(a ** (1/3))\n        return cube_root ** 3 == a\n    \n    # Handle negative numbers\n    else:\n        cube_root = round((-a) ** (1/3))\n        return (-cube_root) ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/78_prompt1p", "code_candidates": [{"code": "def count_hex_digits(input_string: str) -> int:\n    \"\"\"\n    Count occurrences of specific hexadecimal digits ('2', '3', '5', '7', 'B', 'D') in input string.\n    \n    Args:\n        input_string: A string to search for hexadecimal digits\n        \n    Returns:\n        The count of occurrences of the specified hexadecimal digits\n    \"\"\"\n    target_digits = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    \n    for char in input_string:\n        if char.upper() in target_digits:\n            count += 1\n            \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/79_prompt1p", "code_candidates": [{"code": "def convert_decimal_to_binary_db(decimal_num):\n    \"\"\"\n    Convert a decimal number to a binary string representation with 'db' \n    characters added at both the beginning and end of the binary string.\n    \n    Args:\n        decimal_num (int): The decimal number to convert\n        \n    Returns:\n        str: Binary representation prefixed and suffixed with 'db'\n    \"\"\"\n    binary_str = bin(decimal_num)[2:]  # Convert to binary and remove '0b' prefix\n    return f\"db{binary_str}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/80_prompt1p", "code_candidates": [{"code": "def is_happy_string(s: str) -> bool:\n    \"\"\"\n    Determines if a string is 'happy' based on the following criteria:\n    - A string is happy if it has at least 3 characters\n    - Every character appears at most twice\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        True if the string is happy, False otherwise\n    \"\"\"\n    # Check if string has at least 3 characters\n    if len(s) < 3:\n        return False\n    \n    # Count occurrences of each character\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Check if any character appears more than twice\n    for count in char_count.values():\n        if count > 2:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 4, 6, 7], "case_status": ["False", "False", "True", "True", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/81_prompt1p", "code_candidates": [{"code": "def gpa_to_letter_grades(gpa_list):\n    if not gpa_list:\n        return []\n    \n    # Define the grading scale\n    grade_scale = [\n        (4.0, 'A+'),\n        (3.7, 'A'),\n        (3.3, 'A-'),\n        (3.0, 'B+'),\n        (2.7, 'B'),\n        (2.3, 'B-'),\n        (2.0, 'C+'),\n        (1.7, 'C'),\n        (1.3, 'C-'),\n        (1.0, 'D+'),\n        (0.7, 'D'),\n        (0.0, 'F')\n    ]\n    \n    result = []\n    \n    for gpa in gpa_list:\n        # Round to one decimal place for comparison\n        rounded_gpa = round(gpa, 1)\n        \n        # Validate GPA range\n        if rounded_gpa < 0.0 or rounded_gpa > 4.0:\n            raise ValueError(f\"GPA value {gpa} is outside the valid range (0.0 to 4.0)\")\n        \n        # Find the appropriate letter grade\n        for threshold, letter in grade_scale:\n            if rounded_gpa >= threshold:\n                result.append(letter)\n                break\n    \n    return result", "index": 0, "passed_case": [1], "case_status": ["['A+', 'B+', 'C', 'C+', 'A-']", "['D+']", "['F']", "['F']", "['D+', 'F', 'C-', 'B', 'A-']", "['F', 'D']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/82_prompt1p", "code_candidates": [{"code": "def is_prime_length(s: str) -> bool:\n    \"\"\"\n    Returns True if the length of the input string is a prime number, False otherwise.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        bool: True if length is prime, False otherwise\n    \"\"\"\n    length = len(s)\n    \n    # Handle edge cases: 0 and 1 are not prime numbers\n    if length < 2:\n        return False\n    \n    # Check if length is prime\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/83_prompt1p", "code_candidates": [{"code": "def count_same_start_end(n: int) -> int:\n    if n == 1:\n        return 9\n    else:\n        # For n-digit numbers, first and last digits must be same (1-9)\n        # Middle digits can be anything (0-9)\n        # First digit: 9 choices (1-9)\n        # Last digit: 1 choice (must match first digit)\n        # Middle digits: 10^(n-2) choices (each can be 0-9)\n        return 9 * (10 ** (n - 2))", "index": 0, "passed_case": [], "case_status": ["9", "9", "90", "900", "9000"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/84_prompt1p", "code_candidates": [{"code": "def sum_of_digits(N: int) -> str:\n    \"\"\"\n    Given a positive integer N, return the total sum of its digits as a string.\n    \n    Args:\n        N: A positive integer\n        \n    Returns:\n        A string representation of the sum of digits of N\n    \"\"\"\n    digit_sum = sum(int(digit) for digit in str(N))\n    return str(digit_sum)", "index": 0, "passed_case": [0], "case_status": ["1", "6", "12", "9", "18"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/85_prompt1p", "code_candidates": [{"code": "def sum_even_elements(nums: list[int]) -> int:\n    \"\"\"\n    Return the sum of all even elements in the list.\n    If there are no even elements, return 0.\n    \n    Args:\n        nums: A non-empty list of integers\n        \n    Returns:\n        int: Sum of all even elements, or 0 if none exist\n    \"\"\"\n    return sum(num for num in nums if num % 2 == 0)", "index": 0, "passed_case": [], "case_status": ["92", "134", "10", "22"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/86_prompt1p", "code_candidates": [{"code": "def sort_string(s: str) -> str:\n    \"\"\"\n    Takes a string and returns a string with characters arranged in alphabetical order.\n    Uppercase letters appear before lowercase letters.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        String with characters sorted in alphabetical order\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    # Sort characters with custom key: uppercase letters first, then lowercase\n    # For each character, we use (char.lower(), char.islower()) as the sort key\n    # This ensures uppercase letters come before lowercase letters for the same letter\n    sorted_chars = sorted(s, key=lambda char: (char.lower(), char.islower()))\n    \n    return ''.join(sorted_chars)", "index": 0, "passed_case": [0, 1, 2, 3, 5], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "!!!deHllloorW", "", "..?aabeeeHHiiiMMmnooooRrrssttuwyy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/87_prompt1p", "code_candidates": [{"code": "def find_integer_positions(matrix, x):\n    \"\"\"\n    Search for integer x in a 2D nested list structure and return a list of (row, column) tuples\n    indicating all positions where x is found.\n    \n    Args:\n        matrix: A 2D nested list structure\n        x: Integer to search for\n        \n    Returns:\n        List of (row, column) tuples indicating positions where x is found\n    \"\"\"\n    positions = []\n    \n    # Handle empty matrix\n    if not matrix:\n        return positions\n    \n    for row_idx, row in enumerate(matrix):\n        # Handle empty rows\n        if not row:\n            continue\n            \n        for col_idx, element in enumerate(row):\n            # Handle irregular shapes by checking if element is an integer\n            if isinstance(element, int) and element == x:\n                positions.append((row_idx, col_idx))\n    \n    return positions", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/88_prompt1p", "code_candidates": [{"code": "def sort_array(arr):\n    \"\"\"\n    Sorts an array of non-negative integers in ascending order if the sum of \n    the first and last elements is odd, otherwise sorts in descending order.\n    \n    Args:\n        arr: List of non-negative integers\n        \n    Returns:\n        A copy of the array sorted according to the rule\n    \"\"\"\n    if not arr:\n        return []\n    \n    # Create a copy to avoid modifying the original array\n    result = arr.copy()\n    \n    # Calculate sum of first and last elements\n    sum_first_last = arr[0] + arr[-1]\n    \n    # Sort based on whether the sum is odd or even\n    if sum_first_last % 2 == 1:  # odd\n        result.sort()  # ascending order\n    else:  # even\n        result.sort(reverse=True)  # descending order\n        \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/89_prompt1p", "code_candidates": [{"code": "def encrypt(text: str) -> str:\n    if not text:\n        return \"\"\n    \n    result = []\n    for char in text:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            base = ord('A') if char.isupper() else ord('a')\n            # Apply Caesar cipher with shift of 3\n            encrypted_char = chr((ord(char) - base + 3) % 26 + base)\n            result.append(encrypted_char)\n        else:\n            # Preserve non-alphabetic characters\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [], "case_status": ["kl", "dvgijkmno", "ji", "hw"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/90_prompt1p", "code_candidates": [{"code": "def next_smallest(lst):\n    if not lst:\n        return None\n    \n    unique_sorted = sorted(set(lst))\n    \n    if len(unique_sorted) < 2:\n        return None\n    \n    return unique_sorted[1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "2", "None", "None", "1", "None", "-35"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/91_prompt1p", "code_candidates": [{"code": "def count_consecutive_patterns(text: str, pattern: str) -> int:\n    if not text or not pattern:\n        return 0\n    \n    # Split the text into words\n    words = text.split()\n    \n    # If we don't have enough words to form the pattern, return 0\n    if len(words) < len(pattern.split()):\n        return 0\n    \n    # Convert pattern to list of words for comparison\n    pattern_words = pattern.split()\n    \n    # If pattern has more words than text, return 0\n    if len(pattern_words) > len(words):\n        return 0\n    \n    count = 0\n    i = 0\n    \n    # Check for consecutive occurrences of the pattern\n    while i <= len(words) - len(pattern_words):\n        # Check if current position matches the pattern\n        if words[i:i + len(pattern_words)] == pattern_words:\n            # Count consecutive occurrences\n            consecutive_count = 1\n            j = i + len(pattern_words)\n            \n            # Continue checking for consecutive matches\n            while j <= len(words) - len(pattern_words):\n                if words[j:j + len(pattern_words)] == pattern_words:\n                    consecutive_count += 1\n                    j += len(pattern_words)\n                else:\n                    break\n            \n            # If we have 3 or more consecutive occurrences, increment count\n            if consecutive_count >= 3:\n                count += 1\n            \n            # Move index to the end of the last matched pattern\n            i = j\n        else:\n            i += 1\n    \n    return count", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/92_prompt1p", "code_candidates": [{"code": "def any_int(x, y, z):\n    return x == y + z or y == x + z or z == x + y", "index": 0, "passed_case": [0, 1, 3, 4, 5, 6, 7, 8], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/93_prompt1p", "code_candidates": [{"code": "def encode(message):\n    vowels = 'aeiouAEIOU'\n    result = []\n    \n    for char in message:\n        if char.isalpha():\n            # Swap case\n            swapped_char = char.lower() if char.isupper() else char.upper()\n            \n            # Replace vowels\n            if swapped_char in vowels:\n                # Get the letter two positions after in the alphabet\n                if swapped_char.lower() == 'u':\n                    replacement = 'w' if swapped_char.islower() else 'W'\n                else:\n                    # For other vowels, shift by 2 positions\n                    replacement = chr(ord(swapped_char.lower()) + 2)\n                    if swapped_char.isupper():\n                        replacement = replacement.upper()\n                result.append(replacement)\n            else:\n                result.append(swapped_char)\n        else:\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["tgst", "mWDCSKR", "ygs", "tHKS KS C MGSSCGG", "k dQnT kNqW wHcT Tq wRkTg"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/94_prompt1p", "code_candidates": [{"code": "def sum_of_digits_of_largest_prime(numbers):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(n))\n    \n    primes = [num for num in numbers if num > 0 and is_prime(num)]\n    \n    if not primes:\n        return 0\n    \n    largest_prime = max(primes)\n    return sum_of_digits(largest_prime)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["10", "25", "13", "11", "3", "7", "19", "19", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/95_prompt1p", "code_candidates": [{"code": "def check_keys_case(dictionary: dict) -> bool:\n    if not dictionary:\n        return True\n    \n    keys = list(dictionary.keys())\n    \n    # Check if all keys are strings\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    # Check if all keys are lowercase or all keys are uppercase\n    all_lowercase = all(key.islower() for key in keys)\n    all_uppercase = all(key.isupper() for key in keys)\n    \n    return all_lowercase or all_uppercase", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "False", "False", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/96_prompt1p", "code_candidates": [{"code": "def first_n_primes(n: int) -> list[int]:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    primes = []\n    candidate = 2\n    \n    while len(primes) < n:\n        if is_prime(candidate):\n            primes.append(candidate)\n        candidate += 1\n    \n    return primes", "index": 0, "passed_case": [4], "case_status": ["[2, 3, 5, 7, 11]", "[2, 3, 5, 7, 11, 13]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79]", "[2]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/97_prompt1p", "code_candidates": [{"code": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their.\n    \"\"\"\n    return a * b", "index": 0, "passed_case": [6, 7], "case_status": ["60976", "532", "3739020", "-210", "5092", "459", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/98_prompt1p", "code_candidates": [{"code": "def count_upper(s):\n    if not s:\n        return 0\n    \n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    for char in s:\n        if char in uppercase_vowels:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 2], "case_status": ["0", "1", "0", "4"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/99_prompt1p", "code_candidates": [{"code": "def round_to_nearest_integer(number_string: str) -> int:\n    \"\"\"\n    Takes a string representing a number and returns the closest integer,\n    rounding to the nearest integer with ties rounding away from zero.\n    \n    Args:\n        number_string: A string representing a number\n        \n    Returns:\n        The rounded integer value\n    \"\"\"\n    # Convert string to float\n    num = float(number_string)\n    \n    # Use standard rounding (round half away from zero)\n    return round(num)", "index": 0, "passed_case": [0, 2, 3, 4], "case_status": ["10", "14", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/100_prompt1p", "code_candidates": [{"code": "def create_pile(n: int) -> list:\n    \"\"\"\n    Create a pile with n levels where the first level has n stones,\n    and each subsequent level follows a pattern based on whether n is odd or even.\n    \n    Args:\n        n: A positive integer representing the number of levels and stones in the first level\n        \n    Returns:\n        A list containing the number of stones in each level of the pile\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    pile = []\n    current_stones = n\n    \n    if n % 2 == 1:  # n is odd\n        # Next odd numbers: 1, 3, 5, 7, ...\n        for _ in range(n):\n            pile.append(current_stones)\n            current_stones += 2\n    else:  # n is even\n        # Next even numbers: 2, 4, 6, 8, ...\n        for _ in range(n):\n            pile.append(current_stones)\n            current_stones += 2\n    \n    return pile", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/101_prompt1p", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef split_words(text: str) -> List[str]:\n    if not text:\n        return []\n    \n    # Split by commas or spaces, filter out empty strings, and strip whitespace\n    words = re.split(r'[,\\s]+', text.strip())\n    return [word for word in words if word]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/102_prompt1p", "code_candidates": [{"code": "def biggest_even_in_range(x, y):\n    # Handle case where x > y\n    if x > y:\n        return None\n    \n    # Convert to integers by truncating towards zero\n    x = int(x)\n    y = int(y)\n    \n    # Handle case where x > y after conversion\n    if x > y:\n        return None\n    \n    # Start from y and go backwards to find the largest even number\n    for i in range(y, x - 1, -1):\n        if i % 2 == 0:\n            return i\n    \n    # If no even number found, return None\n    return None", "index": 0, "passed_case": [0, 2, 4, 7], "case_status": ["14", "None", "12354", "None", "28", "None", "None", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/103_prompt1p", "code_candidates": [{"code": "def compute_average(n: int, m: int) -> float:\n    if n > m:\n        return 0.0\n    \n    total = sum(range(n, m + 1))\n    count = m - n + 1\n    return total / count", "index": 0, "passed_case": [], "case_status": ["3.0", "10.0", "970.5", "996.5", "705.5", "365.5", "429.0", "626.0", "215.0", "0.0", "0.0", "5.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/104_prompt1p", "code_candidates": [{"code": "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all elements that have no repeated digits.\"\"\"\n    result = []\n    \n    for num in x:\n        str_num = str(num)\n        if len(str_num) == len(set(str_num)):\n            result.append(num)\n    \n    return sorted(result)", "index": 0, "passed_case": [], "case_status": ["[1, 15]", "[10, 152]", "[12345]", "[31, 103, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/105_prompt1p", "code_candidates": [{"code": "def sort_and_name_digits(arr):\n    # Dictionary to map digits to their English names\n    digit_to_word = {\n        1: 'one',\n        2: 'two',\n        3: 'three',\n        4: 'four',\n        5: 'five',\n        6: 'six',\n        7: 'seven',\n        8: 'eight',\n        9: 'nine'\n    }\n    \n    # Filter integers between 1 and 9 inclusive\n    filtered_digits = [x for x in arr if 1 <= x <= 9]\n    \n    # Sort the filtered digits\n    filtered_digits.sort()\n    \n    # Reverse the sorted array\n    filtered_digits.reverse()\n    \n    # Replace each digit with its English word name\n    result = [digit_to_word[x] for x in filtered_digits]\n    \n    return result", "index": 0, "passed_case": [1], "case_status": ["['eight', 'five', 'four', 'three', 'two', 'two', 'one', 'one']", "[]", "['one']", "['three', 'two', 'one']", "['nine', 'eight', 'four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/106_prompt1p", "code_candidates": [{"code": "def f(n):\n    if n <= 0:\n        return []\n    \n    result = []\n    for i in range(n):\n        if i % 2 == 0:\n            # Calculate factorial of i\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            result.append(0)\n    \n    return result", "index": 0, "passed_case": [2], "case_status": ["[1, 0, 2, 0, 24]", "[1, 0, 2, 0, 24, 0, 720]", "[1]", "[1, 0, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/107_prompt1p", "code_candidates": [{"code": "def count_even_odd_palindromes(n):\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:  # Check if palindrome\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/108_prompt1p", "code_candidates": [{"code": "def count_nums(arr):\n    def sum_of_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 5, 6, 7], "case_status": ["0", "2", "7", "6", "6", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/109_prompt1p", "code_candidates": [{"code": "def move_one_ball(arr):\n    if not arr:\n        return True\n    \n    # Create a sorted version of the array\n    sorted_arr = sorted(arr)\n    \n    # Try all possible right shifts\n    for i in range(len(arr)):\n        # Perform i right shifts\n        shifted = arr[-i:] + arr[:-i] if i > 0 else arr[:]\n        if shifted == sorted_arr:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/110_prompt1p", "code_candidates": [{"code": "def can_exchange_to_sort(list1, list2):\n    if len(list1) != len(list2):\n        return False\n    \n    # Create copies to avoid modifying originals\n    l1 = list1[:]\n    l2 = list2[:]\n    \n    # Try all possible combinations of swaps\n    # For each position, we can either swap or not swap\n    # This is a brute force approach for small lists\n    \n    def is_sorted(lst):\n        for i in range(1, len(lst)):\n            if lst[i] < lst[i-1]:\n                return False\n        return True\n    \n    # Check if lists are already sorted\n    if is_sorted(l1) and is_sorted(l2):\n        return True\n    \n    # Try all possible swap combinations\n    n = len(l1)\n    for mask in range(1 << n):  # 2^n combinations\n        # Create new lists for this combination\n        new_l1 = l1[:]\n        new_l2 = l2[:]\n        \n        # Apply swaps based on mask\n        for i in range(n):\n            if mask & (1 << i):\n                new_l1[i], new_l2[i] = new_l2[i], new_l1[i]\n        \n        # Check if both are sorted\n        if is_sorted(new_l1) and is_sorted(new_l2):\n            return True\n    \n    return False", "index": 0, "passed_case": [], "case_status": ["True", "False", "True", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/111_prompt1p", "code_candidates": [{"code": "def letter_frequency(input_string: str) -> dict:\n    \"\"\"\n    Given a string representing space-separated lowercase letters, return a dictionary \n    containing the frequency count of each letter in the input string.\n    \n    Args:\n        input_string: A string of space-separated lowercase letters\n        \n    Returns:\n        A dictionary with letter frequencies\n    \"\"\"\n    if not input_string:\n        return {}\n    \n    letters = input_string.split()\n    frequency = {}\n    \n    for letter in letters:\n        frequency[letter] = frequency.get(letter, 0) + 1\n        \n    return frequency", "index": 0, "passed_case": [0, 2, 3, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2, 'c': 1}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4, 'a': 1}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/112_prompt1p", "code_candidates": [{"code": "def is_palindrome_after_deletion(s: str, c: str) -> bool:\n    # Create a set of characters to delete for faster lookup\n    chars_to_delete = set(c)\n    \n    # Delete all characters in s that are equal to any character in c\n    filtered_string = ''.join(char for char in s if char not in chars_to_delete)\n    \n    # Check if the resulting string is a palindrome\n    return filtered_string == filtered_string[::-1]", "index": 0, "passed_case": [], "case_status": ["False", "False", "True", "False", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/113_prompt1p", "code_candidates": [{"code": "def count_odd_digits(strings):\n    \"\"\"\n    Given a list of strings containing only digits, return a list where each element\n    describes the count of odd digits in the corresponding input string.\n    \n    Args:\n        strings: List[str] - list of strings containing only digits\n        \n    Returns:\n        List[str] - list of formatted strings describing odd digit counts\n    \"\"\"\n    result = []\n    \n    for string in strings:\n        odd_count = sum(1 for digit in string if digit in '13579')\n        result.append(f'the number of odd elements in the string {odd_count} of the input.')\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["['the number of odd elements in the string 4 of the input.']", "['the number of odd elements in the string 1 of the input.', 'the number of odd elements in the string 8 of the input.']", "['the number of odd elements in the string 2 of the input.', 'the number of odd elements in the string 3 of the input.', 'the number of odd elements in the string 2 of the input.']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/114_prompt1p", "code_candidates": [{"code": "def min_subarray_sum(nums):\n    if not nums:\n        return 0\n    \n    min_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = min(nums[i], current_sum + nums[i])\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/115_prompt1p", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef min_bucket_fills(wells: List[List[int]], bucket_capacity: int) -> int:\n    \"\"\"\n    Calculate the minimum number of bucket fills needed to empty all wells.\n    \n    Args:\n        wells: A grid where each row represents a well with 1s indicating water units\n        bucket_capacity: The capacity of each bucket\n        \n    Returns:\n        The total number of bucket fills required as an integer\n        \n    Raises:\n        TypeError: If inputs are invalid\n        ValueError: If bucket_capacity is zero or negative\n    \"\"\"\n    # Handle invalid inputs\n    if not isinstance(wells, list):\n        raise TypeError(\"wells must be a list\")\n    if not isinstance(bucket_capacity, int):\n        raise TypeError(\"bucket_capacity must be an integer\")\n    \n    # Handle zero or negative capacity\n    if bucket_capacity <= 0:\n        raise ValueError(\"bucket_capacity must be positive\")\n    \n    # Handle empty grid\n    if not wells:\n        return 0\n    \n    total_water = 0\n    \n    # Count water units in each well\n    for well in wells:\n        if not isinstance(well, list):\n            raise TypeError(\"Each well must be a list\")\n        total_water += sum(well)\n    \n    # Handle empty wells\n    if total_water == 0:\n        return 0\n    \n    # Calculate minimum bucket fills needed (ceiling division)\n    return math.ceil(total_water / bucket_capacity)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["6", "5", "0", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/116_prompt1p", "code_candidates": [{"code": "def sort_array(arr):\n    \"\"\"\n    Sort array of non-negative integers by number of 1s in binary representation,\n    then by numerical value for ties.\n    \n    Args:\n        arr: List of non-negative integers\n        \n    Returns:\n        List of integers sorted by number of 1s in binary representation,\n        then by numerical value for ties\n    \"\"\"\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[1, 2, 4, 3, 5]", "[-4, -2, -6, -5, -3]", "[0, 1, 2, 4, 3]", "[]", "[2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]", "[32, 3, 5, 6, 12, 44]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/117_prompt1p", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef words_with_n_chars(s: str, n: int) -> List[str]:\n    if n <= 0:\n        return []\n    \n    # Split string into words using regex (alphanumeric characters only)\n    words = re.findall(r'[a-zA-Z0-9]+', s)\n    \n    # Filter words that have exactly n characters\n    result = [word for word in words if len(word) == n]\n    \n    return result", "index": 0, "passed_case": [2, 5], "case_status": ["['Mary', 'lamb']", "['had']", "[]", "[]", "['sam']", "[]", "['a', 'b', 'c', 'd', 'e', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/118_prompt1p", "code_candidates": [{"code": "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n    \n    vowels = set('aeiouAEIOU')\n    \n    # Iterate from right to left, looking for vowels between consonants\n    for i in range(len(word) - 2, 0, -1):\n        # Check if current character is a vowel\n        if word[i] in vowels:\n            # Check if both adjacent characters are consonants\n            if word[i-1] not in vowels and word[i+1] not in vowels:\n                return word[i]\n    \n    return \"\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["u", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/119_prompt1p", "code_candidates": [{"code": "def is_balanced_concatenation(strings):\n    if not isinstance(strings, list) or len(strings) != 2:\n        raise TypeError(\"Input must be a list of exactly two strings\")\n    \n    for s in strings:\n        if not isinstance(s, str):\n            raise TypeError(\"Input must be a list of exactly two strings\")\n        if not all(c in '()' for c in s):\n            raise TypeError(\"Strings must contain only '(' and ')' characters\")\n    \n    def is_balanced(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = strings\n    return is_balanced(s1 + s2) or is_balanced(s2 + s1)", "index": 0, "passed_case": [], "case_status": ["True", "False", "False", "True", "True", "False", "True", "False", "False", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/120_prompt1p", "code_candidates": [{"code": "from typing import List\n\ndef k_largest_elements(arr: List[int], k: int) -> List[int]:\n    if not arr or k <= 0:\n        return []\n    \n    # Sort the array in descending order and take the first k elements\n    sorted_desc = sorted(arr, reverse=True)\n    k_largest = sorted_desc[:k]\n    \n    # Return the k largest elements in ascending order\n    return sorted(k_largest)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[4, 4]", "[2]", "[2, 20, 123]", "[0, 1, 2, 20]", "[-13, -8, 0, 0, 3, 5, 15]", "[3, 5]", "[5]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/121_prompt1p", "code_candidates": [{"code": "def solution(lst):\n    total = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1:\n            total += lst[i]\n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["9", "0", "5", "0", "23", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/122_prompt1p", "code_candidates": [{"code": "def sum_two_digit_elements(arr, k):\n    \"\"\"\n    Returns the sum of elements with at most two digits from the first k elements of the array.\n    \n    Args:\n        arr: List of integers\n        k: Integer representing how many elements from the start to consider\n        \n    Returns:\n        Integer sum of elements with at most two digits (0-99)\n    \"\"\"\n    total = 0\n    for i in range(min(k, len(arr))):\n        if 0 <= arr[i] <= 99:\n            total += arr[i]\n    return total", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["1", "0", "125", "24", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/123_prompt1p", "code_candidates": [{"code": "def collatz_odds(n: int) -> list[int]:\n    odd_numbers = set()\n    current = n\n    \n    while current != 1:\n        if current % 2 == 1:\n            odd_numbers.add(current)\n        current = current // 2 if current % 2 == 0 else 3 * current + 1\n    \n    odd_numbers.add(1)\n    return sorted(list(odd_numbers))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/124_prompt1p", "code_candidates": [{"code": "import re\nfrom datetime import datetime\n\ndef validate_date(date_string: str) -> bool:\n    # Check if string is empty\n    if not date_string:\n        return False\n    \n    # Check format using regex\n    if not re.match(r'^\\d{4}-\\d{2}-\\d{2}$', date_string):\n        return False\n    \n    # Extract year, month, day\n    year = int(date_string[0:4])\n    month = int(date_string[5:7])\n    day = int(date_string[8:10])\n    \n    # Check year range\n    if year < 1000 or year > 2999:\n        return False\n    \n    # Check month range\n    if month < 1 or month > 12:\n        return False\n    \n    # Check day range\n    if day < 1 or day > 31:\n        return False\n    \n    # Validate day for given month and year\n    try:\n        datetime(year, month, day)\n        return True\n    except ValueError:\n        return False", "index": 0, "passed_case": [1, 2, 5, 6, 7, 9, 11, 12, 13, 15], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/125_prompt1p", "code_candidates": [{"code": "def split_words(txt):\n    if not txt:\n        return []\n    \n    if ' ' in txt:\n        return txt.split(' ')\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if c.islower())", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['Hello', 'world!']", "['Hello', 'world!']", "['Hello', 'world,!']", "['Hello,Hello,world', '!']", "6", "5", "4", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/126_prompt1p", "code_candidates": [{"code": "def is_sorted(lst):\n    if not lst:\n        return True\n    \n    # Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    \n    # Check if sorted in ascending order\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i-1]:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/127_prompt1p", "code_candidates": [{"code": "def intersection(interval1, interval2):\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection boundaries\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # Check if there is an intersection\n    if intersection_start <= intersection_end:\n        return (intersection_start, intersection_end)\n    else:\n        return None", "index": 0, "passed_case": [], "case_status": ["(2, 2)", "(0, 1)", "(-3, -1)", "(-2, 0)", "(-1, -1)", "None", "(1, 2)", "(-2, -2)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/128_prompt1p", "code_candidates": [{"code": "def prod_signs(arr):\n    if not arr:\n        return 0\n    \n    magnitude_sum = 0\n    sign_product = 1\n    has_nonzero = False\n    \n    for element in arr:\n        if not isinstance(element, int):\n            continue\n            \n        magnitude_sum += abs(element)\n        if element > 0:\n            sign = 1\n        elif element < 0:\n            sign = -1\n        else:\n            sign = 0\n            has_nonzero = True\n        \n        sign_product *= sign\n        if sign == 0:\n            has_nonzero = True\n    \n    if not has_nonzero and magnitude_sum == 0:\n        return 0\n    \n    return magnitude_sum * sign_product", "index": 0, "passed_case": [0, 1, 2, 4, 5, 6, 7], "case_status": ["-9", "0", "-10", "0", "20", "4", "-4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/129_prompt1p", "code_candidates": [{"code": "def min_path_k_cells(grid, k):\n    if not grid or not grid[0] or k <= 0 or k > len(grid) * len(grid[0]):\n        return []\n    \n    n = len(grid)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def dfs(row, col, path, visited):\n        if len(path) == k:\n            return path[:]\n        \n        min_path = None\n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            if (0 <= new_row < n and 0 <= new_col < n and \n                (new_row, new_col) not in visited):\n                visited.add((new_row, new_col))\n                path.append(grid[new_row][new_col])\n                result = dfs(new_row, new_col, path, visited)\n                if result:\n                    if min_path is None or result < min_path:\n                        min_path = result\n                path.pop()\n                visited.remove((new_row, new_col))\n        \n        return min_path\n    \n    min_result = None\n    for i in range(n):\n        for j in range(n):\n            visited = {(i, j)}\n            path = [grid[i][j]]\n            result = dfs(i, j, path, visited)\n            if result:\n                if min_result is None or result < min_result:\n                    min_result = result\n    \n    return min_result if min_result else []", "index": 0, "passed_case": [1], "case_status": ["[1, 2, 3]", "[1]", "[1, 2, 3, 4]", "[1, 10, 13, 4, 6, 5, 3]", "[1, 7, 4, 6, 5]", "[1, 6, 4, 2, 7, 8, 11, 5, 9]", "[1, 6, 4, 2, 7, 8, 11, 5, 9, 3, 13, 10]", "[1, 3, 2, 7, 4, 5, 9, 8]", "[1, 5, 9, 4, 7, 2, 3, 6]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/130_prompt1p", "code_candidates": [{"code": "def tri(n: int) -> int:\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 3\n    \n    # Use dynamic programming to avoid redundant calculations\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 2\n    dp[3] = 3\n    \n    for i in range(4, n + 1):\n        if i % 2 == 0:  # even\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n        else:  # odd\n            dp[i] = dp[i-1] + dp[i-2]\n    \n    return dp[n]", "index": 0, "passed_case": [], "case_status": ["3", "6", "9", "18", "27", "54", "81", "39366", "execution error: 1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/131_prompt1p", "code_candidates": [{"code": "def digits(n):\n    \"\"\"Given a positive integer n, return the product of all digits in n.\"\"\"\n    product = 1\n    for digit in str(n):\n        product *= int(digit)\n    return product", "index": 0, "passed_case": [0], "case_status": ["5", "20", "0", "15120", "63000", "384"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/132_prompt1p", "code_candidates": [{"code": "def is_nested(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets where each opening bracket '[' has a corresponding closing bracket ']' and the brackets are properly nested.\n    '''\n    if not string:\n        return False\n    \n    # Count of open brackets\n    open_count = 0\n    # Maximum depth reached\n    max_depth = 0\n    \n    for char in string:\n        if char == '[':\n            open_count += 1\n            max_depth = max(max_depth, open_count)\n        elif char == ']':\n            open_count -= 1\n            if open_count < 0:\n                return False\n    \n    # Valid if all brackets are matched and we had at least one pair\n    return open_count == 0 and max_depth > 0", "index": 0, "passed_case": [0, 1, 4, 5, 6, 7, 8, 10, 11, 12, 13], "case_status": ["True", "False", "True", "True", "True", "False", "True", "False", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/133_prompt1p", "code_candidates": [{"code": "def sum_squares(lst):\n    \"\"\"You are given a list of numbers. You need to return the sum of squared elements in the list. For each element in the list, square it and then sum all the squared values. Return 0 for empty lists.\"\"\"\n    return sum(x ** 2 for x in lst)", "index": 0, "passed_case": [0, 2, 5, 6, 9, 10, 11], "case_status": ["14", "14.0", "84", "19.6", "7.76", "10230", "200000000", "62.809999999999995", "1075.59", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/134_prompt1p", "code_candidates": [{"code": "def is_last_char_letter(s: str) -> bool:\n    \"\"\"\n    Returns True if the last character of a given string is a letter, and False if the last character is not a letter.\n    \n    Args:\n        s: A string\n        \n    Returns:\n        bool: True if last character is a letter, False otherwise\n    \"\"\"\n    if not s:\n        return False\n    \n    return s[-1].isalpha()", "index": 0, "passed_case": [1, 3, 4, 5, 6, 7, 9], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/135_prompt1p", "code_candidates": [{"code": "def find_largest_non_increasing_index(nums):\n    \"\"\"\n    Find the largest index of an element that is not greater than or equal to the previous element.\n    \n    Args:\n        nums: List of numbers\n        \n    Returns:\n        int: Largest index where current element < previous element, or -1 if none exists\n    \"\"\"\n    if len(nums) < 2:\n        return -1\n    \n    largest_index = -1\n    \n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            largest_index = i\n    \n    return largest_index", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["3", "-1", "2", "4", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/136_prompt1p", "code_candidates": [{"code": "def find_extremes(numbers):\n    \"\"\"\n    Returns a tuple (a, b) where 'a' is the largest negative integer \n    and 'b' is the smallest positive integer.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        tuple: (largest_negative, smallest_positive)\n    \"\"\"\n    if not numbers:\n        return (None, None)\n    \n    largest_negative = None\n    smallest_positive = None\n    \n    for num in numbers:\n        if num < 0:\n            if largest_negative is None or num > largest_negative:\n                largest_negative = num\n        elif num > 0:\n            if smallest_positive is None or num < smallest_positive:\n                smallest_positive = num\n        # Skip zero (num == 0)\n    \n    return (largest_negative, smallest_positive)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["(None, 1)", "(None, 1)", "(-2, 1)", "(-7, 2)", "(-9, 2)", "(None, None)", "(None, None)", "(-1, None)", "(-1, None)", "(-3, 1)", "(-3, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/137_prompt1p", "code_candidates": [{"code": "def compare_one(a, b):\n    \"\"\"\n    Return the larger of the two values representing real numbers.\n    \n    Args:\n        a: First value (int, float, or string representation of a number)\n        b: Second value (int, float, or string representation of a number)\n        \n    Returns:\n        The larger of the two values, preserving the type of the larger value\n    \"\"\"\n    # Convert string representations to numbers for comparison\n    def to_number(x):\n        if isinstance(x, str):\n            try:\n                return float(x)\n            except ValueError:\n                return x\n        return x\n    \n    num_a = to_number(a)\n    num_b = to_number(b)\n    \n    # Handle comparison\n    if isinstance(num_a, (int, float)) and isinstance(num_b, (int, float)):\n        if num_a > num_b:\n            return a\n        elif num_b > num_a:\n            return b\n        else:\n            return a  # Return first if equal\n    else:\n        # If one or both are not numeric, compare as strings\n        if str(a) > str(b):\n            return a\n        elif str(b) > str(a):\n            return b\n        else:\n            return a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "2.5", "3", "6", "2,3", "6", "2", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/138_prompt1p", "code_candidates": [{"code": "def can_be_sum_of_four_equal_integers(n: int) -> bool:\n    \"\"\"\n    Evaluate whether the given number n can be written as the sum of exactly 4 equal positive integers.\n    \n    Args:\n        n: An integer to evaluate\n        \n    Returns:\n        True if n can be written as sum of 4 equal positive integers, False otherwise\n    \"\"\"\n    # For n to be sum of 4 equal positive integers, n must be divisible by 4\n    # and the result must be a positive integer\n    if n <= 0:\n        return False\n    \n    return n % 4 == 0", "index": 0, "passed_case": [1, 2, 4, 5, 6, 7], "case_status": ["True", "False", "True", "False", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/139_prompt1p", "code_candidates": [{"code": "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as: n! * (n-1)! * (n-2)! * ... * 1! where n! represents the standard factorial of n. For example, special_factorial(4) = 4! * 3! * 2! * 1! = 24 * 6 * 2 * 1 = 288.\"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    \n    if n == 0:\n        return 1\n    \n    def factorial(num):\n        if num <= 1:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n    \n    result = 1\n    for i in range(n, 0, -1):\n        result *= factorial(i)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/140_prompt1p", "code_candidates": [{"code": "import re\n\ndef replace_spaces(text: str) -> str:\n    if not text:\n        return text\n    \n    # Replace 3 or more consecutive spaces with a single underscore\n    result = re.sub(r' {3,}', '_', text)\n    # Replace remaining single spaces with underscores\n    result = result.replace(' ', '_')\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["Example", "Mudasir_Hanif_", "Yellow_Yellow__Dirty__Fellow", "Exa_mple", "_Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/141_prompt1p", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef validate_file_name(file_name: str) -> bool:\n    if not file_name:\n        return False\n    \n    if len(file_name) < 1 or len(file_name) > 100:\n        return False\n    \n    if file_name.startswith('_') or file_name.startswith('-') or file_name.endswith('_') or file_name.endswith('-'):\n        return False\n    \n    if file_name.count('.') != 1:\n        return False\n    \n    name_part, extension = file_name.split('.')\n    \n    if not name_part:\n        return False\n    \n    valid_extensions = {'.txt', '.pdf', '.doc', '.docx', '.jpg', '.png'}\n    if f'.{extension}' not in valid_extensions:\n        return False\n    \n    if not re.match(r'^[a-zA-Z][a-zA-Z0-9_-]*[a-zA-Z0-9]$', file_name):\n        return False\n    \n    if re.search(r'[_-]{2,}', file_name):\n        return False\n    \n    return True", "index": 0, "passed_case": [], "case_status": ["False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/142_prompt1p", "code_candidates": [{"code": "def compute_transformed_sum(numbers):\n    if not numbers:\n        return 0\n    \n    total = 0\n    for i, num in enumerate(numbers):\n        if i % 12 == 0:  # Multiple of both 3 and 4\n            total += (num ** 2) * 2\n        elif i % 3 == 0:  # Multiple of 3 only\n            total += num ** 2\n        elif i % 4 == 0:  # Multiple of 4 only\n            total += num * 2\n        else:  # All other entries\n            total += num\n    \n    return total", "index": 0, "passed_case": [2, 5, 8], "case_status": ["7", "15", "0", "12", "-4", "0", "-10", "6170", "0", "4072", "746"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/143_prompt1p", "code_candidates": [{"code": "def first_last_words(sentence: str) -> tuple:\n    if not sentence or not sentence.strip():\n        return (\"\", \"\")\n    \n    words = sentence.strip().split()\n    \n    if len(words) == 1:\n        return (words[0], words[0])\n    elif len(words) == 2:\n        return (words[0], words[1])\n    else:\n        return (words[0], words[-1])", "index": 0, "passed_case": [], "case_status": ["('This', 'test')", "('lets', 'swimming')", "('there', 'here')", "('Hi', 'Hussein')", "('go', 'it')", "('here', 'here')", "('here', 'is')"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/144_prompt1p", "code_candidates": [{"code": "from math import gcd\nfrom typing import Tuple\n\ndef simplify_fraction(x: Tuple[int, int], n: Tuple[int, int]) -> Tuple[int, int]:\n    \"\"\"\n    Simplifies the fraction x/n where x and n are valid fractions with non-zero denominators.\n    \n    Args:\n        x: A tuple representing the numerator and denominator of the first fraction\n        n: A tuple representing the numerator and denominator of the second fraction\n    \n    Returns:\n        A tuple representing the simplified fraction in lowest terms\n    \"\"\"\n    # Calculate the resulting fraction after division: x/n = x * (1/n) = (x[0]*n[1]) / (x[1]*n[0])\n    numerator = x[0] * n[1]\n    denominator = x[1] * n[0]\n    \n    # Handle edge cases\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    \n    # Handle negative fractions - ensure denominator is positive\n    if denominator < 0:\n        numerator = -numerator\n        denominator = -denominator\n    \n    # Find the GCD and simplify\n    common_divisor = gcd(abs(numerator), abs(denominator))\n    simplified_numerator = numerator // common_divisor\n    simplified_denominator = denominator // common_divisor\n    \n    return (simplified_numerator, simplified_denominator)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/145_prompt1p", "code_candidates": [{"code": "def order_by_points(nums):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Create list of tuples (digit_sum, original_index, value)\n    indexed_nums = [(digit_sum(num), i, num) for i, num in enumerate(nums)]\n    \n    # Sort by digit sum first, then by original index\n    indexed_nums.sort(key=lambda x: (x[0], x[1]))\n    \n    # Extract the values in the new order\n    return [num for _, _, num in indexed_nums]", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/146_prompt1p", "code_candidates": [{"code": "def count_special_numbers(numbers: list) -> int:\n    \"\"\"\n    Filters numbers based on 'special' criteria (divisible by 3 and greater than 10)\n    and returns the count of filtered numbers.\n    \n    Args:\n        numbers: List of numbers to filter\n        \n    Returns:\n        Count of numbers that meet the special criteria\n    \"\"\"\n    count = 0\n    for num in numbers:\n        if num > 10 and num % 3 == 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 5, 6], "case_status": ["0", "1", "3", "1", "2", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/147_prompt1p", "code_candidates": [{"code": "def max_sum_of_three_elements(n: int) -> int:\n    if n < 3:\n        return None\n    \n    # Generate the array where a[i] = i * i - i + 1 for i from 1 to n\n    array = []\n    for i in range(1, n + 1):\n        value = i * i - i + 1\n        array.append(value)\n    \n    # Sort the array in descending order to get the three largest elements\n    array.sort(reverse=True)\n    \n    # Return the sum of the first three elements\n    return array[0] + array[1] + array[2]", "index": 0, "passed_case": [], "case_status": ["41", "65", "221", "29111"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/148_prompt1p", "code_candidates": [{"code": "def planets_between(planet1: str, planet2: str) -> list:\n    solar_system = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n    \n    # Check if both planets are valid and different\n    if planet1 not in solar_system or planet2 not in solar_system or planet1 == planet2:\n        return []\n    \n    # Get indices of both planets\n    index1 = solar_system.index(planet1)\n    index2 = solar_system.index(planet2)\n    \n    # Determine the range (exclusive of the input planets)\n    start_index = min(index1, index2)\n    end_index = max(index1, index2)\n    \n    # Return the planets between (exclusive)\n    return solar_system[start_index + 1:end_index]", "index": 0, "passed_case": [], "case_status": ["['Saturn', 'Uranus']", "['Venus']", "['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn']", "['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus']", "[]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/149_prompt1p", "code_candidates": [{"code": "def filter_and_sort_strings(strings: list[str]) -> list[str]:\n    \"\"\"\n    Filters out strings with odd lengths and returns a sorted list of strings with even lengths.\n    \n    Args:\n        strings: A list of strings\n        \n    Returns:\n        A sorted list of strings with even lengths\n    \"\"\"\n    # Filter strings with even lengths\n    even_length_strings = [s for s in strings if len(s) % 2 == 0]\n    \n    # Sort the filtered strings\n    return sorted(even_length_strings)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['aa']", "['AI', 'asdf', 'school']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['aaaa', 'bbbb', 'cc', 'dd']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/150_prompt1p", "code_candidates": [{"code": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_check(n, x, y):\n    \"\"\"\n    Return x if n is prime, otherwise return y.\n    \n    Args:\n        n: The number to check for primality\n        x: Value to return if n is prime\n        y: Value to return if n is not prime\n    \n    Returns:\n        x if n is prime, otherwise y\n    \"\"\"\n    return x if is_prime(n) else y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["34", "5", "33", "3", "-1", "583", "129", "1234", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/151_prompt1p", "code_candidates": [{"code": "def sum_of_squares(numbers):\n    \"\"\"\n    Return the sum of squares of the numbers that are non-negative (>= 0).\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        int/float: Sum of squares of non-negative numbers, or 0 for empty lists\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    return sum(x**2 for x in numbers if x >= 0)", "index": 0, "passed_case": [0, 3, 6], "case_status": ["0", "41", "0.14", "0", "64", "34.04", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/152_prompt1p", "code_candidates": [{"code": "def compare(game, guess):\n    if len(game) != len(guess):\n        raise ValueError('Lists must be of equal length')\n    \n    return [game[i] - guess[i] for i in range(len(game))]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/153_prompt1p", "code_candidates": [{"code": "def strongest_extension(class_name: str, extensions: list) -> str:\n    if not extensions:\n        return None\n    \n    max_strength = float('-inf')\n    strongest_ext = None\n    \n    for ext in extensions:\n        if not isinstance(ext, str):\n            raise TypeError(\"All extensions must be strings\")\n        \n        uppercase_count = sum(1 for c in ext if c.isupper())\n        lowercase_count = sum(1 for c in ext if c.islower())\n        strength = uppercase_count - lowercase_count\n        \n        if strength > max_strength:\n            max_strength = strength\n            strongest_ext = ext\n    \n    return strongest_ext", "index": 0, "passed_case": [], "case_status": ["eIGHt8OKe", "YEs.WeCaNe", "NuLl__", "TAR", "123", "okIWILL123", "WoW", "Bb", "671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/154_prompt1p", "code_candidates": [{"code": "def cycpattern_check(a, b):\n    if not b:\n        return True\n    if not a:\n        return False\n    \n    # Check if b is a substring of a+a\n    double_a = a + a\n    return b in double_a", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["False", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/155_prompt1p", "code_candidates": [{"code": "def count_even_odd_digits(n: int) -> tuple[int, int]:\n    \"\"\"Count even and odd digits in the absolute value of the input integer.\n    \n    Args:\n        n: An integer (can be negative)\n        \n    Returns:\n        A tuple (even_count, odd_count) where even_count is the number of even digits\n        and odd_count is the number of odd digits in the absolute value of n\n    \"\"\"\n    # Take absolute value to handle negative numbers\n    abs_n = abs(n)\n    \n    # Convert to string to easily iterate through digits\n    digits_str = str(abs_n)\n    \n    even_count = 0\n    odd_count = 0\n    \n    for digit_char in digits_str:\n        digit = int(digit_char)\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(1, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/156_prompt1p", "code_candidates": [{"code": "def int_to_mini_roman(number):\n    if not 1 <= number <= 1000:\n        raise ValueError(\"Number must be between 1 and 1000\")\n    \n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    \n    result = []\n    for i in range(len(values)):\n        count = number // values[i]\n        if count:\n            result.append(symbols[i] * count)\n            number -= values[i] * count\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/157_prompt1p", "code_candidates": [{"code": "def is_right_triangle(a, b, c):\n    \"\"\"\n    Determines if three given side lengths form a right-angled triangle.\n    \n    Args:\n        a, b, c: Side lengths (int or float)\n        \n    Returns:\n        bool: True if the sides form a right triangle, False otherwise\n        \n    Raises:\n        TypeError: If any side is zero, negative, or non-numeric\n    \"\"\"\n    # Validate inputs\n    for side in [a, b, c]:\n        if not isinstance(side, (int, float)):\n            raise TypeError(\"All sides must be numeric\")\n        if side <= 0:\n            raise TypeError(\"All sides must be positive numbers\")\n    \n    # Sort sides to identify the longest side (potential hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check Pythagorean theorem: a\u00b2 + b\u00b2 = c\u00b2\n    # Using a small tolerance for floating point comparison\n    return abs(sides[0]**2 + sides[1]**2 - sides[2]**2) < 1e-10", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/158_prompt1p", "code_candidates": [{"code": "def find_max(words):\n    \"\"\"Write a function that accepts a list of strings. The list contains different words. Return the word that is maximum according to lexicographic (alphabetical) order. If multiple words are tied for the maximum, return the first one encountered in the list.\"\"\"\n    if not words:\n        return None\n    \n    max_word = words[0]\n    for word in words[1:]:\n        if word > max_word:\n            max_word = word\n    \n    return max_word", "index": 0, "passed_case": [0, 7, 8, 9], "case_status": ["string", "name", "cc", "cba", "this", "we", "we", "this", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/159_prompt1p", "code_candidates": [{"code": "def calculate_carrots_eaten(already_eaten: int, number: int, available: int) -> int:\n    \"\"\"\n    Calculate total carrots eaten by a rabbit.\n    \n    Args:\n        already_eaten: Number of carrots already eaten\n        number: Additional carrots the rabbit needs to eat\n        available: Number of carrots available\n    \n    Returns:\n        Total carrots eaten (already eaten + additional eaten)\n    \n    Raises:\n        ValueError: If any input is negative\n    \"\"\"\n    if already_eaten < 0 or number < 0 or available < 0:\n        raise ValueError(\"All inputs must be non-negative\")\n    \n    if number == 0:\n        return already_eaten\n    \n    if available == 0:\n        return already_eaten\n    \n    # Calculate how many additional carrots can actually be eaten\n    additional_eaten = min(number, available)\n    \n    return already_eaten + additional_eaten", "index": 0, "passed_case": [], "case_status": ["11", "12", "11", "7", "9", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/160_prompt1p", "code_candidates": [{"code": "def calculate_result(operators, operands):\n    if not operators and not operands:\n        return 0\n    \n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"Mismatched list lengths\")\n    \n    if not operands:\n        return 0\n    \n    result = operands[0]\n    \n    for i, op in enumerate(operators):\n        if op not in ['+', '-', '*', '/']:\n            raise ValueError(f\"Invalid operation: {op}\")\n        \n        operand = operands[i + 1]\n        \n        if op == '+':\n            result += operand\n        elif op == '-':\n            result -= operand\n        elif op == '*':\n            result *= operand\n        elif op == '/':\n            result /= operand\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "15", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/161_prompt1p", "code_candidates": [{"code": "def solve(s):\n    \"\"\"\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n    result = []\n    for char in s:\n        if char.islower():\n            result.append(char.upper())\n        elif char.isupper():\n            result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result[::-1])", "index": 0, "passed_case": [1, 5], "case_status": ["FdSa", "4321", "BA", "c@A#", "54^wFDSa#", "2@6#", "d^A$#", "CCC#"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/162_prompt1p", "code_candidates": [{"code": "import hashlib\nfrom typing import Union\n\ndef get_md5_hash(input_string: Union[str, None]) -> str:\n    if input_string is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not isinstance(input_string, str):\n        raise TypeError(\"Input must be a string\")\n    \n    return hashlib.md5(input_string.encode('utf-8')).hexdigest()", "index": 0, "passed_case": [0, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "d41d8cd98f00b204e9800998ecf8427e", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/163_prompt1p", "code_candidates": [{"code": "def even_digits_in_range(a: int, b: int) -> list:\n    if a > b:\n        return []\n    \n    result = []\n    for num in range(a, b + 1):\n        for digit_char in str(num):\n            if digit_char in '02468':\n                result.append(int(digit_char))\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[2, 4, 6, 8, 0]", "[]", "[]", "[8, 2, 0, 2, 2, 2, 2, 2, 4, 2, 2, 6, 2, 2, 8, 2, 0, 2, 4, 6, 8, 4, 0, 4, 4, 2, 4, 4, 4, 4, 4, 6, 4, 4, 8, 4, 0, 2, 4, 6, 8, 6, 0, 6, 6, 2, 6, 6, 4, 6, 6, 6, 6, 6, 8, 6, 0, 2, 4, 6, 8, 8, 0, 8, 8, 2, 8, 8, 4, 8, 8, 6, 8, 8, 8, 8]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt1p"}
{"name": "HumanEval/0_prompt2ac", "code_candidates": [{"code": "def has_close_numbers(numbers, threshold):\n    \"\"\"\n    Check if there are any two numbers in the list that are within the given threshold distance of each other.\n    \n    Args:\n        numbers: List of numbers\n        threshold: The maximum allowed distance between numbers\n        \n    Returns:\n        bool: True if such a pair exists, False otherwise\n    \"\"\"\n    if not numbers or len(numbers) < 2:\n        return False\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/1_prompt2ac", "code_candidates": [{"code": "def separate_parenthesized_groups(s: str) -> list:\n    \"\"\"\n    Separate parenthesized groups into individual strings, handling nesting and balancing.\n    \n    Args:\n        s: Input string containing parenthesized groups\n        \n    Returns:\n        List of strings, each containing a complete balanced parentheses expression\n    \"\"\"\n    result = []\n    current_group = \"\"\n    balance = 0\n    \n    for char in s:\n        if char == '(':\n            balance += 1\n            current_group += char\n        elif char == ')':\n            balance -= 1\n            current_group += char\n            if balance == 0:\n                result.append(current_group)\n                current_group = \"\"\n        else:\n            current_group += char\n    \n    return result", "index": 0, "passed_case": [2], "case_status": ["['(()())', ' ((()))', ' ()', ' ((())()())']", "['()', ' (())', ' ((()))', ' (((())))']", "['(()(())((())))']", "['( )', ' (( ))', ' (( )( ))']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/2_prompt2ac", "code_candidates": [{"code": "import math\n\ndef floor(number: float) -> int:\n    \"\"\"\n    Return the integer part (floor) of a positive floating point number.\n    \n    Args:\n        number: A positive floating point number\n        \n    Returns:\n        The largest integer less than or equal to the given number\n    \"\"\"\n    return math.floor(number)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/3_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/4_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if not numbers:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/5_prompt2ac", "code_candidates": [{"code": "def insert_at_end(lst: list, x) -> list:\n    if not lst:\n        return [x]\n    else:\n        lst.append(x)\n        return lst", "index": 0, "passed_case": [], "case_status": ["[7]", "[5, 6, 3, 2, 8]", "[2, 2, 2, 2]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/6_prompt2ac", "code_candidates": [{"code": "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by certain characters.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (() ()) has maximum two levels of nesting while ((( ))) has three.\n\n    >>> parse_nested_parens('(()())((()))()((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    current_depth = 0\n    max_depth = 0\n    \n    for char in paren_string:\n        if char == '(':\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char == ')':\n            current_depth -= 1\n        elif char == ' ' or char == ',' or char == ';':  # Assuming these are separators\n            if max_depth > 0:\n                result.append(max_depth)\n                max_depth = 0\n    \n    # Handle the case where the string doesn't end with a separator\n    if max_depth > 0:\n        result.append(max_depth)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/7_prompt2ac", "code_candidates": [{"code": "def filter_strings_with_substring(strings: list[str], x: str) -> list[str]:\n    \"\"\"\n    Filter a list of strings to return only those that contain the specified substring x.\n    \n    Args:\n        strings: List of strings to filter\n        x: Substring to search for\n        \n    Returns:\n        List of strings containing the substring x\n    \"\"\"\n    if not strings:\n        return []\n    \n    return [s for s in strings if x in s]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/8_prompt2ac", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef sum_and_product(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    product = 1\n    for num in numbers:\n        product *= num\n    \n    return (total_sum, product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/9_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef rolling_maximum(numbers: List[int]) -> List[int]:\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/10_prompt2ac", "code_candidates": [{"code": "def shortest_palindrome(s: str) -> str:\n    if not s:\n        return s\n    \n    # Create a string: s + '#' + reverse(s)\n    # The '#' is a separator to avoid overlap\n    combined = s + '#' + s[::-1]\n    \n    # Compute the KMP failure function (partial match table)\n    def compute_lps(pattern):\n        lps = [0] * len(pattern)\n        length = 0\n        i = 1\n        \n        while i < len(pattern):\n            if pattern[i] == pattern[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n        return lps\n    \n    # Get the LPS array for the combined string\n    lps = compute_lps(combined)\n    \n    # The last value in LPS tells us the longest prefix of s\n    # that matches a suffix of reverse(s)\n    # So we need to add only the remaining part of reverse(s)\n    # to make it a palindrome\n    chars_to_add = len(s) - lps[-1]\n    \n    # Append the reverse of the prefix that doesn't match\n    return s + s[:chars_to_add][::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["", "x", "xyzyx", "xyx", "jerryrrej"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/11_prompt2ac", "code_candidates": [{"code": "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform bitwise XOR operation on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["010010", "0", "0101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/12_prompt2ac", "code_candidates": [{"code": "def longest_string(strings: list[str]) -> str | None:\n    if not strings:\n        return None\n    \n    longest = strings[0]\n    for string in strings:\n        if len(string) > len(longest):\n            longest = string\n    \n    return longest", "index": 0, "passed_case": [0, 1, 2], "case_status": ["None", "x", "zzzz"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/13_prompt2ac", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\"\n    Return the greatest common divisor of two integers a and b.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        The greatest common divisor of a and b\n    \"\"\"\n    # Handle edge cases\n    if a == 0:\n        return abs(b)\n    if b == 0:\n        return abs(a)\n    \n    # Use Euclidean algorithm\n    a, b = abs(a), abs(b)\n    while b:\n        a, b = b, a % b\n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/14_prompt2ac", "code_candidates": [{"code": "def all_prefixes(s: str) -> list:\n    if not s:\n        return ['']\n    return [s[:i] for i in range(len(s), 0, -1)]", "index": 0, "passed_case": [], "case_status": ["['']", "['asdfgh', 'asdfg', 'asdf', 'asd', 'as', 'a']", "['WWW', 'WW', 'W']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/15_prompt2ac", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing dot or space-delimited numbers starting from 0 upto a certain number inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0.1.2.3.4.5'\n    \"\"\"\n    return '.'.join(str(i) for i in range(n + 1))", "index": 0, "passed_case": [0], "case_status": ["0", "0.1.2.3", "0.1.2.3.4.5.6.7.8.9.10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/16_prompt2ac", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many characters (regardless of case) does it consist of\n    >>> count_distinct_characters('xyzXYZ')\n    6\n    >>> count_distinct_characters('Jerry')\n    5\n    \"\"\"\n    return len(set(string.lower()))", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/17_prompt2ac", "code_candidates": [{"code": "def parse_music(music_string: str) -> list[int]:\n    \"\"\"\n    Parse a music string and return a list of beat durations for each note.\n    \n    'o' represents a whole note (1 beat)\n    'o|' represents a half note (4 beats)  \n    '.|' represents a quarter note (2 beats)\n    \n    Args:\n        music_string: A string containing music notes\n        \n    Returns:\n        A list of integers representing beat durations\n    \"\"\"\n    if not music_string:\n        return []\n    \n    result = []\n    i = 0\n    \n    while i < len(music_string):\n        if music_string[i] == 'o':\n            if i + 1 < len(music_string) and music_string[i + 1] == '|':\n                result.append(4)  # half note\n                i += 2\n            else:\n                result.append(1)  # whole note\n                i += 1\n        elif music_string[i] == '.':\n            if i + 1 < len(music_string) and music_string[i + 1] == '|':\n                result.append(2)  # quarter note\n                i += 2\n            else:\n                i += 1  # invalid pattern, skip\n        else:\n            i += 1  # skip invalid characters\n    \n    return result", "index": 0, "passed_case": [0], "case_status": ["[]", "[1, 1, 1, 1]", "[2, 2, 2, 2]", "[4, 4, 2, 2, 1, 1, 1, 1]", "[4, 2, 4, 2, 1, 4, 1, 4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/18_prompt2ac", "code_candidates": [{"code": "def how_many_times(a: str, b: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlapping cases. \"\"\"\n    if not b or not a:\n        return 0\n    \n    count = 0\n    start = 0\n    \n    while True:\n        pos = a.find(b, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/19_prompt2ac", "code_candidates": [{"code": "def sort_number_words_desc(words: list) -> list:\n    word_to_num = {\n        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,\n        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9\n    }\n    \n    return sorted(words, key=lambda word: word_to_num[word], reverse=True)", "index": 0, "passed_case": [], "case_status": ["[]", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/20_prompt2ac", "code_candidates": [{"code": "def find_farthest_elements(numbers):\n    if not numbers or len(numbers) < 2:\n        return None\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    return (min_val, max_val)", "index": 0, "passed_case": [], "case_status": ["(1.0, 5.0)", "(1.0, 5.9)", "(1.0, 5.0)", "(1.0, 5.0)", "(1.1, 5.1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/21_prompt2ac", "code_candidates": [{"code": "def rescale_numbers(numbers):\n    \"\"\"\n    Rescale a list of numbers using linear transformation where the minimum value becomes 0 \n    and maximum value becomes 1, with all other values scaled proportionally between 0 and 1.\n    If all elements in the list are identical, return a list of zeros.\n    \n    Args:\n        numbers: List of numbers to rescale\n        \n    Returns:\n        List of rescaled numbers between 0 and 1\n    \"\"\"\n    if not numbers:\n        return []\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    # If all elements are identical\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    \n    # Apply linear transformation\n    range_val = max_val - min_val\n    return [(x - min_val) / range_val for x in numbers]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[0.0, 1.0]", "[1.0, 0.0]", "[0.0, 0.25, 0.5, 0.75, 1.0]", "[0.25, 0.0, 1.0, 0.5, 0.75]", "[0.25, 0.0, 1.0, 0.5, 0.75]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/22_prompt2ac", "code_candidates": [{"code": "def filter_integers(mixed_list):\n    \"\"\"\n    Filter out integers from a list of mixed types.\n    \n    Args:\n        mixed_list: A list containing mixed data types\n        \n    Returns:\n        A new list containing all elements that are not of type int\n    \"\"\"\n    return [item for item in mixed_list if not isinstance(item, int)]", "index": 0, "passed_case": [0], "case_status": ["[]", "[{}, [], 23.2, 'adasd']", "['c', 'a', 'b']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/23_prompt2ac", "code_candidates": [{"code": "def longest_palindrome(s: str) -> int:\n    if not s:\n        return 0\n    \n    def expand_around_center(left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    max_length = 1\n    for i in range(len(s)):\n        # Odd length palindromes\n        len1 = expand_around_center(i, i)\n        # Even length palindromes\n        len2 = expand_around_center(i, i + 1)\n        max_length = max(max_length, len1, len2)\n    \n    return max_length", "index": 0, "passed_case": [0, 1], "case_status": ["0", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/24_prompt2ac", "code_candidates": [{"code": "def largest_proper_divisor(n: int) -> int:\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    \n    # Start from n//2 and go down to 1\n    # The first divisor we find will be the largest\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            return i\n    \n    # This should never be reached for n > 1\n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/25_prompt2ac", "code_candidates": [{"code": "def factors(n: int) -> list[int]:\n    if n == 0:\n        return []\n    \n    result = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            result.append(i)\n            if i != n // i:\n                result.append(n // i)\n    \n    return sorted(result)", "index": 0, "passed_case": [], "case_status": ["[1, 2]", "[1, 2, 4]", "[1, 2, 4, 8]", "[1, 3, 19, 57]", "[1, 3, 9, 19, 57, 171, 361, 1083, 3249]", "[1, 3, 9, 19, 27, 57, 171, 361, 513, 1083, 3249, 6859, 9747, 20577, 61731, 185193]", "[1, 3, 19, 57, 361, 1083, 6859, 20577]", "[1, 2, 3, 6, 9, 18]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/26_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef remove_k_occurrences(nums: List[int], k: int) -> List[int]:\n    # Count occurrences of each number\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Filter out numbers that occur exactly k times\n    result = []\n    for num in nums:\n        if count[num] != k:\n            result.append(num)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/27_prompt2ac", "code_candidates": [{"code": "def flip_case(s: str) -> str:\n    \"\"\"\n    Flip the case of all alphabetic characters in a string.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        String with flipped case for alphabetic characters\n    \"\"\"\n    if not s:\n        return \"\"\n    \n    result = []\n    for char in s:\n        if char.islower():\n            result.append(char.upper())\n        elif char.isupper():\n            result.append(char.lower())\n        else:\n            result.append(char)\n    \n    return \"\".join(result)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/28_prompt2ac", "code_candidates": [{"code": "def concatenate_reverse(strings: List[str]) -> str:\n    return ' '.join(strings[::-1])", "index": 0, "passed_case": [0], "case_status": ["", "z y x", "k w z y x"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/29_prompt2ac", "code_candidates": [{"code": "def filter_strings_not_starting_with(strings: list[str], prefix: str) -> list[str]:\n    \"\"\"\n    Filter strings that do NOT start with the given prefix.\n    \n    Args:\n        strings: List of strings to filter\n        prefix: Prefix to check against\n        \n    Returns:\n        List of strings that do not start with the prefix\n    \"\"\"\n    return [s for s in strings if not s.startswith(prefix)]", "index": 0, "passed_case": [0], "case_status": ["[]", "['asd', 'xxy', 'john doe']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/30_prompt2ac", "code_candidates": [{"code": "def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [-1, -4]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-5, -3, -10]\n    \"\"\"\n    return [num for num in l if num < 0]", "index": 0, "passed_case": [3], "case_status": ["[-1, -2]", "[-5, -10]", "[-1, -2]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/31_prompt2ac", "code_candidates": [{"code": "def is_composite(n):\n    \"\"\"\n    Check if a given number is composite (not prime).\n    \n    Args:\n        n (int): The number to check\n        \n    Returns:\n        bool: True if the number is composite, False if prime or less than 2\n    \"\"\"\n    # Numbers less than 2 are neither prime nor composite\n    if n < 2:\n        return False\n    \n    # 2 and 3 are prime numbers\n    if n == 2 or n == 3:\n        return False\n    \n    # Even numbers greater than 2 are composite\n    if n % 2 == 0:\n        return True\n    \n    # Check for odd divisors up to sqrt(n)\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += 2\n    \n    # If no divisors found, the number is prime\n    return False", "index": 0, "passed_case": [6], "case_status": ["True", "False", "False", "False", "False", "True", "False", "False", "False", "False", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/32_prompt2ac", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef candidate(xs: List[float]) -> float:\n    if not xs:\n        raise ValueError(\"Empty coefficient list\")\n    \n    if all(x == 0 for x in xs):\n        raise ValueError(\"All coefficients are zero\")\n    \n    # Handle constant polynomial\n    if len(xs) == 1:\n        raise ValueError(\"No real zeros for constant polynomial\")\n    \n    # For linear polynomial: xs[0] + xs[1]*x = 0\n    if len(xs) == 2:\n        if xs[1] == 0:\n            raise ValueError(\"No real zeros for constant polynomial\")\n        return -xs[0] / xs[1]\n    \n    # For higher degree polynomials, use numerical method (Newton-Raphson)\n    def poly(x):\n        result = 0\n        for i, coeff in enumerate(xs):\n            result += coeff * (x ** i)\n        return result\n    \n    def derivative(x):\n        result = 0\n        for i in range(1, len(xs)):\n            result += i * xs[i] * (x ** (i - 1))\n        return result\n    \n    # Try different starting points\n    for start in [0, 1, -1, 0.5, -0.5, 2, -2]:\n        x = start\n        for _ in range(1000):  # Maximum iterations\n            fx = poly(x)\n            if abs(fx) < 1e-10:  # Found zero\n                return x\n            dfx = derivative(x)\n            if abs(dfx) < 1e-15:  # Avoid division by zero\n                break\n            x_new = x - fx / dfx\n            if abs(x_new - x) < 1e-12:  # Converged\n                return x_new\n            x = x_new\n    \n    # If no convergence, try a few more approaches\n    # Try bisection method for simpler cases\n    if len(xs) == 3:  # Quadratic\n        a, b, c = xs[0], xs[1], xs[2]\n        discriminant = b * b - 4 * a * c\n        if discriminant >= 0:\n            sqrt_disc = math.sqrt(discriminant)\n            root1 = (-b - sqrt_disc) / (2 * c)\n            root2 = (-b + sqrt_disc) / (2 * c)\n            # Return one of the roots\n            return root1 if abs(poly(root1)) < abs(poly(root2)) else root2\n    \n    raise ValueError(\"No real zero found\")", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/33_prompt2ac", "code_candidates": [{"code": "def sort_divisible_by_three_desc(lst):\n    \"\"\"\n    Sort elements at indices divisible by 3 in descending order.\n    \n    Args:\n        lst: List of elements\n        \n    Returns:\n        List with elements at indices 0, 3, 6, 9, ... sorted in descending order\n    \"\"\"\n    if not lst:\n        return lst\n    \n    # Extract elements at indices divisible by 3\n    divisible_by_three = [lst[i] for i in range(0, len(lst), 3)]\n    \n    # Sort them in descending order\n    divisible_by_three.sort(reverse=True)\n    \n    # Create result list\n    result = lst.copy()\n    divisible_index = 0\n    \n    # Place sorted elements back at indices divisible by 3\n    for i in range(0, len(result), 3):\n        result[i] = divisible_by_three[divisible_index]\n        divisible_index += 1\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[5, 6, 3, 4, 8, 9, 2]", "[5, 8, 3, 4, 6, 9, 2]", "[5, 6, 9, 4, 8, 3, 2]", "[5, 6, 3, 4, 8, 9, 2, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/34_prompt2ac", "code_candidates": [{"code": "from typing import List, Union\n\ndef unique_sorted(input_list: Union[List, None]) -> List:\n    if input_list is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not input_list:\n        return []\n    \n    return sorted(list(set(input_list)))", "index": 0, "passed_case": [0], "case_status": ["[0, 2, 3, 5, 9, 123]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/35_prompt2ac", "code_candidates": [{"code": "def max_element(l: list):\n    return max(l)", "index": 0, "passed_case": [0, 1], "case_status": ["3", "124"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/36_prompt2ac", "code_candidates": [{"code": "def count_sevens_in_divisible_numbers(n):\n    if n <= 0:\n        return 0\n    \n    count = 0\n    limit = n * n\n    \n    for i in range(1, limit):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    \n    return count", "index": 0, "passed_case": [], "case_status": ["113", "289", "295", "639", "2560", "1704904", "Timeout", "Timeout"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/37_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef sort_even_indices_descending(arr: List[int]) -> List[int]:\n    if not arr:\n        return arr\n    \n    # Extract values at even indices\n    even_values = [arr[i] for i in range(0, len(arr), 2)]\n    \n    # Sort even values in descending order\n    even_values.sort(reverse=True)\n    \n    # Create result array\n    result = arr.copy()\n    even_index = 0\n    \n    # Place sorted even values back at even indices\n    for i in range(0, len(result), 2):\n        result[i] = even_values[even_index]\n        even_index += 1\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[3, 2, 1]", "[123, 3, 9, 2, 5, 3, -3, 0, -5, 1, -10]", "[23, 8, 12, 4, 5, 2, 3, 11, -12, -10]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/38_prompt2ac", "code_candidates": [{"code": "def decode_cyclic(s: str) -> str:\n    \"\"\"\n    Decodes a string that was encoded using the encode_cyclic function.\n    \n    Args:\n        s: The encoded string\n        \n    Returns:\n        The original string before encoding\n    \"\"\"\n    if not s:\n        return s\n    \n    # Split into groups of 3 characters\n    groups = []\n    for i in range(0, len(s), 3):\n        groups.append(s[i:i+3])\n    \n    # Reverse the cyclic shift for each group\n    decoded_groups = []\n    for group in groups:\n        if len(group) == 3:\n            # Reverse the cyclic shift: move last character to front\n            decoded_group = group[2] + group[0] + group[1]\n        elif len(group) == 2:\n            # For groups of 2, we assume no shift was applied\n            decoded_group = group\n        else:  # len(group) == 1\n            # For groups of 1, no shift was applied\n            decoded_group = group\n            \n        decoded_groups.append(decoded_group)\n    \n    return ''.join(decoded_groups)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/39_prompt2ac", "code_candidates": [{"code": "def nth_composite_fibonacci(n):\n    if n <= 0:\n        return None\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        if num == 2:\n            return True\n        if num % 2 == 0:\n            return False\n        for i in range(3, int(num**0.5) + 1, 2):\n            if num % i == 0:\n                return False\n        return True\n    \n    def is_composite(num):\n        return num > 1 and not is_prime(num)\n    \n    a, b = 0, 1\n    count = 0\n    \n    while True:\n        a, b = b, a + b\n        if is_composite(a):\n            count += 1\n            if count == n:\n                return a", "index": 0, "passed_case": [], "case_status": ["8", "21", "34", "55", "144", "377", "610", "987", "2584", "4181"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/40_prompt2ac", "code_candidates": [{"code": "def three_sum_zero(nums):\n    \"\"\"\n    Returns True if there exist three distinct elements in the list that sum to zero.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        bool: True if three distinct elements sum to zero, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if not nums or len(nums) < 3:\n        return False\n    \n    # Check all possible combinations of three distinct elements\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] + nums[j] + nums[k] == 0:\n                    return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/41_prompt2ac", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    # Check for divisors from 5 to sqrt(n)\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    \n    return True", "index": 0, "passed_case": [], "case_status": ["True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/42_prompt2ac", "code_candidates": [{"code": "def incr_list(l: list, increment: int = 2):\n    return [x + increment for x in l]", "index": 0, "passed_case": [0], "case_status": ["[]", "[5, 4, 3]", "[7, 4, 7, 4, 5, 5, 11, 2, 125]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/43_prompt2ac", "code_candidates": [{"code": "def has_two_sum_zero(nums):\n    \"\"\"\n    Returns True if there exist two distinct elements in the list that sum to zero, False otherwise.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        bool: True if two distinct elements sum to zero, False otherwise\n    \"\"\"\n    if len(nums) < 2:\n        return False\n    \n    # Check all possible pairs of distinct elements\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == 0:\n                return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["False", "False", "False", "True", "False", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/44_prompt2ac", "code_candidates": [{"code": "def convert_to_base(x: int, y: int) -> str:\n    # Validate inputs\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise ValueError(\"Both x and y must be integers\")\n    \n    if y < 2 or y > 9:\n        raise ValueError(\"Base y must be between 2 and 9 inclusive\")\n    \n    # Handle zero case\n    if x == 0:\n        return '0'\n    \n    # Handle negative numbers\n    is_negative = x < 0\n    x = abs(x)\n    \n    # Convert to base y\n    result = []\n    while x > 0:\n        result.append(str(x % y))\n        x //= y\n    \n    # Build the string representation\n    base_representation = ''.join(reversed(result))\n    \n    # Add negative sign if needed\n    if is_negative:\n        base_representation = '-' + base_representation\n    \n    return base_representation", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["22", "100", "11101010", "10000", "1000", "111", "2", "3", "4", "5", "6", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/45_prompt2ac", "code_candidates": [{"code": "def triangle_area(base, height):\n    return 0.5 * base * height", "index": 0, "passed_case": [0, 1, 2], "case_status": ["7.5", "2.0", "40.0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/46_prompt2ac", "code_candidates": [{"code": "def fib4(n: int) -> int:\n    if n == 0 or n == 1 or n == 3:\n        return 0\n    if n == 2:\n        return 2\n    \n    # Initialize the base cases\n    a, b, c, d = 0, 0, 2, 0  # fib4(0), fib4(1), fib4(2), fib4(3)\n    \n    # Iteratively compute fib4(n)\n    for _ in range(4, n + 1):\n        next_val = a + b + c + d\n        a, b, c, d = b, c, d, next_val\n    \n    return d", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["4", "28", "104", "386"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/47_prompt2ac", "code_candidates": [{"code": "from typing import List, Union\n\ndef max_or_median(numbers: List[Union[int, float]]) -> Union[int, float]:\n    if not numbers:\n        raise ValueError(\"List cannot be empty\")\n    \n    if len(numbers) % 2 == 1:\n        return max(numbers)\n    else:\n        sorted_numbers = sorted(numbers)\n        n = len(sorted_numbers)\n        mid1 = sorted_numbers[n // 2 - 1]\n        mid2 = sorted_numbers[n // 2]\n        return (mid1 + mid2) / 2", "index": 0, "passed_case": [1, 2, 3], "case_status": ["5", "8.0", "5", "5.5", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/48_prompt2ac", "code_candidates": [{"code": "def is_palindrome(s: str) -> bool:\n    return s == s[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/49_prompt2ac", "code_candidates": [{"code": "def power_mod(x: int, y: int) -> int:\n    if y == 0:\n        raise ValueError(\"Modulus cannot be zero\")\n    if y == 1:\n        return 0\n    if x == 0:\n        return 1 % y\n    \n    # Using Python's built-in pow with three arguments for efficient modular exponentiation\n    result = pow(2, x, y)\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/50_prompt2ac", "code_candidates": [{"code": "def candidate(s: str) -> str:\n    \"\"\"\n    Encodes a string using a shift of 3.\n    \n    Args:\n        s: The input string to encode\n        \n    Returns:\n        The encoded string with each letter shifted by 3 positions\n    \"\"\"\n    result = []\n    \n    for char in s:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            base = ord('A') if char.isupper() else ord('a')\n            # Shift by 3 and wrap around using modulo\n            shifted = (ord(char) - base + 3) % 26 + base\n            result.append(chr(shifted))\n        else:\n            # Non-alphabetic characters remain unchanged\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [], "case_status": ["lifqppmfldfzkavjikop", "bizoecezvpwaqhighn", "sqmogslkulttbqhj", "zlukzrcbtaoekjdpg", "kpluqwctnttodq", "ckbcnzfpnwuqcezpdsgg", "pjhsuqkoae", "ocxucwmqmpfzzqf", "vautpmyxkgjlmcnhdvb", "uubwyqzidfl", "zgqgcslrvnwiffqygnyl", "rcybomtgnzgyibsxilth", "pjpakkfxkgzgmm", "xznqybvozgfeoerudctw", "wlppksiazpapikecjp", "jskypqdxozm", "axphxhvolldvtvvwfjd", "cljufshlpoozwmvnqwpk", "hzljczikgpnvxxouj", "uiuqhhwrvefh", "dexmorojafzjfsjjax", "ynjyknkbkdpulapabj", "kvdaaysqodespqumdcr", "sgkiwbalkzoyqmtkp", "rnwzerbhcyidzrd", "mqllfzmqrbo", "odcqyxqjkcvqjis", "cqnfwzevzilk", "zjtazmvmjrth", "todpdltgzv", "fmpnhhnvinfshvhdfhp", "nhelujxpowtrhp", "idousqkgqtcyu", "zsilqnaqjlbvtfhsvbyl", "aoqjeviyhzdfffdo", "vkdsbsdlfryrdvs", "erzmovdudfnbaruz", "rrovhabcsw", "wdoyxhhfndkrydcbs", "gpdrphomijp", "bgkwvcaoeeuxupmce", "gglgvpnhey", "jzplwmhwdyzbsgwbf", "vzwnfxwqgpcqggyxcp", "wkerpqsszkmmpu", "eokvvszwvjov", "gaeigauxitrguvzf", "hbpxpqvxiusddhufnw", "bziuaadikcvm", "njqusowssguqgvqkx", "fzjtpckgcj", "poibmpmxdl", "oweqgtnbbfelgnrlair", "duueokaecplegrdbhlh", "hjtzvdtkycsivxlvtcw", "vnfycqbhzgxw", "faqspkqwpgwabdus", "xsnxothqsq", "eqziyokpfvxzgpexcex", "hikrpueprdatxzytv", "stewqrqplfoslfzgen", "ofxqfagybrlor", "tnriezmqjjzre", "cgxliarxxwsn", "qxlkuxkacd", "mmharkplzg", "bbhbpgyuwwravrab", "bflgocoqdk", "pnzknivwebxr", "prerewkdpq", "adhovlzpcmqmkjnhrbfa", "wlwereuqyzxwkb", "vfsbqikpda", "igdqajggnxycwqnavcx", "xtvssdlnsve", "rdugzjwksqslguyid", "wvjoytbgxcwgjoqzmr", "exlicbhpenrzizvkp", "wlcmxeryeqv", "xpwzmuobyfmkqghvs", "qirfraadxmwzxtszgz", "wsoepaupgvjsfxeh", "udhcmxjmyaslwlyw", "fmvcmkxhqs", "eucksdzuscegxzjbkpc", "rpfkvlgcelwnerijshjr", "tvmpyvadhnnnkbu", "dpxampwcqwqdihwrdzn", "wtarcveqwro", "xlpuatareriduqia", "gfjbfxrghpbhtpcobqdg", "dmclccjrhwjatfmkrsfv", "omhztyyqnqxh", "fshlwkmgpdfduh", "tkhuiqzlwtdfdqauct", "dpxibzsbpck", "wercvlmjjrxllpzmuwtd", "vaffmvclxbvqjetoww", "tldtzctjuqolw", "doccbijhspm"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/51_prompt2ac", "code_candidates": [{"code": "def remove_vowels(s: str) -> str:\n    vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in s:\n        if char not in vowels:\n            result += char\n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["", "bcdf\nghjklm", "fdcb", "", "cB", "cB", "ybcd"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/52_prompt2ac", "code_candidates": [{"code": "def all_below_threshold(numbers: list, threshold: int) -> bool:\n    \"\"\"\n    Check if all numbers in list are below the given threshold.\n    \n    Args:\n        numbers: List of numbers to check\n        threshold: The threshold value to compare against\n        \n    Returns:\n        True if all numbers are below threshold, False otherwise\n    \"\"\"\n    # If list is empty, return True\n    if not numbers:\n        return True\n    \n    # Check each number in the list\n    for number in numbers:\n        if number >= threshold:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/53_prompt2ac", "code_candidates": [{"code": "def add_multiply_subtract(x: int, y: int) -> int:\n    return (x + y) * (x - y)", "index": 0, "passed_case": [1], "case_status": ["-1", "1", "-5", "-24", "24", "414720", "-575456", "16461", "31820", "557700", "-95700", "522205", "-356895", "185600", "-8125", "-6915", "-112167", "-328747", "-496080", "-73299", "127323", "-160056", "282953", "-106516", "-603693", "654056", "323172", "40448", "-23119", "350439", "107520", "-142485", "-124888", "627785", "309024", "680340", "337109", "285272", "100880", "143369", "229225", "307352", "-420147", "641024", "310865", "514800", "-456213", "-571392", "81055", "708981", "776160", "70665", "-207204", "590187", "-116085", "85973", "396067", "-404157", "49032", "-382800", "391875", "-258400", "34611", "73185", "-820633", "-66591", "274724", "381177", "126973", "627187", "-652525", "-677952", "-63771", "70587", "-827569", "594825", "264384", "56595", "189120", "-655000", "443132", "198645", "53277", "-517140", "25875", "-511335", "165760", "488152", "29564", "30295", "16416", "-588880", "-773857", "-11792", "385595", "173305", "-185476", "-151011", "-220000", "-63240", "-921987", "-455805", "931104", "-60228", "-473515"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/54_prompt2ac", "code_candidates": [{"code": "def same_chars(str1: str, str2: str) -> bool:\n    \"\"\"\n    Check if two strings contain the same set of unique characters.\n    \n    Args:\n        str1: First string to compare\n        str2: Second string to compare\n        \n    Returns:\n        True if both strings have identical sets of unique characters, False otherwise\n    \"\"\"\n    return set(str1) == set(str2)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/55_prompt2ac", "code_candidates": [{"code": "def fib(n):\n    if n <= 0:\n        return None\n    if n == 1 or n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/56_prompt2ac", "code_candidates": [{"code": "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\". return True if every opening bracket has a corresponding closing bracket in proper order. \"\"\"\n    count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/57_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef is_monotonic(nums: List[int]) -> bool:\n    if len(nums) <= 1:\n        return True\n    \n    is_non_decreasing = True\n    is_non_increasing = True\n    \n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            is_non_decreasing = False\n        if nums[i] > nums[i-1]:\n            is_non_increasing = False\n        \n        # Early termination if neither condition holds\n        if not is_non_decreasing and not is_non_increasing:\n            return False\n    \n    return is_non_decreasing or is_non_increasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/58_prompt2ac", "code_candidates": [{"code": "def find_common_elements(list1: list, list2: list) -> list:\n    \"\"\"\n    Return sorted unique common elements for two lists in ascending order.\n    \n    Args:\n        list1: First list of elements\n        list2: Second list of elements\n        \n    Returns:\n        List of unique common elements sorted in ascending order\n    \"\"\"\n    # Convert lists to sets to find intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find common elements\n    common = set1.intersection(set2)\n    \n    # Return sorted list\n    return sorted(list(common))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/59_prompt2ac", "code_candidates": [{"code": "def largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n.\"\"\"\n    if n <= 1:\n        return None\n    \n    largest = -1\n    \n    # Check for factor 2\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n    \n    # Check for odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n        factor += 2\n    \n    # If n is still greater than 1, then it's a prime factor\n    if n > 1:\n        largest = n\n    \n    return largest", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/60_prompt2ac", "code_candidates": [{"code": "def sum_to_n(n: int):\n    \"\"\"Returns the sum of all integers from 1 to n (inclusive). For n=1, returns 1. For n=30, returns 465. For n=100, returns 5050. For n=5, returns 15. For n=10, returns 55.\"\"\"\n    return n * (n + 1) // 2", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "21", "66", "465", "5050"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/61_prompt2ac", "code_candidates": [{"code": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    Returns True if brackets are properly balanced, False otherwise.\n    \n    Args:\n        s: A string containing brackets to check\n        \n    Returns:\n        bool: True if balanced, False otherwise\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/62_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef derivative(coefficients: List[float]) -> List[float]:\n    \"\"\"\n    Compute the first derivative of a polynomial represented as a list of coefficients.\n    \n    Args:\n        coefficients: List of coefficients in ascending order of powers [a0, a1, a2, ..., an]\n        \n    Returns:\n        List of coefficients representing the first derivative polynomial [a1, 2*a2, 3*a3, ..., n*an]\n    \"\"\"\n    if len(coefficients) <= 1:\n        return []\n    \n    return [i * coefficients[i] for i in range(1, len(coefficients))]", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[1, 4, 12, 20]", "[2, 6]", "[2, 2]", "[2, 2, 0, 16]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/63_prompt2ac", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1 or n == 2:\n        return 1\n    \n    # Initialize the first three values\n    a, b, c = 0, 1, 1\n    \n    # Compute iteratively from 3 to n\n    for _ in range(3, n + 1):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "index": 0, "passed_case": [0], "case_status": ["1", "1", "7", "44", "149", "504", "1705"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/64_prompt2ac", "code_candidates": [{"code": "def vowels_count(s):\n    \"\"\"Write a function candidate which takes a string representing\n    a word as input and returns the number of characters or vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> vowels_count(\"abcde\")\n    5\n    >>> vowels_count(\"ACEDY\")\n    5\n    \"\"\"\n    if not s:\n        return 0\n    \n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    for i, char in enumerate(s):\n        if char in vowels:\n            count += 1\n        elif char.lower() == 'y' and i == len(s) - 1:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["2", "3", "2", "1", "2", "1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/65_prompt2ac", "code_candidates": [{"code": "def shift(x: int, shift: int) -> str:\n    # Handle zero shift\n    if shift == 0:\n        return str(x)\n    \n    # Convert to string and handle negative sign\n    is_negative = x < 0\n    digits = str(abs(x))\n    num_digits = len(digits)\n    \n    # Handle single digit case\n    if num_digits == 1:\n        shift = num_digits\n    \n    # Apply modulo to get effective shift\n    effective_shift = shift % num_digits\n    \n    # If effective shift is 0 after modulo, return original\n    if effective_shift == 0:\n        return str(x)\n    \n    # Special case: when shift equals number of digits, return reversed\n    if shift == num_digits:\n        result = digits[::-1]\n    else:\n        # Perform circular left shift\n        result = digits[effective_shift:] + digits[:effective_shift]\n    \n    # Preserve negative sign\n    if is_negative:\n        result = '-' + result\n    \n    return result", "index": 0, "passed_case": [1, 3, 4], "case_status": ["010", "12", "97", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/66_prompt2ac", "code_candidates": [{"code": "def count_uppercase_letters(s: str) -> int:\n    \"\"\"\n    Count the number of uppercase letters in a string.\n    \n    Args:\n        s: Input string to analyze\n        \n    Returns:\n        Count of uppercase letters (A-Z) in the string\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count", "index": 0, "passed_case": [0], "case_status": ["0", "2", "1", "1", "2", "2", "2", "4"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/67_prompt2ac", "code_candidates": [{"code": "def count_mangoes(fruit_string: str, total_fruits: int) -> int:\n    \"\"\"\n    Parse a string containing apple and orange counts, then return the number of mangoes\n    in the basket by subtracting apples and oranges from the total number of fruits.\n    \n    Args:\n        fruit_string: A string in the format \"X apples and Y oranges\"\n        total_fruits: Total number of fruits in the basket\n        \n    Returns:\n        Number of mangoes in the basket\n    \"\"\"\n    # Extract numbers from the string\n    import re\n    numbers = re.findall(r'\\d+', fruit_string)\n    \n    # Parse apples and oranges\n    apples = int(numbers[0])\n    oranges = int(numbers[1])\n    \n    # Calculate mangoes\n    mangoes = total_fruits - apples - oranges\n    \n    return mangoes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["8", "10", "2", "2", "95", "0", "19"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/68_prompt2ac", "code_candidates": [{"code": "def find_max_and_index(arr):\n    if not arr:\n        return []\n    \n    max_value = max(arr)\n    max_index = arr.index(max_value)\n    \n    return [max_value, max_index]", "index": 0, "passed_case": [2], "case_status": ["[4, 0]", "[3, 2]", "[]", "[5, 0]", "[5, 4]", "[8, 2]", "[7, 0]", "[9, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/69_prompt2ac", "code_candidates": [{"code": "from typing import List\nfrom collections import Counter\n\ndef find_smallest_equal_frequency(nums: List[int]) -> int:\n    # Count frequency of each number\n    freq = Counter(nums)\n    \n    # Find all numbers where frequency equals the number itself\n    valid_numbers = []\n    for num, count in freq.items():\n        if num == count:\n            valid_numbers.append(num)\n    \n    # Return smallest such number, or -1 if none exist\n    return min(valid_numbers) if valid_numbers else -1", "index": 0, "passed_case": [0, 1, 2, 3, 6, 7, 8, 12, 13, 16, 19, 20, 24], "case_status": ["1", "4", "-1", "8", "-1", "-1", "2", "1", "-1", "-1", "-1", "3", "1", "4", "1", "-1", "4", "1", "1", "-1", "-1", "-1", "-1", "-1", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/70_prompt2ac", "code_candidates": [{"code": "def strange_sorting(arr):\n    if not arr:\n        return []\n    \n    result = []\n    sorted_arr = sorted(arr)\n    left, right = 0, len(sorted_arr) - 1\n    pick_min = True\n    \n    while left <= right:\n        if pick_min:\n            result.append(sorted_arr[left])\n            left += 1\n        else:\n            result.append(sorted_arr[right])\n            right -= 1\n        pick_min = not pick_min\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[1, 9, 5, 8, 6, 7]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[-5, 5, -5, 5, 0, 2, 2, 2]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/71_prompt2ac", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef triangle_area(sides: List[float]) -> float:\n    \"\"\"\n    Calculate the area of a triangle given its three sides using Heron's formula.\n    \n    Args:\n        sides: A list of three floats representing the sides of the triangle\n        \n    Returns:\n        The area of the triangle as a float\n        \n    Raises:\n        ValueError: If the sides don't form a valid triangle\n    \"\"\"\n    if len(sides) != 3:\n        raise ValueError(\"Triangle must have exactly 3 sides\")\n    \n    a, b, c = sides\n    \n    # Check for valid triangle using triangle inequality\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        raise ValueError(\"Invalid triangle: sum of any two sides must be greater than the third side\")\n    \n    # Check for non-positive sides\n    if a <= 0 or b <= 0 or c <= 0:\n        raise ValueError(\"All sides must be positive\")\n    \n    # Calculate area using Heron's formula\n    s = (a + b + c) / 2  # semi-perimeter\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return area", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/72_prompt2ac", "code_candidates": [{"code": "def is_palindromic_under_weight(q, w):\n    \"\"\"\n    Returns True if list q is palindromic and sum of elements is <= weight w.\n    Returns False otherwise.\n    \"\"\"\n    if not q:\n        return True\n    \n    # Check if palindromic\n    if q != q[::-1]:\n        return False\n    \n    # Check if sum is within weight limit\n    if sum(q) > w:\n        return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/73_prompt2ac", "code_candidates": [{"code": "def min_changes_to_palindrome(arr):\n    \"\"\"\n    Find the minimum number of elements that need to be changed to make the array palindromic.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        int: Minimum number of changes required to make the array palindromic\n    \"\"\"\n    if not arr:\n        return 0\n    \n    changes = 0\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] != arr[right]:\n            changes += 1\n        left += 1\n        right -= 1\n    \n    return changes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["4", "1", "1", "1", "0", "0", "0", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/74_prompt2ac", "code_candidates": [{"code": "def compare_char_counts(list1: list[str], list2: list[str]) -> list[str]:\n    \"\"\"\n    Compare total character counts between two lists of strings and return the list with higher total character count.\n    If counts are equal, return the first list.\n    Handle empty lists appropriately.\n    \n    Args:\n        list1: First list of strings\n        list2: Second list of strings\n        \n    Returns:\n        The list with higher total character count, or list1 if equal\n    \"\"\"\n    # Calculate total character counts for both lists\n    count1 = sum(len(s) for s in list1)\n    count2 = sum(len(s) for s in list2)\n    \n    # Return the list with higher count, or list1 if equal\n    if count1 >= count2:\n        return list1\n    else:\n        return list2", "index": 0, "passed_case": [0, 6], "case_status": ["[]", "['hi', 'admin']", "['hi', 'hi', 'admin', 'project']", "['1', '2', '3', '4', '5']", "['hi', 'admin']", "['hi', 'admin']", "['hi', 'admin']", "['this']", "['this']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/75_prompt2ac", "code_candidates": [{"code": "def is_multiply_prime(n, K):\n    if n <= 1 or K <= 0:\n        return False\n    \n    count = 0\n    d = 2\n    while d * d <= n:\n        while n % d == 0:\n            count += 1\n            n //= d\n        d += 1\n    \n    if n > 1:\n        count += 1\n    \n    return count == K", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/76_prompt2ac", "code_candidates": [{"code": "def is_power(a, b):\n    # Handle special case where both a and b are 0\n    if a == 0 and b == 0:\n        return True\n    \n    # Handle case where b is 0 but a is not 0\n    if b == 0:\n        return False\n    \n    # Handle case where a is 0 but b is not 0\n    if a == 0:\n        return False\n    \n    # Handle case where b is 1\n    if b == 1:\n        return a == 1\n    \n    # Handle case where b is -1\n    if b == -1:\n        return a == 1 or a == -1\n    \n    # Handle negative numbers\n    if a < 0 and b > 0:\n        return False\n    \n    if a > 0 and b < 0:\n        # Check if a is a power of |b| with even exponent\n        if a == 1:\n            return True\n        # For negative b and positive a, we need even powers\n        # This is complex to compute, so we'll use logarithms\n        import math\n        if b == -1:\n            return a == 1 or a == -1\n        # For other negative bases, check if we can find integer k\n        # such that b^k = a\n        if a > 0:\n            # If a > 0 and b < 0, k must be even\n            try:\n                k = math.log(a) / math.log(abs(b))\n                k_rounded = round(k)\n                # Check if k_rounded is even and b^k_rounded == a\n                if k_rounded % 2 == 0 and abs(b) ** k_rounded == a:\n                    return True\n                return False\n            except (ValueError, ZeroDivisionError):\n                return False\n        else:\n            # If a < 0 and b < 0, k must be odd\n            try:\n                k = math.log(-a) / math.log(-b)\n                k_rounded = round(k)\n                # Check if k_rounded is odd and b^k_rounded == a\n                if k_rounded % 2 == 1 and b ** k_rounded == a:\n                    return True\n                return False\n            except (ValueError, ZeroDivisionError):\n                return False\n    \n    # Handle case where both are positive\n    if a > 0 and b > 0:\n        if a == 1:\n            return True\n        try:\n            import math\n            k = math.log(a) / math.log(b)\n            k_rounded = round(k)\n            # Check if b^k_rounded equals a\n            if b ** k_rounded == a:\n                return True\n            return False\n        except (ValueError, ZeroDivisionError):\n            return False\n    \n    # Handle case where a < 0 and b > 0 (should be False)\n    if a < 0 and b > 0:\n        return False\n    \n    # Handle case where both are negative\n    if a < 0 and b < 0:\n        # We need to find k such that b^k = a\n        # Since both are negative, k must be odd\n        try:\n            import math\n            # Use logarithms to estimate k\n            k = math.log(-a) / math.log(-b)\n            k_rounded = round(k)\n            # Check if k_rounded is odd and b^k_rounded == a\n            if k_rounded % 2 == 1 and b ** k_rounded == a:\n                return True\n            return False\n        except (ValueError, ZeroDivisionError):\n            return False\n    \n    # Default case\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/77_prompt2ac", "code_candidates": [{"code": "def is_perfect_cube(n: int) -> bool:\n    if n == 0:\n        return True\n    \n    # Handle negative numbers\n    is_negative = n < 0\n    if is_negative:\n        n = -n\n    \n    # Find the cube root and check if it's an integer\n    cube_root = round(n ** (1/3))\n    \n    # Verify by cubing the rounded root\n    if cube_root ** 3 == n:\n        return True\n    \n    # Try nearby values to handle floating point precision issues\n    for candidate in [cube_root - 1, cube_root, cube_root + 1]:\n        if candidate ** 3 == n:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/78_prompt2ac", "code_candidates": [{"code": "def hex_key(hex_string: str) -> int:\n    \"\"\"\n    Count the number of hexadecimal digits in a string that are prime numbers.\n    \n    Valid hexadecimal digits are 0-9, A-F.\n    Prime digits to count are 2, 3, 5, 7, B(11), D(13).\n    The function is case-insensitive.\n    \n    Args:\n        hex_string: A string containing valid hexadecimal characters (0-9, A-F, a-f)\n        \n    Returns:\n        The count of hexadecimal digits that are prime numbers\n    \"\"\"\n    # Convert to uppercase for case-insensitive comparison\n    hex_string = hex_string.upper()\n    \n    # Set of prime hexadecimal digits\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Count prime digits\n    count = 0\n    for char in hex_string:\n        if char in prime_digits:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["1", "2", "4", "2", "6", "12", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/79_prompt2ac", "code_candidates": [{"code": "def decimal_to_binary(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1' or '2'.\n\n    There will be an extra couple of characters 'db' at different positions (start, or middle, or end) of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_binary(15)   # returns \"db15db\"\n    decimal_to_binary(32)   # returns \"db32db\"\n    \"\"\"\n    return f\"db{decimal}db\"", "index": 0, "passed_case": [0], "case_status": ["db0db", "db32db", "db103db", "db15db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/80_prompt2ac", "code_candidates": [{"code": "def is_happy(s):\n    \"\"\"\n    Determine if a string is 'happy'.\n    \n    A string is happy if it has at least 3 characters and every substring \n    of exactly 3 consecutive characters contains only distinct letters.\n    \n    Args:\n        s (str): The input string to check\n        \n    Returns:\n        bool: True if the string is happy, False otherwise\n    \"\"\"\n    # Check if string has at least 3 characters\n    if len(s) < 3:\n        return False\n    \n    # Check every substring of exactly 3 consecutive characters\n    for i in range(len(s) - 2):\n        substring = s[i:i+3]\n        # Check if all characters in the substring are distinct\n        if len(set(substring)) != 3:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "False", "True", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/81_prompt2ac", "code_candidates": [{"code": "def gpa_to_letter_grades(gpa_list):\n    \"\"\"\n    Convert a list of numerical GPAs to letter grades.\n    \n    Args:\n        gpa_list: List of numerical GPAs\n        \n    Returns:\n        List of letter grades corresponding to the input GPAs\n        \n    Raises:\n        TypeError: If input is None or contains non-numerical values\n        ValueError: If any GPA is negative\n    \"\"\"\n    if gpa_list is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not isinstance(gpa_list, list):\n        raise TypeError(\"Input must be a list\")\n    \n    letter_grades = []\n    \n    for gpa in gpa_list:\n        if gpa is None:\n            raise TypeError(\"GPAs cannot be None\")\n        \n        if not isinstance(gpa, (int, float)):\n            raise TypeError(f\"GPAs must be numerical values, got {type(gpa)}\")\n        \n        if gpa < 0:\n            raise ValueError(\"GPAs cannot be negative\")\n        \n        if gpa > 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:  # gpa == 0.0\n            letter_grades.append('E')\n    \n    return letter_grades", "index": 0, "passed_case": [1, 2, 3, 4, 5], "case_status": ["['A', 'B', 'C-', 'C', 'A-']", "['D+']", "['D-']", "['E']", "['D', 'D-', 'C-', 'B', 'B+']", "['E', 'D-']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/82_prompt2ac", "code_candidates": [{"code": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef check_string_length(s: str) -> bool:\n    length = len(s)\n    return not is_prime(length)", "index": 0, "passed_case": [], "case_status": ["False", "False", "False", "True", "False", "False", "False", "False", "True", "False", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/84_prompt2ac", "code_candidates": [{"code": "def sum_of_digits_in_hex(N: int) -> str:\n    # Calculate sum of digits in base 10\n    digit_sum = sum(int(digit) for digit in str(abs(N)))\n    \n    # Convert sum to hexadecimal and return as string\n    return hex(digit_sum)[2:].upper()", "index": 0, "passed_case": [0], "case_status": ["1", "6", "C", "9", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/85_prompt2ac", "code_candidates": [{"code": "def add(numbers):\n    \"\"\"\n    Add the even elements that are at even indices (0, 2, 4, ...).\n    \n    Args:\n        numbers: A non-empty list of integers\n        \n    Returns:\n        int: Sum of even elements at even indices\n    \"\"\"\n    total = 0\n    for i in range(0, len(numbers), 2):  # iterate through even indices\n        if numbers[i] % 2 == 0:  # check if element is even\n            total += numbers[i]\n    return total", "index": 0, "passed_case": [], "case_status": ["4", "12", "10", "10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/86_prompt2ac", "code_candidates": [{"code": "def sort_string_characters(s: str) -> str:\n    if not s:\n        return s\n    \n    result = []\n    current_word = []\n    \n    for char in s:\n        if char.isspace():\n            if current_word:\n                # Sort the characters in the current word\n                current_word.sort()\n                result.extend(current_word)\n                current_word = []\n            result.append(char)\n        else:\n            current_word.append(char)\n    \n    # Handle the last word if string doesn't end with whitespace\n    if current_word:\n        current_word.sort()\n        result.extend(current_word)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["Hi", "ehllo", "bemnru", "abcd", "Hello !!!Wdlor", "", ".Hi My aemn is Meirst .Rboot How aer ?ouy"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/87_prompt2ac", "code_candidates": [{"code": "def find_integer_coordinates(nested_list, x):\n    \"\"\"\n    Search for all occurrences of integer x in a nested list structure.\n    \n    Args:\n        nested_list: A list of lists containing integers\n        x: The integer to search for\n        \n    Returns:\n        A list of (row, column) tuples indicating positions of x,\n        sorted by row first then by column\n    \"\"\"\n    if not nested_list:\n        return []\n    \n    coordinates = []\n    \n    for row_idx, row in enumerate(nested_list):\n        if not row:  # Handle empty sublists\n            continue\n        for col_idx, element in enumerate(row):\n            if element == x:\n                coordinates.append((row_idx, col_idx))\n    \n    # Sort by row first, then by column\n    coordinates.sort(key=lambda coord: (coord[0], coord[1]))\n    \n    return coordinates", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[]", "[]", "[(2, 2)]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/88_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    if not arr:\n        return []\n    \n    sum_first_last = arr[0] + arr[-1]\n    \n    if sum_first_last % 2 == 0:\n        return sorted(arr)\n    else:\n        return sorted(arr, reverse=True)", "index": 0, "passed_case": [0, 1], "case_status": ["[]", "[5]", "[5, 4, 3, 2, 1, 0]", "[0, 1, 2, 3, 4, 5, 6]", "[2, 1]", "[87, 42, 32, 15, 11, 0]", "[11, 14, 21, 23]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/89_prompt2ac", "code_candidates": [{"code": "def encrypt(text: str) -> str:\n    result = \"\"\n    for char in text:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            base = ord('A') if char.isupper() else ord('a')\n            # Apply Caesar cipher with shift of 3\n            shifted = (ord(char) - base + 3) % 26 + base\n            result += chr(shifted)\n        else:\n            # Leave non-alphabetic characters unchanged\n            result += char\n    return result", "index": 0, "passed_case": [], "case_status": ["kl", "dvgijkmno", "ji", "hw"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/90_prompt2ac", "code_candidates": [{"code": "def first_smallest_unique(nums):\n    \"\"\"\n    Returns the 1st smallest unique element from a list of integers,\n    or None if the list is empty or has insufficient unique elements.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        The smallest distinct value in the list, or None if no elements exist\n    \"\"\"\n    if not nums:\n        return None\n    \n    # Get unique elements and sort them\n    unique_nums = sorted(set(nums))\n    \n    # Return the smallest unique element if it exists\n    return unique_nums[0] if unique_nums else None", "index": 0, "passed_case": [2], "case_status": ["1", "1", "None", "1", "0", "1", "-45"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/91_prompt2ac", "code_candidates": [{"code": "def is_bored(S):\n    if not S:\n        return 0\n    \n    # Split by sentence delimiters\n    import re\n    sentences = re.split(r'[.?!]+', S)\n    \n    # Remove empty strings\n    sentences = [s.strip() for s in sentences if s.strip()]\n    \n    if not sentences:\n        return 0\n    \n    # Count sentences that start with \"I\" or \"W\"\n    count = 0\n    for sentence in sentences:\n        # Get the first word of the sentence\n        words = sentence.split()\n        if words:\n            first_word = words[0]\n            if first_word == \"I\" or first_word == \"W\":\n                count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["0", "0", "1", "0", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/92_prompt2ac", "code_candidates": [{"code": "def check_numbers(a, b, c):\n    \"\"\"\n    Takes 3 numbers and returns True if all numbers are integers AND \n    one of the numbers is greater than or equal to the sum of the other two.\n    \n    Args:\n        a, b, c: Three numbers to check\n        \n    Returns:\n        bool: True if all are integers and condition is met, False otherwise\n    \"\"\"\n    # Check if all numbers are integers\n    if not all(isinstance(x, int) for x in [a, b, c]):\n        return False\n    \n    # Check if one number is >= sum of other two\n    return (a >= b + c) or (b >= a + c) or (c >= a + b)", "index": 0, "passed_case": [0, 1, 2, 4, 5, 6, 7, 8, 9], "case_status": ["True", "False", "False", "True", "True", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/93_prompt2ac", "code_candidates": [{"code": "def encode(message):\n    vowels = 'aeiouAEIOU'\n    vowel_shift = {'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a',\n                   'A': 'E', 'E': 'I', 'I': 'O', 'O': 'U', 'U': 'A'}\n    \n    result = []\n    for char in message:\n        if char.isalpha():\n            # Swap case\n            swapped_char = char.lower() if char.isupper() else char.upper()\n            \n            # Replace vowels\n            if swapped_char in vowels:\n                encoded_char = vowel_shift[swapped_char]\n            else:\n                encoded_char = swapped_char\n                \n            result.append(encoded_char)\n        else:\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [], "case_status": ["tist", "mADESOR", "yis", "tHOS OS E MISSEGI", "o dUnT kNuW wHeT Tu wRoTi"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/94_prompt2ac", "code_candidates": [{"code": "from typing import List, Optional\n\ndef smallest_prime(numbers: List[int]) -> Optional[int]:\n    if not numbers:\n        return None\n    \n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    primes = [num for num in numbers if is_prime(num)]\n    \n    return min(primes) if primes else None", "index": 0, "passed_case": [4], "case_status": ["2", "2", "3", "5", "3", "2", "8191", "7", "97"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/95_prompt2ac", "code_candidates": [{"code": "def check_consistent_case(d: dict) -> bool:\n    if not d:\n        return False\n    \n    string_keys = [k for k in d.keys() if isinstance(k, str)]\n    \n    if not string_keys:\n        return False\n    \n    all_lowercase = all(k.islower() for k in string_keys)\n    all_uppercase = all(k.isupper() for k in string_keys)\n    \n    return all_lowercase or all_uppercase", "index": 0, "passed_case": [0, 1, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/96_prompt2ac", "code_candidates": [{"code": "def primes_less_than_n(n: int) -> list[int]:\n    if n <= 2:\n        return []\n    \n    # Sieve of Eratosthenes\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    # Collect primes less than n\n    primes = []\n    for i in range(2, n):\n        if is_prime[i]:\n            primes.append(i)\n    \n    return primes", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "case_status": ["[2, 3]", "[2, 3, 5]", "[2, 3, 5]", "[2, 3, 5, 7]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19]", "[]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/97_prompt2ac", "code_candidates": [{"code": "def multiply(a: int, b: int) -> int:\n    \"\"\"\n    Compute the product of unit digits of two integers.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        Product of the unit digits of both integers\n    \"\"\"\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["16", "72", "0", "20", "42", "49", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/98_prompt2ac", "code_candidates": [{"code": "def count_uppercase_vowels_at_indices(s: str) -> int:\n    uppercase_vowels = {'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    \n    for i in range(len(s)):\n        if s[i] in uppercase_vowels:\n            count += 1\n    \n    return count", "index": 0, "passed_case": [0, 2], "case_status": ["0", "1", "0", "4"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/99_prompt2ac", "code_candidates": [{"code": "def closest_integer(value: str) -> int:\n    \"\"\"\n    Convert string to number and round to nearest integer, with tie-breaking rule\n    of rounding away from zero (farthest from zero).\n    \n    Args:\n        value: String representation of a number\n        \n    Returns:\n        Integer result after rounding\n    \"\"\"\n    # Convert string to float\n    num = float(value)\n    \n    # Handle the rounding with tie-breaking away from zero\n    if num >= 0:\n        # For positive numbers, use standard rounding\n        return int(num + 0.5)\n    else:\n        # For negative numbers, round away from zero\n        return int(num - 0.5)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["10", "15", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/100_prompt2ac", "code_candidates": [{"code": "def pile_stones(n: int) -> list[int]:\n    \"\"\"\n    Create a pile with n levels where the first level has n stones.\n    For each subsequent level, if n is odd, use the next odd number in sequence,\n    if n is even, use the next even number in sequence.\n    \n    Args:\n        n: A positive integer representing the number of levels and stones in the first level\n        \n    Returns:\n        A list where element at index i represents the number of stones in level (i+1)\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    result = []\n    current = n\n    \n    for i in range(n):\n        result.append(current)\n        current += 2\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/101_prompt2ac", "code_candidates": [{"code": "def words_string(s):\n    \"\"\"\n    You will be given a string of words separated by letters or commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    words_string(\"Hi, my name is John\") == [\"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"six\"]\n    \"\"\"\n    if not s:\n        return []\n    \n    # Split by commas and spaces, then filter out empty strings\n    import re\n    parts = re.split(r'[,\\s]+', s.strip())\n    words = [part for part in parts if part]\n    \n    # Return the last word if there are any words, otherwise return empty list\n    return [words[-1]] if words else []", "index": 0, "passed_case": [4], "case_status": ["['John']", "['six']", "['name']", "['six']", "[]", "['gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/102_prompt2ac", "code_candidates": [{"code": "def largest_integer_in_range(x: int, y: int) -> int:\n    \"\"\"\n    Returns the largest integer in range [x, y] inclusive.\n    \n    Args:\n        x: The lower bound of the range (inclusive)\n        y: The upper bound of the range (inclusive)\n        \n    Returns:\n        The largest integer in the range [x, y], or -1 if no integer exists\n    \"\"\"\n    # For valid integer inputs, the largest integer in range [x, y] is always y\n    # when x <= y. If x > y, there are no integers in the range.\n    if x <= y:\n        return y\n    else:\n        return -1", "index": 0, "passed_case": [1, 2, 3, 5, 7], "case_status": ["15", "-1", "12354", "-1", "29", "-1", "7", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/103_prompt2ac", "code_candidates": [{"code": "def max_to_binary(n: int, m: int) -> str:\n    if n > m:\n        return -1\n    \n    max_val = max(range(n, m + 1))\n    return bin(max_val)", "index": 0, "passed_case": [9, 10, 11], "case_status": ["0b101", "0b1101", "0b1111010001", "0b1111100101", "0b1101010011", "0b1000100010", "0b111110000", "0b1110000110", "0b11101001", "-1", "-1", "0b101"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/104_prompt2ac", "code_candidates": [{"code": "def odd_or_even_digits(x):\n    \"\"\"\n    Return a sorted list of elements that contain only odd digits OR only even digits.\n    \n    Args:\n        x: List of positive integers\n        \n    Returns:\n        List of integers sorted in increasing order that contain only odd or only even digits\n    \"\"\"\n    def is_all_odd_or_even(num):\n        digits = [int(d) for d in str(num)]\n        all_odd = all(d % 2 == 1 for d in digits)\n        all_even = all(d % 2 == 0 for d in digits)\n        return all_odd or all_even\n    \n    result = [num for num in x if is_all_odd_or_even(num)]\n    return sorted(result)", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 15, 33]", "[]", "[111, 151]", "[31, 135]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/105_prompt2ac", "code_candidates": [{"code": "def solution(arr):\n    # Filter integers between 1 and 9 inclusive\n    filtered = [x for x in arr if 1 <= x <= 9]\n    \n    # Sort in ascending order\n    filtered.sort()\n    \n    # Reverse the array\n    filtered.reverse()\n    \n    # Replace each digit with its corresponding name\n    digit_names = {\n        1: 'One',\n        2: 'Two',\n        3: 'Three',\n        4: 'Four',\n        5: 'Five',\n        6: 'Six',\n        7: 'Seven',\n        8: 'Eight',\n        9: 'Nine'\n    }\n    \n    result = [digit_names[x] for x in filtered]\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["['Eight', 'Five', 'Four', 'Three', 'Two', 'Two', 'One', 'One']", "[]", "['One']", "['Three', 'Two', 'One']", "['Nine', 'Eight', 'Four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/106_prompt2ac", "code_candidates": [{"code": "def f(n):\n    def factorial(x):\n        if x <= 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n    \n    def sum_to_x(x):\n        return x * (x + 1) // 2\n    \n    result = []\n    for i in range(1, n + 1):\n        if i % 2 == 1:  # odd\n            result.append(factorial(i))\n        else:  # even\n            result.append(sum_to_x(i))\n    return result", "index": 0, "passed_case": [2], "case_status": ["[1, 3, 6, 10, 120]", "[1, 3, 6, 10, 120, 21, 5040]", "[1]", "[1, 3, 6]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/107_prompt2ac", "code_candidates": [{"code": "def count_palindromes(n: int) -> tuple[int, int]:\n    even_count = 0\n    odd_count = 0\n    \n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:  # Check if palindrome\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(8, 13)", "(4, 6)", "(1, 2)", "(6, 8)", "(5, 6)", "(4, 6)", "(4, 5)", "(0, 1)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/108_prompt2ac", "code_candidates": [{"code": "def count_positive_digit_sums(numbers):\n    def digit_sum(n):\n        if n == 0:\n            return 0\n        str_n = str(abs(n))\n        digits = [int(d) for d in str_n]\n        if n < 0:\n            digits[0] = -digits[0]\n        return sum(digits)\n    \n    count = 0\n    for num in numbers:\n        if digit_sum(num) > 0:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["0", "0", "6", "5", "4", "5", "1", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/109_prompt2ac", "code_candidates": [{"code": "def can_sort_with_right_shifts(arr):\n    if not arr or len(arr) <= 1:\n        return True\n    \n    n = len(arr)\n    \n    # Check if already sorted\n    if all(arr[i] <= arr[i+1] for i in range(n-1)):\n        return True\n    \n    # Try up to 2 right shifts\n    for shifts in range(1, 3):\n        # Perform right shift\n        shifted = arr[-shifts:] + arr[:-shifts]\n        \n        # Check if sorted\n        if all(shifted[i] <= shifted[i+1] for i in range(n-1)):\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["True", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/110_prompt2ac", "code_candidates": [{"code": "def can_make_all_even(lst1, lst2):\n    # Count even numbers in both lists\n    even_count = sum(1 for x in lst1 if x % 2 == 0) + sum(1 for x in lst2 if x % 2 == 0)\n    \n    # Check if we have enough even numbers to fill lst1\n    if even_count >= len(lst1):\n        return 'YES'\n    else:\n        return 'NO'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["YES", "NO", "YES", "YES", "NO", "NO", "YES"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/111_prompt2ac", "code_candidates": [{"code": "def letter_frequency(s: str) -> dict:\n    if not s:\n        return {}\n    \n    letters = s.split()\n    frequency = {}\n    \n    for letter in letters:\n        frequency[letter] = frequency.get(letter, 0) + 1\n    \n    max_freq = max(frequency.values())\n    return {letter: count for letter, count in frequency.items() if count == max_freq}", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["{'a': 2, 'b': 2}", "{'a': 2, 'b': 2}", "{'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}", "{'r': 1, 't': 1, 'g': 1}", "{'b': 4}", "{}", "{'a': 1}"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/112_prompt2ac", "code_candidates": [{"code": "def delete_and_check_palindrome(s: str, c: str) -> tuple:\n    # Create a set of characters to delete for efficient lookup\n    chars_to_delete = set(c)\n    \n    # Delete characters from s that appear in c\n    result_string = ''.join(char for char in s if char not in chars_to_delete)\n    \n    # Check if the resulting string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return (result_string, is_palindrome)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["('bcd', False)", "('acdef', False)", "('cdedc', True)", "('dik', False)", "('', True)", "('abcdedcba', True)", "('abcdedcba', True)", "('abba', True)", "('', True)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/113_prompt2ac", "code_candidates": [{"code": "def count_odd_digits(strings):\n    \"\"\"\n    Count odd digits in each string and return formatted results.\n    \n    Args:\n        strings: List of strings containing only digits\n        \n    Returns:\n        List of formatted strings with odd digit counts\n    \"\"\"\n    result = []\n    odd_digits = {'1', '3', '5', '7', '9'}\n    \n    for string in strings:\n        count = sum(1 for char in string if char in odd_digits)\n        result.append(f'the number of odd digits is {count}')\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["['the number of odd digits is 4']", "['the number of odd digits is 1', 'the number of odd digits is 8']", "['the number of odd digits is 2', 'the number of odd digits is 3', 'the number of odd digits is 2']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/114_prompt2ac", "code_candidates": [{"code": "def minSubArraySum(nums):\n    if not nums:\n        return 0\n    \n    min_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        current_sum = min(nums[i], current_sum + nums[i])\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/115_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef min_bucket_operations(wells: List[List[int]], bucket_capacity: int) -> int:\n    \"\"\"\n    Calculate the minimum number of bucket operations needed to empty all wells.\n    \n    Args:\n        wells: A list of lists where each inner list represents a well with 0s and 1s\n               (1s represent water units)\n        bucket_capacity: The capacity of each bucket\n    \n    Returns:\n        The total number of bucket operations required to empty all wells\n    \"\"\"\n    if not wells or bucket_capacity <= 0:\n        return 0\n    \n    total_operations = 0\n    \n    for well in wells:\n        # Count water units in the current well\n        water_units = sum(well)\n        \n        # If there's water in the well, calculate operations needed\n        if water_units > 0:\n            # Calculate operations needed for this well\n            operations = (water_units + bucket_capacity - 1) // bucket_capacity\n            total_operations += operations\n    \n    return total_operations", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["6", "5", "0", "4", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/116_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef sort_by_binary_ones(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sort an array of non-negative integers by number of 1s in binary representation\n    in descending order. For ties, sort by decimal value ascending.\n    \n    Args:\n        arr: List of non-negative integers\n        \n    Returns:\n        Sorted list according to the specified criteria\n        \n    Raises:\n        ValueError: If array contains negative integers\n    \"\"\"\n    if not arr:\n        return []\n    \n    # Validate input\n    for num in arr:\n        if num < 0:\n            raise ValueError(\"All numbers must be non-negative\")\n    \n    # Sort by number of 1s in binary (descending) then by value (ascending)\n    return sorted(arr, key=lambda x: (-bin(x).count('1'), x))", "index": 0, "passed_case": [3, 6, 7], "case_status": ["[3, 5, 1, 2, 4]", "execution error: 1", "[3, 1, 2, 4, 0]", "[]", "[77, 7, 3, 3, 5, 5, 5, 2, 2, 4, 4]", "[44, 3, 5, 6, 12, 32]", "[2, 4, 8, 16, 32]", "[2, 4, 8, 16, 32]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/117_prompt2ac", "code_candidates": [{"code": "def words_with_n_consonants(s: str, n: int) -> list:\n    if not s:\n        return []\n    \n    vowels = set('aeiouAEIOU')\n    result = []\n    words = s.split()\n    \n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['little']", "['Mary', 'lamb']", "[]", "['world']", "['Uncle']", "[]", "['b', 'c', 'd', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/118_prompt2ac", "code_candidates": [{"code": "def find_vowel_between_consonants(word: str) -> str:\n    if len(word) < 3:\n        return \"\"\n    \n    vowels = set('aeiouAEIOU')\n    candidates = []\n    \n    # Check each character (except first and last) to see if it's a vowel between consonants\n    for i in range(1, len(word) - 1):\n        if word[i] in vowels:\n            if word[i-1] not in vowels and word[i+1] not in vowels:\n                candidates.append((i, word[i]))\n    \n    if not candidates:\n        return \"\"\n    \n    # Find the candidate closest to the center\n    # If equidistant, prioritize the left one\n    center = (len(word) - 1) / 2\n    best_candidate = candidates[0]\n    best_distance = abs(best_candidate[0] - center)\n    \n    for i, (pos, vowel) in enumerate(candidates):\n        distance = abs(pos - center)\n        if distance < best_distance:\n            best_candidate = (pos, vowel)\n            best_distance = distance\n        elif distance == best_distance and i > 0:  # Equidistant, prefer left\n            # Already have the left one, so we keep it\n            pass\n    \n    return best_candidate[1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["u", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/119_prompt2ac", "code_candidates": [{"code": "def can_form_balanced(s1: str, s2: str) -> str:\n    def is_balanced(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    # Check both possible concatenations\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/120_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef k_smallest_numbers(nums: List[int], k: int) -> List[int]:\n    if k == 0:\n        return []\n    \n    # Get unique elements and sort them\n    unique_sorted = sorted(set(nums))\n    \n    # Return first k elements or all if k exceeds unique count\n    return unique_sorted[:k]", "index": 0, "passed_case": [0, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[-4, 4]", "[-3]", "[-123, -3, 0]", "[-123, -3, 0, 1]", "[-13, -8, 0, 3, 5, 15]", "[-10, -1]", "[-7]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/121_prompt2ac", "code_candidates": [{"code": "def sum_matching_parity(nums):\n    \"\"\"\n    Return the sum of elements where the element's parity matches the position's parity.\n    \n    Args:\n        nums: A non-empty list of integers\n        \n    Returns:\n        int: Sum of elements where element parity matches position parity\n    \"\"\"\n    total = 0\n    for i, num in enumerate(nums):\n        if i % 2 == num % 2:\n            total += num\n    return total", "index": 0, "passed_case": [], "case_status": ["6", "388", "9", "10", "43", "24"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/122_prompt2ac", "code_candidates": [{"code": "def sum_two_digit_elements(arr, k):\n    \"\"\"\n    Returns the sum of elements with at most two digits from the first k elements of arr.\n    \n    Args:\n        arr: A non-empty array of integers\n        k: An integer representing how many elements from the start to consider\n        \n    Returns:\n        The sum of elements with at most two digits (0-99) from the first k elements\n    \"\"\"\n    total = 0\n    for i in range(min(k, len(arr))):\n        if 0 <= arr[i] <= 99:\n            total += arr[i]\n    return total", "index": 0, "passed_case": [1, 2, 3, 4], "case_status": ["1", "0", "125", "24", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/123_prompt2ac", "code_candidates": [{"code": "def odd_collatz_numbers(n):\n    \"\"\"\n    Return a sorted list of all odd numbers in the Collatz sequence for n.\n    \n    Args:\n        n (int): A positive integer\n        \n    Returns:\n        List[int]: Sorted list of all odd numbers in the Collatz sequence\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    odd_numbers = set()\n    current = n\n    \n    while current != 1:\n        if current % 2 == 1:  # current is odd\n            odd_numbers.add(current)\n            current = 3 * current + 1\n        else:  # current is even\n            current = current // 2\n    \n    # Add 1 since the sequence always ends with 1\n    odd_numbers.add(1)\n    \n    return sorted(list(odd_numbers))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 7, 11, 13, 17]", "[1, 5]", "[1, 3, 5]", "[1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/124_prompt2ac", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef validate_date(date_string: str) -> bool:\n    if not date_string or not isinstance(date_string, str):\n        return False\n    \n    # Check if format is valid (dd-mm-yyyy or mm-dd-yyyy with - or /)\n    if '-' in date_string:\n        parts = date_string.split('-')\n        separator = '-'\n    elif '/' in date_string:\n        parts = date_string.split('/')\n        separator = '/'\n    else:\n        return False\n    \n    if len(parts) != 3:\n        return False\n    \n    try:\n        day_str, month_str, year_str = parts\n        day = int(day_str)\n        month = int(month_str)\n        year = int(year_str)\n    except ValueError:\n        return False\n    \n    # Check month range\n    if month < 1 or month > 12:\n        return False\n    \n    # Check year (assuming any 4-digit year is valid)\n    if len(year_str) != 4:\n        return False\n    \n    # Days in each month\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Adjust February for leap years\n    if is_leap_year(year):\n        days_in_month[1] = 29\n    \n    # Check day range\n    if day < 1 or day > days_in_month[month - 1]:\n        return False\n    \n    # Check if the format matches the expected pattern\n    if len(day_str) != 2 or len(month_str) != 2 or len(year_str) != 4:\n        return False\n    \n    return True\n\ndef is_leap_year(year: int) -> bool:\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/125_prompt2ac", "code_candidates": [{"code": "def process_string(s: str) -> list:\n    if not s or s.isspace():\n        return []\n    \n    if ' ' in s:\n        return s.split(' ')\n    elif ',' in s:\n        return s.split(',')\n    else:\n        count = 0\n        for char in s:\n            if char.islower():\n                ascii_val = ord(char)\n                if ascii_val % 2 == 1:  # odd ASCII value\n                    count += 1\n        return [count]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['Hello', 'world!']", "['Hello', 'world!']", "['Hello', 'world,!']", "['Hello,Hello,world', '!']", "[3]", "[3]", "[3]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/126_prompt2ac", "code_candidates": [{"code": "def is_sorted(lst):\n    if len(lst) <= 1:\n        return False\n    \n    # Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    \n    # Check if sorted in ascending order\n    is_ascending = all(lst[i] <= lst[i+1] for i in range(len(lst)-1))\n    \n    # Check if sorted in descending order\n    is_descending = all(lst[i] >= lst[i+1] for i in range(len(lst)-1))\n    \n    # Return True if sorted in either order\n    return is_ascending or is_descending", "index": 0, "passed_case": [1, 2, 3, 4, 5, 9, 10, 12], "case_status": ["False", "True", "False", "True", "True", "False", "False", "False", "True", "False", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/127_prompt2ac", "code_candidates": [{"code": "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef check_prime_intersection(interval1, interval2):\n    # Find intersection\n    start = max(interval1[0], interval2[0])\n    end = min(interval1[1], interval2[1])\n    \n    # Check if there's an intersection\n    if start > end:\n        return 'NO'\n    \n    # Calculate length of intersection\n    length = end - start\n    \n    # Check if length is prime\n    if is_prime(length):\n        return 'YES'\n    else:\n        return 'NO'", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["NO", "NO", "YES", "YES", "NO", "NO", "NO", "NO"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/128_prompt2ac", "code_candidates": [{"code": "from typing import List, Optional\n\ndef calculate_signed_magnitude_sum(numbers: List[int]) -> Optional[int]:\n    if not numbers:\n        return None\n    \n    if any(num == 0 for num in numbers):\n        return 0\n    \n    magnitude_sum = sum(abs(num) for num in numbers)\n    \n    negative_count = sum(1 for num in numbers if num < 0)\n    sign_factor = 1 if negative_count % 2 == 0 else -1\n    \n    return magnitude_sum * sign_factor", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["-9", "0", "-10", "None", "20", "4", "-4", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/129_prompt2ac", "code_candidates": [{"code": "def path(grid, k):\n    N = len(grid)\n    if N < 2:\n        return []\n    \n    # Find the position of each value in the grid\n    pos = {}\n    for i in range(N):\n        for j in range(N):\n            pos[grid[i][j]] = (i, j)\n    \n    # Get the maximum value in the grid\n    max_val = N * N\n    \n    # Start with the maximum value and build the path\n    # We want the lexicographically smallest path of length k\n    # So we start from the largest value and try to go to smaller values\n    result = []\n    current_val = max_val\n    current_pos = pos[current_val]\n    \n    # For k=1, just return the maximum value\n    if k == 1:\n        return [current_val]\n    \n    # Build the path\n    result = [current_val]\n    for _ in range(k - 1):\n        # Find the neighbor with the smallest value\n        min_neighbor = None\n        min_pos = None\n        \n        # Check all 4 neighbors\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = current_pos[0] + di, current_pos[1] + dj\n            # Check if neighbor is within bounds\n            if 0 <= ni < N and 0 <= nj < N:\n                neighbor_val = grid[ni][nj]\n                # If this is the first neighbor or if it's smaller than current min\n                if min_neighbor is None or neighbor_val < min_neighbor:\n                    min_neighbor = neighbor_val\n                    min_pos = (ni, nj)\n        \n        # If no valid neighbor found, we can't proceed\n        if min_neighbor is None:\n            break\n            \n        current_val = min_neighbor\n        current_pos = min_pos\n        result.append(current_val)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[9, 6, 3]", "[9]", "[16, 12, 8, 4]", "[16, 3, 5, 3, 5, 3, 5]", "[16, 11, 1, 7, 1]", "[16, 3, 9, 3, 9, 3, 9, 3, 9]", "[16, 3, 9, 3, 9, 3, 9, 3, 9, 3, 9, 3]", "[9, 5, 1, 3, 1, 3, 1, 3]", "[9, 4, 7, 2, 3, 2, 3, 2]", "[4, 2, 1, 2, 1, 2, 1, 2, 1, 2]", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/130_prompt2ac", "code_candidates": [{"code": "def tri(n):\n    if n < 0:\n        return []\n    \n    # Initialize the sequence with the base cases\n    sequence = [1, 1, 2]\n    \n    # Return appropriate slice based on n\n    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 1]\n    elif n == 2:\n        return [1, 1, 2]\n    else:\n        # Generate the sequence up to n\n        for i in range(3, n + 1):\n            next_num = sequence[i-1] + sequence[i-2] + sequence[i-3]\n            sequence.append(next_num)\n        return sequence", "index": 0, "passed_case": [8], "case_status": ["[1, 1, 2, 4]", "[1, 1, 2, 4, 7]", "[1, 1, 2, 4, 7, 13]", "[1, 1, 2, 4, 7, 13, 24]", "[1, 1, 2, 4, 7, 13, 24, 44]", "[1, 1, 2, 4, 7, 13, 24, 44, 81]", "[1, 1, 2, 4, 7, 13, 24, 44, 81, 149]", "[1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415]", "[1]", "[1, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/131_prompt2ac", "code_candidates": [{"code": "def digits(n: int) -> int:\n    product = 1\n    has_odd = False\n    \n    for digit in str(n):\n        d = int(digit)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    \n    return product if has_odd else 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["5", "5", "5", "315", "2625", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/132_prompt2ac", "code_candidates": [{"code": "def has_nested_brackets(s: str) -> bool:\n    \"\"\"\n    Determines if there exists a valid subsequence of square brackets \n    where at least one bracket is nested at 2 or more levels deep.\n    \n    Args:\n        s: Input string containing square brackets\n        \n    Returns:\n        True if such a subsequence exists, False otherwise\n    \"\"\"\n    if not s:\n        return False\n    \n    # Find all valid subsequences (contiguous subsequences of brackets)\n    # and check if any has nesting depth >= 2\n    for i in range(len(s)):\n        if s[i] == '[':\n            depth = 0\n            for j in range(i, len(s)):\n                if s[j] == '[':\n                    depth += 1\n                elif s[j] == ']':\n                    depth -= 1\n                    # If we reach a closing bracket and depth is at least 2,\n                    # we found a valid subsequence with nesting\n                    if depth >= 2:\n                        return True\n                # If we encounter a non-bracket character, break\n                elif s[j] not in '[]':\n                    break\n                # If depth goes negative, invalid sequence\n                if depth < 0:\n                    break\n    \n    return False", "index": 0, "passed_case": [2, 3, 4, 5, 7, 8, 11, 12, 13], "case_status": ["False", "True", "False", "False", "True", "False", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/133_prompt2ac", "code_candidates": [{"code": "import math\nfrom typing import List\n\ndef sum_of_squares_of_ceiling(numbers: List[float]) -> int:\n    \"\"\"\n    Compute the sum of squares of ceiling-rounded values.\n    \n    Args:\n        numbers: A list of numbers\n        \n    Returns:\n        The sum of squares of ceiling-rounded values\n    \"\"\"\n    return sum(math.ceil(num) ** 2 for num in numbers)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["14", "14", "84", "29", "6", "10230", "200000000", "75", "1086", "0", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/134_prompt2ac", "code_candidates": [{"code": "def check_if_last_char_is_a_letter(txt):\n    if not txt:\n        return True\n    \n    if not txt[-1].isalpha():\n        return False\n    \n    # If the string has only one character and it's a letter\n    if len(txt) == 1:\n        return True\n    \n    # Check if the character before the last one is a space\n    # This would mean the last character is not part of a word\n    return txt[-2] == ' '", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 7, 8, 9], "case_status": ["False", "True", "False", "True", "False", "False", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/135_prompt2ac", "code_candidates": [{"code": "def find_decreasing_index(arr):\n    \"\"\"\n    Returns the smallest index i where arr[i] < arr[i-1], or -1 if array is strictly increasing.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        int: Smallest index where element decreases, or -1 if strictly increasing\n    \"\"\"\n    if len(arr) <= 1:\n        return -1\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    \n    return -1", "index": 0, "passed_case": [0, 1, 2, 4], "case_status": ["3", "-1", "2", "2", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/136_prompt2ac", "code_candidates": [{"code": "def find_max_min(numbers):\n    \"\"\"\n    Returns a tuple (a, b) where 'a' is the largest integer in the list \n    and 'b' is the smallest integer in the list.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        tuple: (max_value, min_value) or (None, None) if empty list\n    \"\"\"\n    if not numbers:\n        return (None, None)\n    \n    return (max(numbers), min(numbers))", "index": 0, "passed_case": [5], "case_status": ["(7, 1)", "(7, 0)", "(6, -2)", "(7, -7)", "(9, -9)", "(None, None)", "(0, 0)", "(-1, -6)", "(0, -6)", "(1, -6)", "(1, -100)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/137_prompt2ac", "code_candidates": [{"code": "def compare_values(val1, val2):\n    \"\"\"\n    Compare two values that can be integers, floats, or string representations of numbers.\n    Returns the smaller value in its original type, or None if equal.\n    String numbers can use comma or period as decimal separator.\n    \"\"\"\n    def to_numeric(val):\n        if isinstance(val, (int, float)):\n            return float(val)\n        elif isinstance(val, str):\n            # Normalize decimal separator to period\n            normalized = val.replace(',', '.')\n            try:\n                return float(normalized)\n            except ValueError:\n                raise ValueError(f\"Cannot convert '{val}' to a number\")\n        else:\n            raise TypeError(f\"Unsupported type: {type(val)}\")\n    \n    num1 = to_numeric(val1)\n    num2 = to_numeric(val2)\n    \n    if num1 < num2:\n        return val1\n    elif num2 < num1:\n        return val2\n    else:\n        return None", "index": 0, "passed_case": [7], "case_status": ["1", "1", "2", "5", "1", "5,1", "1", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/138_prompt2ac", "code_candidates": [{"code": "def can_be_sum_of_four_positive_evens(n: int) -> bool:\n    # Minimum possible sum of 4 positive even integers is 8 (2+2+2+2)\n    if n < 8:\n        return False\n    \n    # Check if n is even (necessary condition since sum of even numbers is even)\n    if n % 2 != 0:\n        return False\n    \n    # Since n >= 8 and n is even, we can always express it as sum of 4 positive even integers\n    # For example: n = 2 + 2 + 2 + (n-6), where (n-6) is even and >= 2 when n >= 8\n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["False", "False", "True", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/139_prompt2ac", "code_candidates": [{"code": "def product_of_factorials(n: int) -> int:\n    if n <= 0:\n        return 1\n    \n    result = 1\n    factorial = 1\n    \n    for i in range(1, n + 1):\n        factorial *= i\n        result *= factorial\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["288", "34560", "125411328000", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/140_prompt2ac", "code_candidates": [{"code": "import re\nfrom typing import List, Dict, Optional\n\ndef replace_spaces(text: str) -> str:\n    \"\"\"\n    Replace all spaces in text with underscores, but replace sequences of 2 or more \n    consecutive spaces with a single dash.\n    \n    Args:\n        text: Input string to process\n        \n    Returns:\n        String with spaces replaced according to the rules\n    \"\"\"\n    if not text:\n        return text\n    \n    # First replace sequences of 2 or more spaces with a single dash\n    result = re.sub(r' {2,}', '-', text)\n    # Then replace remaining single spaces with underscores\n    result = result.replace(' ', '_')\n    \n    return result", "index": 0, "passed_case": [0, 1, 3, 4], "case_status": ["Example", "Mudasir_Hanif_", "Yellow_Yellow-Dirty-Fellow", "Exa-mple", "-Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/141_prompt2ac", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef validate_file_names(file_names: List[str]) -> List[bool]:\n    \"\"\"\n    Validates file names based on the following criteria:\n    - Exactly 3 digits\n    - Exactly one dot\n    - Non-empty substring before dot starting with a letter\n    - Extension being one of ['txt', 'exe', 'dll']\n    \n    Args:\n        file_names: List of file name strings to validate\n        \n    Returns:\n        List of booleans indicating whether each file name is valid\n    \"\"\"\n    result = []\n    \n    for file_name in file_names:\n        # Check if there's exactly one dot\n        if file_name.count('.') != 1:\n            result.append(False)\n            continue\n            \n        # Split into name and extension\n        name_part, ext_part = file_name.split('.')\n        \n        # Check if extension is valid\n        if ext_part not in ['txt', 'exe', 'dll']:\n            result.append(False)\n            continue\n            \n        # Check if name part is non-empty and starts with a letter\n        if not name_part or not name_part[0].isalpha():\n            result.append(False)\n            continue\n            \n        # Check if name part contains exactly 3 digits\n        digit_count = sum(1 for c in name_part if c.isdigit())\n        if digit_count != 3:\n            result.append(False)\n            continue\n            \n        # Check if name part contains only letters and digits\n        if not name_part.isalnum():\n            result.append(False)\n            continue\n            \n        result.append(True)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False]", "[False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]", "[False, False, False, False]", "[False, False]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/142_prompt2ac", "code_candidates": [{"code": "def process_and_sum(numbers: list) -> int:\n    \"\"\"\n    Process list entries based on index multiples and return the sum.\n    \n    For indices that are multiples of 3: cube the entry\n    For indices that are multiples of 4 but not 3: square the entry\n    For all other indices: leave unchanged\n    Indices that are multiples of both 3 and 4 (i.e., 12): cube (prioritizing 3)\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        Sum of processed entries\n    \"\"\"\n    if not numbers:\n        return 0\n        \n    result = 0\n    for i, num in enumerate(numbers):\n        if i % 12 == 0:  # Multiple of both 3 and 4 (i.e., 12)\n            result += num ** 3\n        elif i % 3 == 0:  # Multiple of 3 only\n            result += num ** 3\n        elif i % 4 == 0:  # Multiple of 4 but not 3\n            result += num ** 2\n        else:  # All other indices\n            result += num\n            \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 5, 8], "case_status": ["6", "14", "0", "9", "-5", "0", "20", "-175710", "0", "28000", "-2308"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/143_prompt2ac", "code_candidates": [{"code": "def get_words_with_certain_lengths(sentence: str, certain_lengths: list[int]) -> list[str]:\n    if not sentence or not certain_lengths:\n        return []\n    \n    words = sentence.split()\n    result = []\n    \n    for word in words:\n        if len(word) in certain_lengths:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [5], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/144_prompt2ac", "code_candidates": [{"code": "def simplify(a, b):\n    \"\"\"Your task is to implement a function that will simplify the expression\n    x * n, or x + n. The function returns True if x * n or x + n evaluates to a whole number and False\n    otherwise. Both x and n, are string representation of a fraction, and have the following format,\n    <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n    You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n    simplify(\"1/5\", \"5/1\") = False\n    simplify(\"1/6\", \"2/1\") = True\n    simplify(\"7/10\", \"10/2\") = True\n    \"\"\"\n    from fractions import Fraction\n    \n    # Parse the fractions\n    frac_a = Fraction(a)\n    frac_b = Fraction(b)\n    \n    # Calculate both operations\n    product = frac_a * frac_b\n    sum_result = frac_a + frac_b\n    \n    # Check if either result is a whole number\n    return product.denominator == 1 or sum_result.denominator == 1", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["True", "False", "True", "False", "True", "True", "True", "False", "False", "True", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/145_prompt2ac", "code_candidates": [{"code": "def order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in descending or ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [1, 11, -1, -12, -11]\n    >>> order_by_points([]) == []\n    \"\"\"\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Create list of (digit_sum, original_index, value) tuples\n    indexed_nums = [(digit_sum(num), i, num) for i, num in enumerate(nums)]\n    \n    # Sort by digit sum first, then by original index for stability\n    indexed_nums.sort(key=lambda x: (x[0], x[1]))\n    \n    # Extract just the values in the new order\n    return [num for _, _, num in indexed_nums]", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/146_prompt2ac", "code_candidates": [{"code": "def count_numbers(numbers):\n    if not numbers:\n        return 0\n    \n    def is_odd_digit(digit):\n        return digit % 2 == 1\n    \n    def has_valid_first_last_digits(num):\n        abs_num = abs(num)\n        digits = [int(d) for d in str(abs_num)]\n        first_digit = digits[0]\n        last_digit = digits[-1]\n        \n        first_is_odd = is_odd_digit(first_digit)\n        last_is_odd = is_odd_digit(last_digit)\n        \n        return first_is_odd == last_is_odd\n    \n    count = 0\n    for num in numbers:\n        if num == 10 or num < 10 or num > 10:\n            if has_valid_first_last_digits(num):\n                count += 1\n    \n    return count", "index": 0, "passed_case": [3, 6], "case_status": ["4", "3", "4", "4", "5", "1", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/147_prompt2ac", "code_candidates": [{"code": "def get_max_triples(n):\n    # Create array a where a[i] = i * i + i - 1\n    a = [i * i + i - 1 for i in range(1, n + 1)]\n    \n    # Count triples where sum is divisible by 3\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    \n    return count", "index": 0, "passed_case": [0, 1], "case_status": ["1", "4", "24", "51744"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/148_prompt2ac", "code_candidates": [{"code": "def planets_between(planet1: str, planet2: str) -> tuple:\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are valid\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    \n    # Get indices of both planets\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    \n    # Determine the range (inclusive)\n    start_index = min(index1, index2)\n    end_index = max(index1, index2)\n    \n    # Extract the planets in range and add 'abc' prefix\n    result = tuple(f\"abc{planet}\" for planet in planets[start_index:end_index+1])\n    \n    return result", "index": 0, "passed_case": [6], "case_status": ["('abcJupiter', 'abcSaturn', 'abcUranus', 'abcNeptune')", "('abcMercury', 'abcVenus', 'abcEarth')", "('abcMercury', 'abcVenus', 'abcEarth', 'abcMars', 'abcJupiter', 'abcSaturn', 'abcUranus')", "('abcVenus', 'abcEarth', 'abcMars', 'abcJupiter', 'abcSaturn', 'abcUranus', 'abcNeptune')", "('abcEarth',)", "('abcEarth', 'abcMars')", "()"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/149_prompt2ac", "code_candidates": [{"code": "def filter_and_sort_strings(strings):\n    \"\"\"\n    Filter out strings with odd lengths, then sort remaining strings by length\n    in ascending order, with alphabetical sorting as tiebreaker.\n    \n    Args:\n        strings: List of strings\n        \n    Returns:\n        List of strings filtered and sorted\n    \"\"\"\n    # Filter out strings with odd lengths\n    even_length_strings = [s for s in strings if len(s) % 2 == 0]\n    \n    # Sort by length first, then alphabetically\n    return sorted(even_length_strings, key=lambda x: (len(x), x))", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["['aa']", "['AI', 'asdf', 'school']", "[]", "['abcd', 'dcba']", "['AI', 'ai', 'au']", "[]", "['cc', 'dd', 'aaaa', 'bbbb']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/150_prompt2ac", "code_candidates": [{"code": "def foo(a, b, c):\n    if a < 2:\n        return b\n    \n    for i in range(2, int(a**0.5) + 1):\n        if a % i == 0:\n            return b\n    \n    return c", "index": 0, "passed_case": [], "case_status": ["12", "8", "5212", "52", "12", "1245", "56", "34", "2", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/151_prompt2ac", "code_candidates": [{"code": "def double_the_difference(lst):\n    '''\n    Given a list of numbers, return the sum of squares of the numbers\n    in the list that are odd. Ignore numbers that are negative or not integers.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n   \n    If the input list is empty, return 0.\n    '''\n    if not lst:\n        return 0\n    \n    total = 0\n    for num in lst:\n        if isinstance(num, int) and num >= 0 and num % 2 == 1:\n            total += num ** 2\n    \n    return total", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["0", "25", "0", "0", "0", "34", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/152_prompt2ac", "code_candidates": [{"code": "from typing import List, Union\n\ndef compare_scores(guesses: List[Union[int, float]], scores: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    Compare game scores with guesses and return absolute differences.\n    \n    Args:\n        guesses: List of guessed scores\n        scores: List of actual scores\n        \n    Returns:\n        List of absolute differences (0 for correct guesses)\n    \"\"\"\n    if not guesses and not scores:\n        return []\n    \n    return [abs(guess - score) for guess, score in zip(guesses, scores)]", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[0, 0, 0, 0, 3, 3]", "[0, 0, 0, 0, 0, 0]", "[2, 4, 6]", "[2, 0, 0, 1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/153_prompt2ac", "code_candidates": [{"code": "from typing import List\n\ndef strongest_extension(class_name: str, extensions: List[str]) -> str:\n    def calculate_strength(extension: str) -> int:\n        uppercase_count = sum(1 for char in extension if char.isupper())\n        lowercase_count = sum(1 for char in extension if char.islower())\n        return uppercase_count - lowercase_count\n    \n    max_strength = float('-inf')\n    strongest_ext = \"\"\n    \n    for extension in extensions:\n        strength = calculate_strength(extension)\n        if strength > max_strength:\n            max_strength = strength\n            strongest_ext = extension\n    \n    return class_name + \".\" + strongest_ext", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8], "case_status": ["Watashi.eIGHt8OKe", "Boku123.YEs.WeCaNe", "__YESIMHERE.NuLl__", "K.TAR", "__HAHA.123", "YameRore.okIWILL123", "finNNalLLly.WoW", "_.Bb", "Sp.671235"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/154_prompt2ac", "code_candidates": [{"code": "def cycpattern_check(a, b):\n    if not b:\n        return True\n    if len(b) > len(a):\n        return False\n    \n    # Check if b or any of its rotations is a substring of a\n    # Create all possible rotations of b and check if any is in a\n    for i in range(len(b)):\n        rotation = b[i:] + b[:i]\n        if rotation in a:\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/156_prompt2ac", "code_candidates": [{"code": "def int_to_roman(num: int) -> str:\n    if not 1 <= num <= 1000:\n        raise ValueError(\"Input must be between 1 and 1000\")\n    \n    # Define the mapping of values to roman numerals in descending order\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    numerals = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    \n    result = []\n    \n    # Process each value from largest to smallest\n    for i in range(len(values)):\n        # Add the numeral as many times as the value fits into num\n        count = num // values[i]\n        if count > 0:\n            result.append(numerals[i] * count)\n            num -= values[i] * count\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/157_prompt2ac", "code_candidates": [{"code": "def right_angle_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return True if the three\n    sides form a right-angled triangle, False otherwise.\n    A right-angled triangle is a triangle in which one angle is right angle or \n    90 degree.\n    Example:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n    # Sort the sides to identify the largest side (potential hypotenuse)\n    sides = sorted([a, b, c])\n    \n    # Check if it's a valid triangle first (triangle inequality)\n    if sides[0] + sides[1] <= sides[2]:\n        return False\n    \n    # Check Pythagorean theorem: a\u00b2 + b\u00b2 = c\u00b2\n    return abs(sides[0]**2 + sides[1]**2 - sides[2]**2) < 1e-10", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["True", "False", "True", "False", "True", "False", "True", "True", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/158_prompt2ac", "code_candidates": [{"code": "def word_with_min_unique_chars(words):\n    \"\"\"\n    Returns the word with the minimum number of unique characters from a list of strings,\n    with lexicographical ordering as tiebreaker.\n    \n    Args:\n        words: List of strings\n        \n    Returns:\n        String with minimum unique characters, or lexicographically smallest in case of tie\n    \"\"\"\n    if not words:\n        return None\n        \n    min_unique_count = float('inf')\n    result = None\n    \n    for word in words:\n        unique_count = len(set(word))\n        if (unique_count < min_unique_count or \n            (unique_count == min_unique_count and \n             (result is None or word < result))):\n            min_unique_count = unique_count\n            result = word\n            \n    return result", "index": 0, "passed_case": [1, 2, 3, 8, 9], "case_status": ["of", "enam", "aaaaaaa", "abc", "of", "we", "a", "a", "b", "play"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/159_prompt2ac", "code_candidates": [{"code": "def rabbit_eating(initial_eaten: int, need: int, remaining: int) -> list:\n    \"\"\"\n    Calculate total carrots eaten and remaining carrots after rabbit eats.\n    \n    Args:\n        initial_eaten: Number of carrots already eaten\n        need: Number of carrots rabbit wants to eat\n        remaining: Number of carrots available\n    \n    Returns:\n        List containing [total carrots eaten, remaining carrots after eating]\n    \"\"\"\n    # Calculate how many carrots rabbit can actually eat\n    actual_eaten = min(need, remaining)\n    \n    # Calculate total eaten (initial + actual eaten)\n    total_eaten = initial_eaten + actual_eaten\n    \n    # Calculate remaining carrots\n    remaining_carrots = max(0, remaining - need)\n    \n    return [total_eaten, remaining_carrots]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["[11, 4]", "[12, 1]", "[11, 0]", "[7, 0]", "[9, 2]", "[5, 0]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/160_prompt2ac", "code_candidates": [{"code": "def evaluate_expression(operators, operands):\n    if len(operators) != len(operands) - 1:\n        raise ValueError(\"Number of operators must be one less than number of operands\")\n    \n    # Create the expression string\n    expression = str(operands[0])\n    for i, operator in enumerate(operators):\n        expression += f\" {operator} {operands[i + 1]}\"\n    \n    # Use eval with proper precedence\n    return eval(expression)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["37", "9", "8"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/161_prompt2ac", "code_candidates": [{"code": "def reverse_case(s: str) -> str:\n    if not s:\n        return s\n    \n    result = []\n    has_letters = False\n    \n    for char in s:\n        if char.isalpha():\n            has_letters = True\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n        else:\n            result.append(char)\n    \n    # If no letters found, return original string\n    if not has_letters:\n        return s\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 2, 3, 4, 6, 7], "case_status": ["aSdF", "1234", "AB", "#A@c", "#aSDFw^45", "#6@2", "#$A^d", "#CCC"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/162_prompt2ac", "code_candidates": [{"code": "import hashlib\n\ndef string_to_md5(text):\n    if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "None", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/163_prompt2ac", "code_candidates": [{"code": "def odd_numbers_in_range(a: int, b: int) -> list[int]:\n    \"\"\"\n    Returns a list of odd numbers in the range [a, b] in ascending order.\n    \n    Args:\n        a: First positive integer (inclusive)\n        b: Second positive integer (inclusive)\n    \n    Returns:\n        List of odd numbers in ascending order, or empty list if none exist\n    \"\"\"\n    result = []\n    for num in range(a, b + 1):\n        if num % 2 == 1:\n            result.append(num)\n    return result", "index": 0, "passed_case": [], "case_status": ["[3, 5, 7, 9]", "[]", "[]", "[17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ac"}
{"name": "HumanEval/0_prompt2ap", "code_candidates": [{"code": "def has_close_elements(numbers: list, threshold: float) -> bool:\n    \"\"\"\n    Check if any two elements in the list have an absolute difference less than the given threshold.\n    \n    Args:\n        numbers: List of numbers\n        threshold: The threshold value for comparison\n        \n    Returns:\n        True if such elements exist, False otherwise\n    \"\"\"\n    # Handle edge cases\n    if not numbers or len(numbers) < 2:\n        return False\n    \n    # Check all pairs of elements\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "False", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/1_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace has a certain requirement to meet) and not nested within each other\n    \"\"\"\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n            \n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            \n        if balance == 0 and current_group:\n            result.append(''.join(current_group))\n            current_group = []\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["['(()())', '((()))', '()', '((())()())']", "['()', '(())', '((()))', '(((())))']", "['(()(())((())))']", "['()', '(())', '(()())']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/2_prompt2ap", "code_candidates": [{"code": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into an integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1). Return the decimal part of the number. \"\"\"\n    return number - int(number)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0.5", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/3_prompt2ap", "code_candidates": [{"code": "def is_overdrawn(operations: list[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "False", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/4_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(values: List[float]) -> float:\n    if not values:\n        return 0.0\n    \n    mean = sum(values) / len(values)\n    absolute_deviations = [abs(x - mean) for x in values]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/6_prompt2ap", "code_candidates": [{"code": "def parse_parentheses_depth(s: str) -> list[int]:\n    \"\"\"\n    Parse a string containing groups of nested parentheses separated by whitespace\n    and return a list of integers representing the maximum nesting depth for each group.\n    \n    Args:\n        s: A string containing groups of nested parentheses separated by whitespace\n        \n    Returns:\n        A list of integers representing the maximum nesting depth for each group\n    \"\"\"\n    if not s:\n        return []\n    \n    groups = s.split()\n    result = []\n    \n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        \n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        \n        result.append(max_depth)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2], "case_status": ["[2, 3, 1, 3]", "[1, 2, 3, 4]", "[4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/7_prompt2ap", "code_candidates": [{"code": "def filter_strings_with_substring(strings: list, x: str) -> list:\n    \"\"\"\n    Filter a list of strings to return only those that contain the specified substring x.\n    \n    Args:\n        strings: List of strings to filter\n        x: Substring to search for (case-sensitive)\n        \n    Returns:\n        List of strings containing the substring x\n    \"\"\"\n    # Handle edge cases\n    if not strings or not x:\n        return []\n    \n    result = []\n    for s in strings:\n        # Skip None strings\n        if s is None:\n            continue\n        # Check if substring exists in string\n        if x in s:\n            result.append(s)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "['xxx', 'xxxAAA', 'xxx']", "['xxx', 'aaaxxy', 'xxxAAA', 'xxx']", "['grunt', 'prune']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/8_prompt2ap", "code_candidates": [{"code": "from typing import List, Tuple\n\ndef sum_and_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\"\n    Calculate the sum and product of all integers in the list.\n    \n    Args:\n        numbers: A list of integers\n        \n    Returns:\n        A tuple containing (sum, product) of all integers in the list\n    \"\"\"\n    if not numbers:\n        return (0, 1)\n    \n    total_sum = sum(numbers)\n    \n    product = 1\n    for num in numbers:\n        product *= num\n        \n    return (total_sum, product)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["(0, 1)", "(3, 1)", "(100, 0)", "(15, 105)", "(10, 10)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/9_prompt2ap", "code_candidates": [{"code": "def cumulative_max(numbers: list) -> list:\n    if not numbers:\n        return []\n    \n    result = []\n    current_max = numbers[0]\n    \n    for num in numbers:\n        if num > current_max:\n            current_max = num\n        result.append(current_max)\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[]", "[1, 2, 3, 4]", "[4, 4, 4, 4]", "[3, 3, 3, 100, 100]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/10_prompt2ap", "code_candidates": [{"code": "def longest_palindrome(s: str) -> str:\n    if not s:\n        return \"\"\n    \n    def expand_around_center(left: int, right: int) -> str:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n    \n    longest = \"\"\n    \n    for i in range(len(s)):\n        # Check for odd-length palindromes (center at i)\n        palindrome1 = expand_around_center(i, i)\n        # Check for even-length palindromes (center between i and i+1)\n        palindrome2 = expand_around_center(i, i + 1)\n        \n        # Update longest palindrome if we found a longer one\n        if len(palindrome1) > len(longest):\n            longest = palindrome1\n        if len(palindrome2) > len(longest):\n            longest = palindrome2\n    \n    return longest", "index": 0, "passed_case": [0, 1, 3], "case_status": ["", "x", "x", "xyx", "rr"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/13_prompt2ap", "code_candidates": [{"code": "def greatest_common_divisor(a: int, b: int) -> int:\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both arguments must be integers\")\n    \n    if a == 0 and b == 0:\n        return 0\n    \n    a, b = abs(a), abs(b)\n    \n    while b:\n        a, b = b, a % b\n    \n    return a", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["1", "5", "7", "12"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/14_prompt2ap", "code_candidates": [{"code": "def get_prefixes(s: str) -> list[str]:\n    return [s[:i] for i in range(len(s) + 1)]", "index": 0, "passed_case": [], "case_status": ["['']", "['', 'a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']", "['', 'W', 'WW', 'WWW']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/15_prompt2ap", "code_candidates": [{"code": "def string_sequence(n: int) -> str:\n    \"\"\" Return a string containing numbers from 1 to n, delimited by spaces. \"\"\"\n    return ' '.join(str(i) for i in range(1, n + 1))", "index": 0, "passed_case": [], "case_status": ["", "1 2 3", "1 2 3 4 5 6 7 8 9 10"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/16_prompt2ap", "code_candidates": [{"code": "def count_distinct_characters(string: str) -> int:\n    \"\"\" Given a string, find out how many characters (regardless of case) does it consist of\n    \"\"\"\n    return len(set(string.lower()))", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["0", "5", "5", "1", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/18_prompt2ap", "code_candidates": [{"code": "def count_non_overlapping_substrings(string: str, substring: str) -> int:\n    if not substring or not string:\n        return 0\n    \n    count = 0\n    start = 0\n    \n    while True:\n        pos = string.find(substring, start)\n        if pos == -1:\n            break\n        count += 1\n        start = pos + 1\n    \n    return count", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["0", "4", "4", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/19_prompt2ap", "code_candidates": [{"code": "def sort_numbers(input_string: str) -> str:\n    if not input_string:\n        return \"\"\n    \n    # Split the string into individual number strings\n    number_strings = input_string.split()\n    \n    # Convert to floats for proper numerical sorting\n    numbers = [float(num) for num in number_strings]\n    \n    # Sort numerically\n    numbers.sort()\n    \n    # Convert back to strings and join with spaces\n    # Use int() if the number is a whole number to avoid .0 suffix\n    result = \" \".join(str(int(num)) if num.is_integer() else str(num) for num in numbers)\n    \n    return result", "index": 0, "passed_case": [0], "case_status": ["", "execution error: 1", "execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/20_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef find_closest_pair(numbers: List[float]) -> List[float]:\n    if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two numbers\")\n    \n    min_diff = float('inf')\n    closest_pair = []\n    \n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            diff = abs(numbers[i] - numbers[j])\n            if diff < min_diff:\n                min_diff = diff\n                closest_pair = [numbers[i], numbers[j]]\n    \n    return sorted(closest_pair)", "index": 0, "passed_case": [], "case_status": ["[3.9, 4.0]", "[5.0, 5.9]", "[2.0, 2.2]", "[2.0, 2.0]", "[2.2, 3.1]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/23_prompt2ap", "code_candidates": [{"code": "def strlen(string: str) -> int:\n    \"\"\" Return the length of the input string \"\"\"\n    return len(string)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["0", "1", "9"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/24_prompt2ap", "code_candidates": [{"code": "def largest_proper_divisor(n: int) -> int:\n    if n <= 1:\n        return 1\n    \n    # For prime numbers, return 1\n    # Check if n is prime by testing divisibility up to sqrt(n)\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # If we find a divisor, the largest proper divisor is n // i\n            return n // i\n    \n    # If no divisor found, n is prime, so return 1\n    return 1", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["1", "1", "5", "50", "7"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/25_prompt2ap", "code_candidates": [{"code": "def prime_factors(n: int) -> list[int]:\n    if n == 1:\n        return []\n    \n    factors = []\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    \n    if n > 1:\n        factors.append(n)\n    \n    return factors", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["[2]", "[2, 2]", "[2, 2, 2]", "[3, 19]", "[3, 3, 19, 19]", "[3, 3, 3, 19, 19, 19]", "[3, 19, 19, 19]", "[2, 3, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/26_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef remove_k_occurrences(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    Remove all elements that occur exactly k times from the list.\n    \n    Args:\n        nums: List of integers\n        k: Number of occurrences to remove\n        \n    Returns:\n        List with elements occurring exactly k times removed\n    \"\"\"\n    # Count occurrences of each element\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    # Filter out elements that occur exactly k times\n    return [num for num in nums if count[num] != k]", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/27_prompt2ap", "code_candidates": [{"code": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase or uppercase characters to either uppercase or lowercase.\n    \"\"\"\n    return string.swapcase()", "index": 0, "passed_case": [0, 1, 2], "case_status": ["", "hELLO!", "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/41_prompt2ap", "code_candidates": [{"code": "def count_collisions(n: int) -> int:\n    \"\"\"\n    Calculate the total number of collisions between cars moving in opposite directions.\n    \n    Args:\n        n: Number of cars moving from left to right and right to left\n        \n    Returns:\n        Total number of collisions\n    \"\"\"\n    return n * n", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["4", "9", "16", "64", "100"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/49_prompt2ap", "code_candidates": [{"code": "def modp(x: int, y: int) -> int:\n    return (2 ** x) % y", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["3", "2", "1", "8", "1", "4", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/50_prompt2ap", "code_candidates": [{"code": "def candidate(encoded_string):\n    \"\"\"\n    Decodes a string that was encoded with encode_shift by shifting characters back by 5 positions.\n    \n    Args:\n        encoded_string (str): The encoded string to decode\n        \n    Returns:\n        str: The decoded string\n    \"\"\"\n    result = []\n    \n    for char in encoded_string:\n        if char.isalpha():\n            # Determine if the character is uppercase or lowercase\n            if char.isupper():\n                # For uppercase letters, shift back by 5 with wraparound\n                shifted = chr((ord(char) - ord('A') - 5) % 26 + ord('A'))\n            else:\n                # For lowercase letters, shift back by 5 with wraparound\n                shifted = chr((ord(char) - ord('a') - 5) % 26 + ord('a'))\n            result.append(shifted)\n        else:\n            # Non-alphabetic characters remain unchanged\n            result.append(char)\n    \n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/56_prompt2ap", "code_candidates": [{"code": "def is_valid_brackets(s: str) -> bool:\n    \"\"\"\n    Determine if a string of '<' and '>' brackets is properly matched and nested.\n    \n    Args:\n        s: A string containing only '<' and '>' characters\n        \n    Returns:\n        True if brackets are properly matched and nested, False otherwise\n    \"\"\"\n    count = 0\n    for char in s:\n        if char == '<':\n            count += 1\n        elif char == '>':\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/58_prompt2ap", "code_candidates": [{"code": "def common(l1: list, l2: list):\n    \"\"\"Return common.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["[1, 5, 653]", "[2, 3]", "[2, 3, 4]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/59_prompt2ap", "code_candidates": [{"code": "def largest_prime_factor(n: int):\n    largest = -1\n    \n    # Handle factor 2\n    while n % 2 == 0:\n        largest = 2\n        n = n // 2\n    \n    # Handle odd factors from 3 onwards\n    factor = 3\n    while factor * factor <= n:\n        while n % factor == 0:\n            largest = factor\n            n = n // factor\n        factor += 2\n    \n    # If n is still greater than 1, then it's a prime factor\n    if n > 1:\n        largest = n\n    \n    return largest", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["5", "3", "7", "11", "29"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/61_prompt2ap", "code_candidates": [{"code": "def is_balanced(s: str) -> bool:\n    \"\"\"\n    Check if a string of parentheses is properly balanced and nested.\n    \n    Args:\n        s: A string containing parentheses to check\n        \n    Returns:\n        True if all parentheses are correctly matched and nested, False otherwise\n    \"\"\"\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    \n    return len(stack) == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/63_prompt2ap", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    # Use dynamic programming with space optimization\n    a, b, c = 0, 0, 1  # fibfib(0), fibfib(1), fibfib(2)\n    \n    for i in range(3, n + 1):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "0", "4", "24", "81", "274", "927"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/65_prompt2ap", "code_candidates": [{"code": "def circular_shift(x, shift):\n    # Convert to string and handle negative numbers\n    str_x = str(x)\n    is_negative = str_x.startswith('-')\n    if is_negative:\n        str_x = str_x[1:]  # Remove the negative sign\n    \n    # Get the number of digits\n    num_digits = len(str_x)\n    \n    # Handle case where number has only one digit\n    if num_digits <= 1:\n        return str_x if not is_negative else '-' + str_x\n    \n    # Normalize shift using modulo\n    normalized_shift = shift % num_digits if shift != 0 else 0\n    \n    # Perform circular shift\n    if normalized_shift == 0:\n        result = str_x\n    elif shift > 0:  # Left shift\n        result = str_x[normalized_shift:] + str_x[:normalized_shift]\n    else:  # Right shift (shift is negative)\n        result = str_x[-normalized_shift:] + str_x[:-normalized_shift]\n    \n    # Apply negative sign if needed\n    return result if not is_negative else '-' + result", "index": 0, "passed_case": [1, 3, 4], "case_status": ["010", "12", "97", "21", "11"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/69_prompt2ap", "code_candidates": [{"code": "def find_smallest_integer(numbers):\n    \"\"\"\n    Returns the smallest integer from a non-empty list of positive integers \n    that appears at least once in the list.\n    \n    Args:\n        numbers: A non-empty list of positive integers\n        \n    Returns:\n        The smallest integer that appears at least once in the list\n        \n    Raises:\n        ValueError: If input is None or empty list\n    \"\"\"\n    if numbers is None:\n        raise ValueError(\"Input cannot be None\")\n    \n    if not numbers:\n        raise ValueError(\"List cannot be empty\")\n    \n    # Since we want the smallest integer that appears at least once,\n    # and the list contains positive integers, we can simply return\n    # the minimum value in the list\n    return min(numbers)", "index": 0, "passed_case": [0, 3, 4, 5, 6, 7, 9, 10, 12, 15, 21, 22, 23], "case_status": ["1", "1", "3", "8", "2", "1", "2", "1", "3", "1", "1", "2", "1", "1", "1", "1", "1", "1", "1", "2", "10", "2", "1", "1", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/70_prompt2ap", "code_candidates": [{"code": "def strange_order(nums):\n    \"\"\"\n    Returns elements of the input list in a 'strange' order:\n    alternately taking elements from the start and end of the list.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        List of integers in strange order\n    \"\"\"\n    if not nums:\n        return []\n    \n    result = []\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        if len(result) % 2 == 0:\n            result.append(nums[left])\n            left += 1\n        else:\n            result.append(nums[right])\n            right -= 1\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 4, 5, 6, 8], "case_status": ["[1, 4, 2, 3]", "[5, 9, 6, 8, 7]", "[1, 5, 2, 4, 3]", "[5, 1, 6, 9, 7, 8]", "[5, 5, 5, 5]", "[]", "[1, 8, 2, 7, 3, 6, 4, 5]", "[0, -5, 2, -5, 2, 5, 2, 5]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/71_prompt2ap", "code_candidates": [{"code": "import math\nfrom typing import Tuple, Optional\n\ndef triangle_area(a: float, b: float, c: float) -> Optional[float]:\n    \"\"\"\n    Calculate the area of a triangle given three sides using Heron's formula.\n    \n    Args:\n        a, b, c: The lengths of the three sides of the triangle\n        \n    Returns:\n        The area of the triangle rounded to 2 decimal places, or None if \n        the sides don't form a valid triangle\n    \"\"\"\n    # Check for valid side lengths (positive numbers)\n    if a <= 0 or b <= 0 or c <= 0:\n        return None\n    \n    # Check triangle inequality\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return None\n    \n    # Calculate area using Heron's formula\n    s = (a + b + c) / 2  # semi-perimeter\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    \n    return round(area, 2)", "index": 0, "passed_case": [0, 2, 3, 5, 7], "case_status": ["6.0", "None", "8.18", "1.73", "None", "16.25", "None", "0.43", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/78_prompt2ap", "code_candidates": [{"code": "def hex_key(num):\n    prime_hex_digits = {'2', '3', '5', '7', 'B', 'D', 'b', 'd'}\n    count = 0\n    for char in num:\n        if char in prime_hex_digits:\n            count += 1\n    return count", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["1", "2", "4", "2", "6", "12", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/79_prompt2ap", "code_candidates": [{"code": "def decimal_to_binary(decimal_num):\n    \"\"\"\n    Convert a decimal number to binary representation.\n    \n    Args:\n        decimal_num (int): The decimal number to convert\n        \n    Returns:\n        str: Binary representation prefixed and suffixed with 'db'\n    \"\"\"\n    if decimal_num == 0:\n        return \"db0db\"\n    \n    binary_str = \"\"\n    while decimal_num > 0:\n        binary_str = str(decimal_num % 2) + binary_str\n        decimal_num //= 2\n    \n    return f\"db{binary_str}db\"", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["db0db", "db100000db", "db1100111db", "db1111db"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/81_prompt2ap", "code_candidates": [{"code": "def gpa_to_letter_grades(gpa_list):\n    if not gpa_list:\n        return []\n    \n    # Define the grading scale\n    grading_scale = [\n        (4.0, 'A'),\n        (3.7, 'A-'),\n        (3.3, 'B+'),\n        (3.0, 'B'),\n        (2.7, 'B-'),\n        (2.3, 'C+'),\n        (2.0, 'C'),\n        (1.7, 'C-'),\n        (1.3, 'D+'),\n        (1.0, 'D'),\n        (0.0, 'F')\n    ]\n    \n    def get_letter_grade(gpa):\n        if gpa < 0.0 or gpa > 4.0:\n            raise ValueError(\"GPA must be between 0.0 and 4.0\")\n        \n        # Find the closest grade\n        best_grade = None\n        min_diff = float('inf')\n        \n        for threshold, grade in grading_scale:\n            diff = abs(gpa - threshold)\n            if diff < min_diff:\n                min_diff = diff\n                best_grade = grade\n            elif diff == min_diff:\n                # If same distance, choose the higher grade\n                # Find the index of current and best grade in scale\n                current_idx = next(i for i, (t, g) in enumerate(grading_scale) if t == threshold)\n                best_idx = next(i for i, (t, g) in enumerate(grading_scale) if g == best_grade)\n                if current_idx < best_idx:\n                    best_grade = grade\n        \n        return best_grade\n    \n    return [get_letter_grade(gpa) for gpa in gpa_list]", "index": 0, "passed_case": [1], "case_status": ["['A', 'B', 'C-', 'C', 'A-']", "['D+']", "['D']", "['F']", "['D', 'F', 'C-', 'B-', 'B+']", "['F', 'D']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/88_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef sort_array(arr: List[int]) -> List[int]:\n    if not arr:\n        return []\n    \n    # Create a copy to avoid modifying the original array\n    result = arr.copy()\n    \n    # Calculate sum of first and last elements\n    sum_first_last = arr[0] + arr[-1]\n    \n    # Sort based on whether sum is odd or even\n    if sum_first_last % 2 == 1:  # odd\n        result.sort()  # ascending order\n    else:  # even\n        result.sort(reverse=True)  # descending order\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["[]", "[5]", "[0, 1, 2, 3, 4, 5]", "[6, 5, 4, 3, 2, 1, 0]", "[1, 2]", "[0, 11, 15, 32, 42, 87]", "[23, 21, 14, 11]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/92_prompt2ap", "code_candidates": [{"code": "def has_integer(a: float, b: float, c: float) -> bool:\n    \"\"\"\n    Takes 3 numbers and returns true if one of the numbers is an integer.\n    Returns false if none of the numbers is an integer.\n    \n    Args:\n        a, b, c: Three numbers (int or float)\n        \n    Returns:\n        bool: True if at least one number is an integer, False otherwise\n    \"\"\"\n    return any(num.is_integer() for num in [a, b, c])", "index": 0, "passed_case": [0, 4, 5, 6, 7, 8], "case_status": ["True", "True", "True", "True", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/95_prompt2ap", "code_candidates": [{"code": "def check_case_pattern(d: dict) -> bool:\n    if not d:\n        return True\n    \n    # Check if all keys are strings\n    if not all(isinstance(key, str) for key in d.keys()):\n        return False\n    \n    # Get all string keys\n    string_keys = [key for key in d.keys() if isinstance(key, str)]\n    \n    # Check if all keys follow the same case pattern\n    all_lowercase = all(key.islower() for key in string_keys)\n    all_uppercase = all(key.isupper() for key in string_keys)\n    \n    return all_lowercase or all_uppercase", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "False", "False", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/96_prompt2ap", "code_candidates": [{"code": "def first_n_primes(n: int) -> list[int]:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    \n    if n == 0:\n        return []\n    \n    primes = []\n    candidate = 2\n    \n    while len(primes) < n:\n        is_prime = True\n        for i in range(2, int(candidate**0.5) + 1):\n            if candidate % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(candidate)\n        candidate += 1\n    \n    return primes", "index": 0, "passed_case": [4], "case_status": ["[2, 3, 5, 7, 11]", "[2, 3, 5, 7, 11, 13]", "[2, 3, 5, 7, 11, 13, 17]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]", "[]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79]", "[2]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211]", "[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/97_prompt2ap", "code_candidates": [{"code": "def multiply(a, b):\n    \"\"\"Complete the function that takes two integers and returns the product of their values.\"\"\"\n    return a * b", "index": 0, "passed_case": [6, 7], "case_status": ["60976", "532", "3739020", "-210", "5092", "459", "0", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/99_prompt2ap", "code_candidates": [{"code": "def closest_integer(value):\n    \"\"\"\n    Return the integer closest to the input value.\n    If the value is exactly halfway between two integers, \n    return the integer away from zero (round half away from zero).\n    \"\"\"\n    # Convert to float if it's a string\n    if isinstance(value, str):\n        value = float(value)\n    \n    # Handle the case where value is exactly halfway\n    # We need to round away from zero in this case\n    if value >= 0:\n        return int(value + 0.5)\n    else:\n        return int(value - 0.5)", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["10", "15", "-16", "15", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/100_prompt2ap", "code_candidates": [{"code": "def create_stone_pile(n: int) -> list:\n    \"\"\"\n    Create a pile with n levels of stones where the first level has n stones,\n    and each subsequent level follows a specific progression rule.\n    \n    Args:\n        n: A positive integer representing the number of levels and stones in the first level\n        \n    Returns:\n        A list containing the number of stones in each level of the pile\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    pile = []\n    current_stones = n\n    \n    for _ in range(n):\n        pile.append(current_stones)\n        current_stones += 2\n    \n    return pile", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["[3, 5, 7]", "[4, 6, 8, 10]", "[5, 7, 9, 11, 13]", "[6, 8, 10, 12, 14, 16]", "[8, 10, 12, 14, 16, 18, 20, 22]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/101_prompt2ap", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef split_words(text: str) -> List[str]:\n    if not text:\n        return []\n    \n    # Split by comma or space using regex\n    parts = re.split(r'[,\\s]+', text)\n    \n    # Filter out empty strings\n    return [part for part in parts if part]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["['Hi', 'my', 'name', 'is', 'John']", "['One', 'two', 'three', 'four', 'five', 'six']", "['Hi', 'my', 'name']", "['One', 'two', 'three', 'four', 'five', 'six']", "[]", "['ahmed', 'gamal']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/102_prompt2ap", "code_candidates": [{"code": "def largest_odd_or_even(x: int, y: int) -> int:\n    \"\"\"\n    Returns the largest odd or even integer from two positive numbers x and y.\n    If both numbers are odd or both are even, return the larger of the two.\n    If one is odd and one is even, return the larger odd number if it exists,\n    otherwise return the larger even number.\n    \n    Args:\n        x: First positive integer\n        y: Second positive integer\n        \n    Returns:\n        The largest odd or even integer according to the rules\n    \"\"\"\n    # Check if both numbers have the same parity (both odd or both even)\n    if (x % 2) == (y % 2):\n        # Return the larger of the two numbers\n        return max(x, y)\n    else:\n        # One is odd, one is even\n        # Return the larger odd number if it exists, otherwise return the larger even number\n        if x % 2 == 1:  # x is odd\n            return x\n        else:  # y is odd\n            return y", "index": 0, "passed_case": [7], "case_status": ["15", "13", "33", "5233", "29", "27", "7", "546"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/103_prompt2ap", "code_candidates": [{"code": "def rounded_avg(n, m):\n    if n > m:\n        return None\n    \n    total = sum(range(n, m + 1))\n    count = m - n + 1\n    average = total / count\n    \n    # Banker's rounding (round half to even)\n    return round(average)", "index": 0, "passed_case": [], "case_status": ["3", "10", "970", "996", "706", "366", "429", "626", "215", "None", "None", "5"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/105_prompt2ap", "code_candidates": [{"code": "def process_digits(arr):\n    # Filter integers between 1 and 9 inclusive\n    filtered = [x for x in arr if 1 <= x <= 9]\n    \n    # Sort in ascending order\n    filtered.sort()\n    \n    # Reverse the array\n    filtered.reverse()\n    \n    # Map digits to their English word names\n    digit_to_word = {\n        1: 'one',\n        2: 'two',\n        3: 'three',\n        4: 'four',\n        5: 'five',\n        6: 'six',\n        7: 'seven',\n        8: 'eight',\n        9: 'nine'\n    }\n    \n    return [digit_to_word[x] for x in filtered]", "index": 0, "passed_case": [1], "case_status": ["['eight', 'five', 'four', 'three', 'two', 'two', 'one', 'one']", "[]", "['one']", "['three', 'two', 'one']", "['nine', 'eight', 'four']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/106_prompt2ap", "code_candidates": [{"code": "def generate_list(n):\n    \"\"\"\n    Generate a list of size n where each element at index i is:\n    - factorial of i if i is odd\n    - square of i if i is even\n    \n    Args:\n        n (int): Size of the list to generate\n        \n    Returns:\n        list: List with calculated values based on index parity\n    \"\"\"\n    def factorial(num):\n        if num <= 1:\n            return 1\n        result = 1\n        for i in range(2, num + 1):\n            result *= i\n        return result\n    \n    result = []\n    for i in range(n):\n        if i % 2 == 1:  # odd index\n            result.append(factorial(i))\n        else:  # even index\n            result.append(i ** 2)\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[0, 1, 4, 6, 16]", "[0, 1, 4, 6, 16, 120, 36]", "[0]", "[0, 1, 4]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/112_prompt2ap", "code_candidates": [{"code": "def reverse_delete(s, c):\n    # Delete all characters in s that appear in c\n    filtered = ''.join(char for char in s if char not in c)\n    \n    # Check if the resulting string is a palindrome\n    return filtered == filtered[::-1]", "index": 0, "passed_case": [], "case_status": ["False", "False", "True", "False", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/114_prompt2ap", "code_candidates": [{"code": "def minSubArraySum(nums):\n    \"\"\"\n    Find the minimum sum of any contiguous subarray.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        int: Minimum sum of any contiguous subarray\n    \"\"\"\n    if not nums:\n        return 0\n    \n    min_sum = nums[0]\n    current_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        # Either extend the existing subarray or start a new one\n        current_sum = min(nums[i], current_sum + nums[i])\n        # Update the minimum sum found so far\n        min_sum = min(min_sum, current_sum)\n    \n    return min_sum", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["1", "-6", "-14", "-9999999999999999", "0", "-6", "-6", "3", "-33", "-10", "7", "-1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/115_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef min_bucket_fills(wells: List[List[int]], capacity: int) -> int:\n    \"\"\"\n    Calculate the minimum number of bucket fills needed to empty all wells.\n    \n    Args:\n        wells: A list of lists where each inner list represents a well with 0s and 1s\n               (1s represent water units)\n        capacity: The capacity of each bucket (number of water units it can hold)\n    \n    Returns:\n        The minimum number of bucket fills required to remove all water units\n    \"\"\"\n    if not wells or capacity <= 0:\n        return 0\n    \n    total_fills = 0\n    \n    for well in wells:\n        # Count water units in this well\n        water_units = sum(well)\n        \n        # If there are water units, calculate fills needed\n        if water_units > 0:\n            # Calculate bucket fills needed for this well\n            fills_for_well = (water_units + capacity - 1) // capacity\n            total_fills += fills_for_well\n    \n    return total_fills", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["6", "5", "0", "4", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/117_prompt2ap", "code_candidates": [{"code": "def select_words(s, n):\n    if not s:\n        return []\n    \n    words = s.split()\n    result = []\n    \n    for word in words:\n        # Remove punctuation from the word for length calculation\n        clean_word = ''.join(char for char in word if char.isalnum())\n        if len(clean_word) == n:\n            result.append(word)\n    \n    return result", "index": 0, "passed_case": [2, 5], "case_status": ["['Mary', 'lamb']", "['had']", "[]", "[]", "['sam']", "[]", "['a', 'b', 'c', 'd', 'e', 'f']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/118_prompt2ap", "code_candidates": [{"code": "def get_closest_vowel(word):\n    if len(word) < 3:\n        return \"\"\n    \n    vowels = set('aeiouAEIOU')\n    \n    # Iterate from right to left, looking for vowels between consonants\n    for i in range(len(word) - 2, 0, -1):\n        # Check if current character is a vowel\n        if word[i] in vowels:\n            # Check if both adjacent characters are consonants\n            if word[i-1] not in vowels and word[i+1] not in vowels:\n                return word[i]\n    \n    return \"\"", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], "case_status": ["u", "u", "", "", "", "a", "o", "", "", "", "i", "", "o"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/119_prompt2ap", "code_candidates": [{"code": "def is_balanced_concatenation(strings: list[str]) -> bool:\n    def is_balanced(s: str) -> bool:\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    s1, s2 = strings\n    return is_balanced(s1 + s2) or is_balanced(s2 + s1)", "index": 0, "passed_case": [], "case_status": ["True", "False", "False", "True", "True", "False", "True", "False", "False", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/120_prompt2ap", "code_candidates": [{"code": "from typing import List\n\ndef k_largest_elements(arr: List[int], k: int) -> List[int]:\n    if not arr or k <= 0:\n        return []\n    \n    # Sort the array in descending order and take the first k elements\n    sorted_desc = sorted(arr, reverse=True)\n    k_largest = sorted_desc[:k]\n    \n    # Return the k largest elements in ascending order\n    return sorted(k_largest)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "case_status": ["[-4, -3, 5]", "[4, 4]", "[2]", "[2, 20, 123]", "[0, 1, 2, 20]", "[-13, -8, 0, 0, 3, 5, 15]", "[3, 5]", "[5]", "[-4, 4]", "[-10, 10]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/121_prompt2ap", "code_candidates": [{"code": "def sum_even_non_negative(numbers: list[int]) -> int:\n    \"\"\"\n    Return the sum of all even elements that are greater than or equal to 0.\n    \n    Args:\n        numbers: A non-empty list of integers\n        \n    Returns:\n        The sum of all even elements >= 0\n    \"\"\"\n    return sum(num for num in numbers if num >= 0 and num % 2 == 0)", "index": 0, "passed_case": [], "case_status": ["0", "54", "0", "14", "62", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/122_prompt2ap", "code_candidates": [{"code": "def sum_two_digit_elements(arr, k):\n    \"\"\"\n    Return the sum of elements with at most two digits (0-99 inclusive) \n    from the array, considering only the first k qualifying elements.\n    \n    Args:\n        arr: List of integers\n        k: Number of qualifying elements to consider\n        \n    Returns:\n        Sum of qualifying elements, or 0 if none exist\n    \"\"\"\n    qualifying_elements = []\n    \n    for num in arr:\n        if 0 <= num <= 99:\n            qualifying_elements.append(num)\n            if len(qualifying_elements) == k:\n                break\n    \n    return sum(qualifying_elements)", "index": 0, "passed_case": [2, 4], "case_status": ["99", "8", "125", "35", "1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/125_prompt2ap", "code_candidates": [{"code": "def split_words(txt):\n    if not txt:\n        return []\n    \n    # Check if string contains any alphabetic characters\n    has_alpha = any(c.isalpha() for c in txt)\n    \n    if has_alpha:\n        # Split on alphabetic characters\n        result = []\n        current_word = \"\"\n        for c in txt:\n            if c.isalpha():\n                if current_word:\n                    result.append(current_word)\n                    current_word = \"\"\n            else:\n                current_word += c\n        if current_word:\n            result.append(current_word)\n        return result\n    else:\n        # No alphabetic characters, check for commas\n        if ',' in txt:\n            return txt.split(',')\n        else:\n            # No commas, return count of alphabetic characters\n            return sum(1 for c in txt if c.isalpha())", "index": 0, "passed_case": [], "case_status": ["[' ', '!']", "[',', '!']", "[' ', ',!']", "[',', ',', ' !']", "[]", "[]", "[]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/126_prompt2ap", "code_candidates": [{"code": "def is_sorted(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted in ascending order.\n    Duplicates are allowed and considered sorted.\n    Return True if the list is sorted in ascending order, False otherwise.\n    An empty list is considered sorted.\n    '''\n    if not lst:\n        return True\n    \n    for i in range(1, len(lst)):\n        if lst[i] < lst[i-1]:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 12], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True", "False", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/129_prompt2ap", "code_candidates": [{"code": "def find_path_k_cells(grid, k):\n    if not grid or not grid[0] or k <= 0:\n        return []\n    \n    rows, cols = len(grid), len(grid[0])\n    \n    # Directions for adjacent cells (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    def dfs(row, col, path, visited):\n        if len(path) == k:\n            return path[:]\n        \n        for dr, dc in directions:\n            new_row, new_col = row + dr, col + dc\n            \n            # Check if the new position is valid\n            if 0 <= new_row < rows and 0 <= new_col < cols:\n                # Add the new cell to path\n                path.append(grid[new_row][new_col])\n                result = dfs(new_row, new_col, path, visited)\n                if result:\n                    return result\n                # Backtrack\n                path.pop()\n        \n        return None\n    \n    # Try starting from each cell\n    for i in range(rows):\n        for j in range(cols):\n            path = [grid[i][j]]\n            result = dfs(i, j, path, set())\n            if result:\n                return result\n    \n    return []", "index": 0, "passed_case": [10], "case_status": ["[1, 4, 1]", "[5]", "[1, 5, 1, 5]", "[6, 5, 6, 5, 6, 5, 6]", "[8, 6, 8, 6, 8]", "[11, 5, 11, 5, 11, 5, 11, 5, 11]", "[12, 9, 12, 9, 12, 9, 12, 9, 12, 9, 12, 9]", "[2, 3, 2, 3, 2, 3, 2, 3]", "[6, 3, 6, 3, 6, 3, 6, 3]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]", "[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/130_prompt2ap", "code_candidates": [{"code": "def tri(n):\n    if n == 1:\n        return 3\n    else:\n        return tri(n-1) + n", "index": 0, "passed_case": [], "case_status": ["8", "12", "17", "23", "30", "38", "47", "212", "execution error: 1", "3"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/131_prompt2ap", "code_candidates": [{"code": "def digits(n):\n    \"\"\"Given a positive integer n, return the sum of its digits.\"\"\"\n    return sum(int(digit) for digit in str(n))", "index": 0, "passed_case": [0], "case_status": ["5", "9", "10", "35", "35", "20"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/134_prompt2ap", "code_candidates": [{"code": "def is_last_char_letter(s: str) -> bool:\n    if not s:\n        return False\n    \n    # Remove trailing spaces\n    s = s.rstrip()\n    \n    # Check if string is empty after removing trailing spaces\n    if not s:\n        return False\n    \n    # Check if last character is a letter\n    return s[-1].isalpha()", "index": 0, "passed_case": [1, 3, 5, 6], "case_status": ["True", "True", "True", "True", "True", "False", "False", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/135_prompt2ap", "code_candidates": [{"code": "def filter_decreasing_sequence(numbers):\n    \"\"\"\n    Takes a list of numbers and returns a new list containing only the elements \n    that are not greater than or equal to the previous element in the sequence.\n    The first element is always included.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        List of numbers filtered according to the rule\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = [numbers[0]]\n    \n    for i in range(1, len(numbers)):\n        if numbers[i] < result[-1]:\n            result.append(numbers[i])\n    \n    return result", "index": 0, "passed_case": [], "case_status": ["[1]", "[1]", "[1]", "[4, 3]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/136_prompt2ap", "code_candidates": [{"code": "def find_largest_and_smallest_negative(numbers):\n    \"\"\"\n    Returns a tuple (a, b) where 'a' is the largest negative integer \n    and 'b' is the smallest negative integer from the list.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        tuple: (largest_negative, smallest_negative)\n        \n    Raises:\n        ValueError: If list is empty or contains no negative integers\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"List is empty\")\n    \n    negative_numbers = [num for num in numbers if num < 0]\n    \n    if not negative_numbers:\n        raise ValueError(\"List contains no negative integers\")\n    \n    return (max(negative_numbers), min(negative_numbers))", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "(-2, -2)", "(-7, -7)", "(-9, -9)", "execution error: 1", "execution error: 1", "(-1, -6)", "(-1, -6)", "(-3, -6)", "(-3, -100)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/140_prompt2ap", "code_candidates": [{"code": "import re\n\ndef fix_spaces(text):\n    if not text:\n        return text\n    \n    # Replace 3 or more consecutive spaces with a single dash\n    text = re.sub(r' {3,}', '-', text)\n    \n    # Replace remaining single spaces with underscores\n    text = text.replace(' ', '_')\n    \n    return text", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["Example", "Mudasir_Hanif_", "Yellow_Yellow__Dirty__Fellow", "Exa-mple", "-Exa_1_2_2_mple"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/147_prompt2ap", "code_candidates": [{"code": "def get_max_triples(n):\n    a = []\n    for i in range(1, n + 1):\n        if i % 2 == 1:  # i is odd\n            a.append(i * i + i - 1)\n        else:  # i is even\n            a.append(i * i - i + 1)\n    \n    # Find all possible triples (i, j, k) where i < j < k\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                current_sum = a[i] + a[j] + a[k]\n                max_sum = max(max_sum, current_sum)\n    \n    return max_sum", "index": 0, "passed_case": [], "case_status": ["53", "73", "237", "29307"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/151_prompt2ap", "code_candidates": [{"code": "def sum_of_squares(numbers):\n    \"\"\"\n    Return the sum of squares of numbers in the list that are even or positive.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        int: Sum of squares of even or positive numbers\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    total = 0\n    for num in numbers:\n        if num % 2 == 0 or num > 0:\n            total += num ** 2\n    \n    return total", "index": 0, "passed_case": [0, 6], "case_status": ["0", "41", "0.14", "1400", "68", "34.04", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/160_prompt2ap", "code_candidates": [{"code": "def element_wise_add(list1, list2):\n    \"\"\"\n    Performs element-wise addition on two lists of numbers.\n    \n    Args:\n        list1: First list of numbers\n        list2: Second list of numbers\n        \n    Returns:\n        A new list where each element is the sum of corresponding elements from the input lists\n        \n    Raises:\n        ValueError: If the lists have different lengths\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError('Lists must have the same length')\n    \n    return [a + b for a, b in zip(list1, list2)]", "index": 0, "passed_case": [], "case_status": ["execution error: 1", "execution error: 1", "execution error: 1"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/163_prompt2ap", "code_candidates": [{"code": "def odd_digits_between(a: int, b: int) -> list:\n    if a > b:\n        return []\n    \n    odd_digits = set()\n    \n    for num in range(a, b + 1):\n        for digit_char in str(num):\n            digit = int(digit_char)\n            if digit % 2 == 1:\n                odd_digits.add(digit)\n    \n    return sorted(list(odd_digits))", "index": 0, "passed_case": [], "case_status": ["[1, 3, 5, 7, 9]", "[]", "[]", "[1, 3, 5, 7, 9]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2ap"}
{"name": "HumanEval/4_prompt2cp", "code_candidates": [{"code": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    if len(numbers) <= 1:\n        return 0.0\n    \n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)", "index": 0, "passed_case": [0, 1, 2], "case_status": ["True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/30_prompt2cp", "code_candidates": [{"code": "def get_negative(numbers: list) -> list:\n    return [num for num in numbers if num < 0]", "index": 0, "passed_case": [3], "case_status": ["[-1, -2]", "[-5, -10]", "[-1, -2]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/41_prompt2cp", "code_candidates": [{"code": "def is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    \n    return True", "index": 0, "passed_case": [], "case_status": ["True", "True", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/50_prompt2cp", "code_candidates": [{"code": "def encode_shift(s: str) -> str:\n    \"\"\"Encode a string by shifting each alphabetic character by 5 positions forward in the alphabet.\"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                # Shift lowercase letters\n                shifted = chr((ord(char) - ord('a') + 5) % 26 + ord('a'))\n            else:\n                # Shift uppercase letters\n                shifted = chr((ord(char) - ord('A') + 5) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Preserve non-alphabetic characters\n            result.append(char)\n    return ''.join(result)\n\ndef decode_shift(s: str) -> str:\n    \"\"\"Decode a string by shifting each alphabetic character back by 5 positions in the alphabet.\"\"\"\n    result = []\n    for char in s:\n        if char.isalpha():\n            if char.islower():\n                # Shift lowercase letters back by 5\n                shifted = chr((ord(char) - ord('a') - 5) % 26 + ord('a'))\n            else:\n                # Shift uppercase letters back by 5\n                shifted = chr((ord(char) - ord('A') - 5) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            # Preserve non-alphabetic characters\n            result.append(char)\n    return ''.join(result)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99], "case_status": ["daxihhexdvxrcsnbacgh", "targwuwrnhosizayzf", "kiegykdcmdlltizb", "rdmcrjutlsgwcbvhy", "chdmioulfllgvi", "uctufrxhfomiuwrhvkyy", "hbzkmicgsw", "gupmuoeiehxrrix", "nsmlheqpcybdeufzvnt", "mmtoqiravxd", "ryiyukdjnfoaxxiqyfqd", "juqtgelyfryqatkpadlz", "hbhsccxpcyryee", "prfiqtngryxwgwjmvulo", "odhhckasrhshacwubh", "bkcqhivpgre", "sphzpzngddvnlnnoxbv", "udbmxkzdhggroenfiohc", "zrdburacyhfnppgmb", "mamizzojnwxz", "vwpegjgbsxrbxkbbsp", "qfbqcfctcvhmdshstb", "cnvssqkigvwkhimevuj", "kycaotsdcrgqielch", "jforwjtzuqavrjv", "eiddxreijtg", "gvuiqpibcunibak", "uifxorwnradc", "rblsrenebjlz", "lgvhvdlyrn", "xehfzzfnafxkznzvxzh", "fzwdmbphgoljzh", "avgmkicyiluqm", "rkadifsibdtnlxzkntqd", "sgibwnaqzrvxxxvg", "ncvktkvdxjqjvnk", "wjregnvmvxftsjmr", "jjgnzstuko", "ovgqpzzxfvcjqvutk", "yhvjhzgeabh", "tyconusgwwmpmheuw", "yydynhfzwq", "brhdoezovqrtkyotx", "nrofxpoiyhuiyyqpuh", "ocwjhikkrceehm", "wgcnnkronbgn", "yswaysmpaljymnrx", "zthphinpamkvvzmxfo", "tramssvacune", "fbimkgokkymiynicp", "xrblhucyub", "hgatehepvd", "gowiylfttxwdyfjdsaj", "vmmwgcswuhdwyjvtzdz", "zblrnvlcqukanpdnluo", "nfxquitzrypo", "xsikhciohyostvmk", "pkfpglziki", "wiraqgchxnpryhwpuwp", "zacjhmwhjvslprqln", "klwoijihdxgkdxrywf", "gxpixsyqtjdgj", "lfjawreibbrjw", "uypdasjppokf", "ipdcmpcsuv", "eezsjchdry", "ttzthyqmoojsnjst", "txdygugivc", "hfrcfanowtpj", "hjwjwocvhi", "svzgndrhueiecbfzjtxs", "odowjwmiqrpoct", "nxktiachvs", "ayvisbyyfpquoifsnup", "plnkkvdfknw", "jvmyrbockikdymqav", "onbgqltypuoybgirej", "wpdautzhwfjrarnch", "oduepwjqwin", "phoremgtqxeciyznk", "iajxjssvpeorplkryr", "okgwhsmhynbkxpwz", "mvzuepbeqskdodqo", "xenuecpzik", "wmuckvrmkuwyprbtchu", "jhxcndyuwdofwjabkzbj", "lnehqnsvzfffctm", "vhpsehouioivazojvrf", "olsjunwiojg", "pdhmslsjwjavmias", "yxbtxpjyzhtzlhugtivy", "veuduubjzobslxecjkxn", "gezrlqqifipz", "xkzdoceyhvxvmz", "lczmairdolvxvismul", "vhpatrkthuc", "owjundebbjpddhremolv", "nsxxenudptnibwlgoo", "ldvlrulbmigdo", "vguutabzkhe"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/54_prompt2cp", "code_candidates": [{"code": "def same_chars(s0: str, s1: str):\n    return set(s0) == set(s1)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6], "case_status": ["True", "True", "True", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/55_prompt2cp", "code_candidates": [{"code": "def fib(n: int):\n    \"\"\"\n    Compute the nth Fibonacci number.\n    The Fibonacci sequence starts with fib(1) = 1 and fib(2) = 1, where each subsequent number\n    is the sum of the two preceding ones.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(3)\n    2\n    >>> fib(4)\n    3\n    >>> fib(5)\n    5\n    >>> fib(6)\n    8\n    >>> fib(7)\n    13\n    >>> fib(8)\n    21\n    >>> fib(9)\n    34\n    >>> fib(10)\n    55\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    if n == 1 or n == 2:\n        return 1\n    \n    a, b = 1, 1\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b", "index": 0, "passed_case": [0, 1, 2, 3, 4], "case_status": ["55", "1", "21", "89", "144"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/56_prompt2cp", "code_candidates": [{"code": "def is_matched(s: str) -> bool:\n    stack = []\n    brackets = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}':\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    \n    return len(stack) == 0", "index": 0, "passed_case": [0, 1, 2, 3], "case_status": ["True", "True", "True", "True", "True", "True", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/57_prompt2cp", "code_candidates": [{"code": "def is_monotonic(nums):\n    \"\"\"\n    Returns True if list elements are monotonic (non-decreasing or non-increasing), False otherwise.\n    \n    Args:\n        nums: List of numbers\n        \n    Returns:\n        bool: True if monotonic, False otherwise\n    \"\"\"\n    if len(nums) <= 1:\n        return True\n    \n    is_increasing = True\n    is_decreasing = True\n    \n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            is_increasing = False\n        if nums[i] > nums[i-1]:\n            is_decreasing = False\n        \n        # Early termination if neither monotonic property holds\n        if not is_increasing and not is_decreasing:\n            return False\n    \n    return is_increasing or is_decreasing", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "True", "False", "True", "True", "False", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/58_prompt2cp", "code_candidates": [{"code": "def common(l1: list, l2: list):\n    \"\"\"Return common.\"\"\"\n    set1 = set(l1)\n    set2 = set(l2)\n    common_elements = list(set1 & set2)\n    return sorted(common_elements, key=lambda x: l1.index(x) + l2.index(x))", "index": 0, "passed_case": [0, 3], "case_status": ["[1, 5, 653]", "[3, 2]", "[3, 4, 2]", "[]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/61_prompt2cp", "code_candidates": [{"code": "def correct_bracketing(brackets: str) -> bool:\n    \"\"\"\n    Validates if a string of parentheses is properly balanced and matched.\n    \n    Args:\n        brackets: A string containing parentheses to validate\n        \n    Returns:\n        True if brackets are properly balanced, False otherwise\n    \"\"\"\n    count = 0\n    for bracket in brackets:\n        if bracket == '(':\n            count += 1\n        elif bracket == ')':\n            count -= 1\n            if count < 0:\n                return False\n    return count == 0", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "False", "False", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/63_prompt2cp", "code_candidates": [{"code": "def fibfib(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    \n    # Initialize the first three values\n    a, b, c = 0, 1, 1\n    \n    # Compute iteratively from 3 to n\n    for _ in range(3, n + 1):\n        next_val = a + b + c\n        a, b, c = b, c, next_val\n    \n    return c", "index": 0, "passed_case": [0], "case_status": ["1", "1", "7", "44", "149", "504", "1705"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/70_prompt2cp", "code_candidates": [{"code": "def remove_duplicates(numbers: list[int]) -> list[int]:\n    seen = set()\n    result = []\n    \n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    \n    return result", "index": 0, "passed_case": [5, 8], "case_status": ["[1, 2, 3, 4]", "[5, 6, 7, 8, 9]", "[1, 2, 3, 4, 5]", "[5, 6, 7, 8, 9, 1]", "[5]", "[]", "[1, 2, 3, 4, 5, 6, 7, 8]", "[0, 2, 5, -5]", "[111111]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/71_prompt2cp", "code_candidates": [{"code": "def triangle_area(a, b, c):\n    # Check if all sides are positive\n    if a <= 0 or b <= 0 or c <= 0:\n        return None\n    \n    # Check triangle inequality\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return None\n    \n    # Calculate area using Heron's formula\n    s = (a + b + c) / 2  # semi-perimeter\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    \n    return round(area, 2)", "index": 0, "passed_case": [0, 2, 3, 5, 7], "case_status": ["6.0", "None", "8.18", "1.73", "None", "16.25", "None", "0.43", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/72_prompt2cp", "code_candidates": [{"code": "def will_fly(q, w):\n    \"\"\"\n    Determine if object q will fly based on weight limit w.\n    \n    An object will fly if and only if:\n    1. The total weight of all elements in q is less than or equal to w\n    2. The list q is palindromic (reads the same forwards and backwards)\n    \n    Args:\n        q: List of weights\n        w: Weight limit\n        \n    Returns:\n        bool: True if object will fly, False otherwise\n    \"\"\"\n    # Check if the list is empty\n    if not q:\n        return True\n    \n    # Check if total weight exceeds limit\n    if sum(q) > w:\n        return False\n    \n    # Check if list is palindromic\n    return q == q[::-1]", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["True", "False", "True", "False", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/75_prompt2cp", "code_candidates": [{"code": "def is_composite(n):\n    if n < 4:\n        return False\n    \n    # Check if n is divisible by any number from 2 to sqrt(n)\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += 1\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 4, 5, 9], "case_status": ["False", "True", "True", "True", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/77_prompt2cp", "code_candidates": [{"code": "def iscube(a):\n    if a == 0:\n        return True\n    \n    # Handle positive numbers\n    if a > 0:\n        cube_root = round(a ** (1/3))\n        return cube_root ** 3 == a\n    \n    # Handle negative numbers\n    else:\n        cube_root = round((-a) ** (1/3))\n        return (-cube_root) ** 3 == a", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["True", "False", "True", "True", "False", "True", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/78_prompt2cp", "code_candidates": [{"code": "def count_prime_hex_digits(hex_string: str) -> int:\n    \"\"\"\n    Count the number of prime digits in a hexadecimal string.\n    \n    Prime digits in hexadecimal are: 2, 3, 5, 7\n    (Note: In hexadecimal, these are the same as in decimal)\n    \n    Args:\n        hex_string: A string containing valid hexadecimal characters (0-9, a-f, A-F)\n        \n    Returns:\n        The count of prime digits (2, 3, 5, 7) in the input string\n    \"\"\"\n    prime_digits = {'2', '3', '5', '7', '2', '3', '5', '7'}  # 2, 3, 5, 7 in both cases\n    count = 0\n    \n    for char in hex_string:\n        if char.lower() in prime_digits:\n            count += 1\n            \n    return count", "index": 0, "passed_case": [1, 3, 6], "case_status": ["0", "2", "2", "2", "4", "8", "0"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/80_prompt2cp", "code_candidates": [{"code": "def is_happy(s: str) -> bool:\n    # Check if string has at least 3 characters\n    if len(s) < 3:\n        return False\n    \n    # Check every group of 3 consecutive characters\n    for i in range(len(s) - 2):\n        group = s[i:i+3]\n        # Check if group has at least 2 different characters\n        if len(set(group)) < 2:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 4, 6], "case_status": ["False", "False", "True", "True", "True", "True", "True", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/82_prompt2cp", "code_candidates": [{"code": "def prime_length(s: str) -> bool:\n    length = len(s)\n    \n    # Handle edge cases: 0 and 1 are not prime numbers\n    if length < 2:\n        return False\n    \n    # Check if length is a prime number\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    \n    return True", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], "case_status": ["True", "True", "True", "False", "True", "True", "True", "True", "False", "True", "True", "False", "False", "True", "False", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/84_prompt2cp", "code_candidates": [{"code": "def digit_sum(N: int) -> int:\n    \"\"\"\n    Calculate the sum of digits of a positive integer N.\n    \n    Args:\n        N: A positive integer\n        \n    Returns:\n        The sum of all digits in N\n    \"\"\"\n    total = 0\n    while N > 0:\n        total += N % 10\n        N //= 10\n    return total", "index": 0, "passed_case": [0], "case_status": ["1", "6", "12", "9", "18"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/85_prompt2cp", "code_candidates": [{"code": "def sum_even_elements(lst):\n    \"\"\"\n    Sum all even elements that are present in the list.\n    \n    Args:\n        lst: A non-empty list of integers\n        \n    Returns:\n        int: The sum of all even elements in the list\n    \"\"\"\n    return sum(x for x in lst if x % 2 == 0)", "index": 0, "passed_case": [], "case_status": ["92", "134", "10", "22"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/94_prompt2cp", "code_candidates": [{"code": "def sum_of_primes(numbers):\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n    \n    return sum(num for num in numbers if num > 0 and is_prime(num))", "index": 0, "passed_case": [4], "case_status": ["226", "4615", "5408", "164", "3", "9", "8191", "8325", "224"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/134_prompt2cp", "code_candidates": [{"code": "def is_last_char_letter(s: str) -> bool:\n    \"\"\"\n    Returns True if the last character of a given string is a letter, False otherwise.\n    Empty strings and strings ending with spaces return False.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        bool: True if last character is a letter, False otherwise\n    \"\"\"\n    if not s or s[-1] == ' ':\n        return False\n    return s[-1].isalpha()", "index": 0, "passed_case": [1, 3, 4, 5, 6, 7, 9], "case_status": ["True", "True", "True", "True", "False", "False", "False", "False", "True", "False"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/141_prompt2cp", "code_candidates": [{"code": "import re\nfrom typing import List\n\ndef validate_file_names(file_names: List[str]) -> List[str]:\n    \"\"\"\n    Validates file names based on specific criteria.\n    \n    Args:\n        file_names: List of file name strings to validate\n        \n    Returns:\n        List of 'Yes' or 'No' strings indicating validity of each file name\n    \"\"\"\n    result = []\n    valid_extensions = {'dll', 'exe', 'sys', 'drv'}\n    \n    for file_name in file_names:\n        # Check if file name starts with a digit\n        if not file_name[0].isdigit():\n            result.append('No')\n            continue\n            \n        # Check if file name contains only alphanumeric characters and dots\n        if not re.match(r'^[a-zA-Z0-9.]+$', file_name):\n            result.append('No')\n            continue\n            \n        # Check for double dots\n        if '..' in file_name:\n            result.append('No')\n            continue\n            \n        # Extract extension (everything after the last dot)\n        if '.' not in file_name:\n            result.append('No')\n            continue\n            \n        parts = file_name.split('.')\n        if len(parts) < 2:\n            result.append('No')\n            continue\n            \n        extension = parts[-1]\n        \n        # Check if extension is valid\n        if extension not in valid_extensions:\n            result.append('No')\n            continue\n            \n        # Check if there are multiple extensions (more than one dot)\n        # This is already handled by the split and checking for last part\n        \n        result.append('Yes')\n        \n    return result", "index": 0, "passed_case": [], "case_status": ["['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No', 'No']", "['No', 'No', 'No', 'No']", "['No', 'No']"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/142_prompt2cp", "code_candidates": [{"code": "def sum_of_squares(numbers: list[int]) -> int:\n    return sum(x ** 2 for x in numbers)", "index": 0, "passed_case": [2, 3, 5], "case_status": ["14", "98", "0", "9", "9", "0", "56", "12942", "2", "10064", "2602"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/143_prompt2cp", "code_candidates": [{"code": "def last_word(sentence: str) -> str:\n    if not sentence:\n        return \"\"\n    \n    # Split by spaces and filter out empty strings\n    words = [word for word in sentence.split(' ') if word]\n    \n    if not words:\n        return \"\"\n    \n    return words[-1]", "index": 0, "passed_case": [6], "case_status": ["test", "swimming", "here", "Hussein", "it", "here", "is"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/145_prompt2cp", "code_candidates": [{"code": "def order_by_points(nums):\n    def digit_sum(n):\n        return sum(int(digit) for digit in str(abs(n)))\n    \n    # Create list of (digit_sum, original_index, value) tuples\n    indexed_nums = [(digit_sum(num), i, num) for i, num in enumerate(nums)]\n    \n    # Sort by digit sum first, then by original index\n    indexed_nums.sort(key=lambda x: (x[0], x[1]))\n    \n    # Extract just the values in the new order\n    return [num for _, _, num in indexed_nums]", "index": 0, "passed_case": [1, 2, 4], "case_status": ["[1, -1, 11, -11, -12]", "[0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]", "[]", "[1, -11, 2, -3, -32, 43, 54, -98]", "[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]", "[0, -21, 4, 23, 6, 6, -76]"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/146_prompt2cp", "code_candidates": [{"code": "def filter_special(numbers):\n    \"\"\"\n    Selects the first number from the input array that is greater than 10.\n    If no such number exists, returns None.\n    \n    Args:\n        numbers: A list of integers\n        \n    Returns:\n        The first integer greater than 10, or None if no such integer exists\n    \"\"\"\n    for num in numbers:\n        if num > 10:\n            return num\n    return None", "index": 0, "passed_case": [], "case_status": ["None", "15", "33", "43", "71", "None", "None"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/150_prompt2cp", "code_candidates": [{"code": "def x_or_y(n, x, y):\n    return x if n % 2 == 0 else y", "index": 0, "passed_case": [1, 5, 6, 8, 9], "case_status": ["12", "5", "5212", "52", "12", "583", "129", "34", "0", "2"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/151_prompt2cp", "code_candidates": [{"code": "def sum_of_squares(numbers: list) -> int:\n    \"\"\"\n    Return the sum of squares of non-negative numbers in the list.\n    \n    Args:\n        numbers: A list of numbers\n        \n    Returns:\n        The sum of squares of all non-negative numbers\n    \"\"\"\n    return sum(num ** 2 for num in numbers if num >= 0)", "index": 0, "passed_case": [0, 3, 6], "case_status": ["0", "41", "0.14", "0", "64", "34.04", "166650"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/154_prompt2cp", "code_candidates": [{"code": "def is_cyclic_pattern(a: str, b: str) -> bool:\n    \"\"\"\n    Check if string 'b' is a cyclic pattern of string 'a'.\n    A cyclic pattern means 'b' is a rotation of some substring of 'a'.\n    \n    Args:\n        a: The original string\n        b: The string to check for being a cyclic pattern\n        \n    Returns:\n        True if 'b' can be obtained by rotating any substring of 'a', False otherwise\n    \"\"\"\n    # Handle edge cases\n    if not b:\n        return True\n    if not a:\n        return False\n    if len(b) > len(a):\n        return False\n    \n    # Check all possible substrings of 'a' with length equal to 'b'\n    for i in range(len(a) - len(b) + 1):\n        substring = a[i:i + len(b)]\n        # Check if 'b' is a rotation of 'substring'\n        # A string 'b' is a rotation of 'substring' if 'b' is a substring of 'substring + substring'\n        if b in (substring + substring):\n            return True\n    \n    return False", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5], "case_status": ["False", "True", "False", "True", "False", "True"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/155_prompt2cp", "code_candidates": [{"code": "def count_even_odd_digits(num: int) -> tuple[int, int]:\n    \"\"\"\n    Count even and odd digits in the absolute value of an integer.\n    \n    Args:\n        num: An integer\n        \n    Returns:\n        A tuple (even_count, odd_count) where even_count is the number of even digits\n        and odd_count is the number of odd digits in the absolute value of num\n    \"\"\"\n    # Handle the special case of 0\n    if num == 0:\n        return (1, 0)\n    \n    # Take absolute value to handle negative numbers\n    num = abs(num)\n    \n    even_count = 0\n    odd_count = 0\n    \n    # Count digits\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    \n    return (even_count, odd_count)", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7], "case_status": ["(0, 1)", "(1, 1)", "(2, 2)", "(3, 3)", "(3, 3)", "(1, 0)", "(2, 3)", "(1, 0)"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/156_prompt2cp", "code_candidates": [{"code": "def int_to_mini_roman(num: int) -> str:\n    if not isinstance(num, int) or num < 1 or num > 3999:\n        return \"\"\n    \n    # Define the mapping in descending order\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = ['m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i']\n    \n    result = \"\"\n    \n    for i in range(len(values)):\n        # Add the symbol as many times as the value fits into num\n        count = num // values[i]\n        if count > 0:\n            result += symbols[i] * count\n            num -= values[i] * count\n    \n    return result", "index": 0, "passed_case": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "case_status": ["xix", "clii", "ccli", "cdxxvi", "d", "i", "iv", "xliii", "xc", "xciv", "dxxxii", "cm", "cmxciv", "m"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/161_prompt2cp", "code_candidates": [{"code": "def solve(s):\n    \"\"\"\n    The function should return the resulted string.\n    Examples\n    solve(\"1234\") = \"1234\"\n    solve(\"ab\") = \"ab\"\n    solve(\"#a@C\") = \"#a@C\"\n    \"\"\"\n    return s", "index": 0, "passed_case": [], "case_status": ["AsDf", "1234", "ab", "#a@C", "#AsdfW^45", "#6@2", "#$a^D", "#ccc"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
{"name": "HumanEval/162_prompt2cp", "code_candidates": [{"code": "import hashlib\nfrom typing import Optional\n\ndef compute_md5(input_string: Optional[str]) -> str:\n    if input_string is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if input_string == \"\":\n        return 'd41d8cd98f00b204e9800998ecf8427e'\n    \n    # Encode the string to UTF-8 bytes\n    encoded_string = input_string.encode('utf-8')\n    \n    # Compute MD5 hash\n    md5_hash = hashlib.md5(encoded_string)\n    \n    # Return the hexadecimal representation in lowercase\n    return md5_hash.hexdigest()", "index": 0, "passed_case": [0, 2, 3], "case_status": ["3e25960a79dbc69b674cd4ec67a72c62", "d41d8cd98f00b204e9800998ecf8427e", "0ef78513b0cb8cef12743f5aeb35f888", "5f4dcc3b5aa765d61d8327deb882cf99"]}], "dataset": "HumanEvalComm", "prompt_type": "prompt2cp"}
